var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js"(exports, module) {
    "use strict";
    function assertPath(path5) {
      if (typeof path5 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path5));
      }
    }
    function normalizeStringPosix(path5, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i = 0; i <= path5.length; ++i) {
        if (i < path5.length)
          code = path5.charCodeAt(i);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i - 1 || dots === 1) {
          } else if (lastSlash !== i - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path5.slice(lastSlash + 1, i);
            else
              res = path5.slice(lastSlash + 1, i);
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format3(sep2, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep2 + base;
    }
    var posix2 = {
      // path.resolve([from ...], to)
      resolve: function resolve3() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd2;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path5;
          if (i >= 0)
            path5 = arguments[i];
          else {
            if (cwd2 === void 0)
              cwd2 = process.cwd();
            path5 = cwd2;
          }
          assertPath(path5);
          if (path5.length === 0) {
            continue;
          }
          resolvedPath = path5 + "/" + resolvedPath;
          resolvedAbsolute = path5.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize2(path5) {
        assertPath(path5);
        if (path5.length === 0) return ".";
        var isAbsolute2 = path5.charCodeAt(0) === 47;
        var trailingSeparator = path5.charCodeAt(path5.length - 1) === 47;
        path5 = normalizeStringPosix(path5, !isAbsolute2);
        if (path5.length === 0 && !isAbsolute2) path5 = ".";
        if (path5.length > 0 && trailingSeparator) path5 += "/";
        if (isAbsolute2) return "/" + path5;
        return path5;
      },
      isAbsolute: function isAbsolute2(path5) {
        assertPath(path5);
        return path5.length > 0 && path5.charCodeAt(0) === 47;
      },
      join: function join() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i = 0; i < arguments.length; ++i) {
          var arg = arguments[i];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix2.normalize(joined);
      },
      relative: function relative2(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return "";
        from = posix2.resolve(from);
        to = posix2.resolve(to);
        if (from === to) return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for (; i <= length; ++i) {
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === 47) {
                return to.slice(toStart + i + 1);
              } else if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === 47) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i);
          var toCode = to.charCodeAt(toStart + i);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i;
        }
        var out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path5) {
        return path5;
      },
      dirname: function dirname2(path5) {
        assertPath(path5);
        if (path5.length === 0) return ".";
        var code = path5.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i = path5.length - 1; i >= 1; --i) {
          code = path5.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path5.slice(0, end);
      },
      basename: function basename5(path5, ext) {
        if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path5);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path5.length) {
          if (ext.length === path5.length && ext === path5) return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i = path5.length - 1; i >= 0; --i) {
            var code = path5.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) end = firstNonSlashEnd;
          else if (end === -1) end = path5.length;
          return path5.slice(start, end);
        } else {
          for (i = path5.length - 1; i >= 0; --i) {
            if (path5.charCodeAt(i) === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1) return "";
          return path5.slice(start, end);
        }
      },
      extname: function extname3(path5) {
        assertPath(path5);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i = path5.length - 1; i >= 0; --i) {
          var code = path5.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path5.slice(startDot, end);
      },
      format: function format3(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format3("/", pathObject);
      },
      parse: function parse5(path5) {
        assertPath(path5);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path5.length === 0) return ret;
        var code = path5.charCodeAt(0);
        var isAbsolute2 = code === 47;
        var start;
        if (isAbsolute2) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path5.length - 1;
        var preDotState = 0;
        for (; i >= start; --i) {
          code = path5.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute2) ret.base = ret.name = path5.slice(1, end);
            else ret.base = ret.name = path5.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute2) {
            ret.name = path5.slice(1, startDot);
            ret.base = path5.slice(1, end);
          } else {
            ret.name = path5.slice(startPart, startDot);
            ret.base = path5.slice(startPart, end);
          }
          ret.ext = path5.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path5.slice(0, startPart - 1);
        else if (isAbsolute2) ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix2.posix = posix2;
    module.exports = posix2;
  }
});

// node_modules/.pnpm/prettier@3.5.3/node_modules/prettier/standalone.js
var require_standalone = __commonJS({
  "node_modules/.pnpm/prettier@3.5.3/node_modules/prettier/standalone.js"(exports, module) {
    (function(t) {
      function e() {
        var o = t();
        return o.default || o;
      }
      if (typeof exports == "object" && typeof module == "object") module.exports = e();
      else if (typeof define == "function" && define.amd) define(e);
      else {
        var f2 = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        f2.prettier = e();
      }
    })(function() {
      "use strict";
      var Au = Object.create;
      var Me = Object.defineProperty;
      var vu = Object.getOwnPropertyDescriptor;
      var Bu = Object.getOwnPropertyNames;
      var wu = Object.getPrototypeOf, _u = Object.prototype.hasOwnProperty;
      var fr = (e) => {
        throw TypeError(e);
      };
      var dr = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), vt = (e, t) => {
        for (var r in t) Me(e, r, { get: t[r], enumerable: true });
      }, pr = (e, t, r, n) => {
        if (t && typeof t == "object" || typeof t == "function") for (let u of Bu(t)) !_u.call(e, u) && u !== r && Me(e, u, { get: () => t[u], enumerable: !(n = vu(t, u)) || n.enumerable });
        return e;
      };
      var Ve = (e, t, r) => (r = e != null ? Au(wu(e)) : {}, pr(t || !e || !e.__esModule ? Me(r, "default", { value: e, enumerable: true }) : r, e)), xu = (e) => pr(Me({}, "__esModule", { value: true }), e);
      var bu = (e, t, r) => t.has(e) || fr("Cannot " + r);
      var Fr = (e, t, r) => t.has(e) ? fr("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r);
      var pe = (e, t, r) => (bu(e, t, "access private method"), r);
      var st = dr((la, mn) => {
        "use strict";
        var Fn = new Proxy(String, { get: () => Fn });
        mn.exports = Fn;
      });
      var $n = dr((ur) => {
        "use strict";
        Object.defineProperty(ur, "__esModule", { value: true });
        function wi() {
          return new Proxy({}, { get: () => (e) => e });
        }
        var Wn = /\r\n|[\n\r\u2028\u2029]/;
        function _i(e, t, r) {
          let n = Object.assign({ column: 0, line: -1 }, e.start), u = Object.assign({}, n, e.end), { linesAbove: i = 2, linesBelow: o = 3 } = r || {}, s = n.line, a2 = n.column, D = u.line, l = u.column, p = Math.max(s - (i + 1), 0), f2 = Math.min(t.length, D + o);
          s === -1 && (p = 0), D === -1 && (f2 = t.length);
          let d = D - s, c = {};
          if (d) for (let F = 0; F <= d; F++) {
            let m = F + s;
            if (!a2) c[m] = true;
            else if (F === 0) {
              let h = t[m - 1].length;
              c[m] = [a2, h - a2 + 1];
            } else if (F === d) c[m] = [0, l];
            else {
              let h = t[m - F].length;
              c[m] = [0, h];
            }
          }
          else a2 === l ? a2 ? c[s] = [a2, 0] : c[s] = true : c[s] = [a2, l - a2];
          return { start: p, end: f2, markerLines: c };
        }
        function xi(e, t, r = {}) {
          let u = wi(false), i = e.split(Wn), { start: o, end: s, markerLines: a2 } = _i(t, i, r), D = t.start && typeof t.start.column == "number", l = String(s).length, f2 = e.split(Wn, s).slice(o, s).map((d, c) => {
            let F = o + 1 + c, h = ` ${` ${F}`.slice(-l)} |`, C = a2[F], v = !a2[F + 1];
            if (C) {
              let E = "";
              if (Array.isArray(C)) {
                let g = d.slice(0, Math.max(C[0] - 1, 0)).replace(/[^\t]/g, " "), j = C[1] || 1;
                E = [`
 `, u.gutter(h.replace(/\d/g, " ")), " ", g, u.marker("^").repeat(j)].join(""), v && r.message && (E += " " + u.message(r.message));
              }
              return [u.marker(">"), u.gutter(h), d.length > 0 ? ` ${d}` : "", E].join("");
            } else return ` ${u.gutter(h)}${d.length > 0 ? ` ${d}` : ""}`;
          }).join(`
`);
          return r.message && !D && (f2 = `${" ".repeat(l + 1)}${r.message}
${f2}`), f2;
        }
        ur.codeFrameColumns = xi;
      });
      var co = {};
      vt(co, { __debug: () => lo, check: () => ao, doc: () => Dr, format: () => yu, formatWithCursor: () => gu, getSupportInfo: () => Do, util: () => cr, version: () => cu });
      var Nu = (e, t, r, n) => {
        if (!(e && t == null)) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
      }, ne = Nu;
      function U() {
      }
      U.prototype = { diff: function(t, r) {
        var n, u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = u.callback;
        typeof u == "function" && (i = u, u = {});
        var o = this;
        function s(E) {
          return E = o.postProcess(E, u), i ? (setTimeout(function() {
            i(E);
          }, 0), true) : E;
        }
        t = this.castInput(t, u), r = this.castInput(r, u), t = this.removeEmpty(this.tokenize(t, u)), r = this.removeEmpty(this.tokenize(r, u));
        var a2 = r.length, D = t.length, l = 1, p = a2 + D;
        u.maxEditLength != null && (p = Math.min(p, u.maxEditLength));
        var f2 = (n = u.timeout) !== null && n !== void 0 ? n : 1 / 0, d = Date.now() + f2, c = [{ oldPos: -1, lastComponent: void 0 }], F = this.extractCommon(c[0], r, t, 0, u);
        if (c[0].oldPos + 1 >= D && F + 1 >= a2) return s(mr(o, c[0].lastComponent, r, t, o.useLongestToken));
        var m = -1 / 0, h = 1 / 0;
        function C() {
          for (var E = Math.max(m, -l); E <= Math.min(h, l); E += 2) {
            var g = void 0, j = c[E - 1], b = c[E + 1];
            j && (c[E - 1] = void 0);
            var X = false;
            if (b) {
              var ae = b.oldPos - E;
              X = b && 0 <= ae && ae < a2;
            }
            var $e = j && j.oldPos + 1 < D;
            if (!X && !$e) {
              c[E] = void 0;
              continue;
            }
            if (!$e || X && j.oldPos < b.oldPos ? g = o.addToPath(b, true, false, 0, u) : g = o.addToPath(j, false, true, 1, u), F = o.extractCommon(g, r, t, E, u), g.oldPos + 1 >= D && F + 1 >= a2) return s(mr(o, g.lastComponent, r, t, o.useLongestToken));
            c[E] = g, g.oldPos + 1 >= D && (h = Math.min(h, E - 1)), F + 1 >= a2 && (m = Math.max(m, E + 1));
          }
          l++;
        }
        if (i) (function E() {
          setTimeout(function() {
            if (l > p || Date.now() > d) return i();
            C() || E();
          }, 0);
        })();
        else for (; l <= p && Date.now() <= d; ) {
          var v = C();
          if (v) return v;
        }
      }, addToPath: function(t, r, n, u, i) {
        var o = t.lastComponent;
        return o && !i.oneChangePerToken && o.added === r && o.removed === n ? { oldPos: t.oldPos + u, lastComponent: { count: o.count + 1, added: r, removed: n, previousComponent: o.previousComponent } } : { oldPos: t.oldPos + u, lastComponent: { count: 1, added: r, removed: n, previousComponent: o } };
      }, extractCommon: function(t, r, n, u, i) {
        for (var o = r.length, s = n.length, a2 = t.oldPos, D = a2 - u, l = 0; D + 1 < o && a2 + 1 < s && this.equals(n[a2 + 1], r[D + 1], i); ) D++, a2++, l++, i.oneChangePerToken && (t.lastComponent = { count: 1, previousComponent: t.lastComponent, added: false, removed: false });
        return l && !i.oneChangePerToken && (t.lastComponent = { count: l, previousComponent: t.lastComponent, added: false, removed: false }), t.oldPos = a2, D;
      }, equals: function(t, r, n) {
        return n.comparator ? n.comparator(t, r) : t === r || n.ignoreCase && t.toLowerCase() === r.toLowerCase();
      }, removeEmpty: function(t) {
        for (var r = [], n = 0; n < t.length; n++) t[n] && r.push(t[n]);
        return r;
      }, castInput: function(t) {
        return t;
      }, tokenize: function(t) {
        return Array.from(t);
      }, join: function(t) {
        return t.join("");
      }, postProcess: function(t) {
        return t;
      } };
      function mr(e, t, r, n, u) {
        for (var i = [], o; t; ) i.push(t), o = t.previousComponent, delete t.previousComponent, t = o;
        i.reverse();
        for (var s = 0, a2 = i.length, D = 0, l = 0; s < a2; s++) {
          var p = i[s];
          if (p.removed) p.value = e.join(n.slice(l, l + p.count)), l += p.count;
          else {
            if (!p.added && u) {
              var f2 = r.slice(D, D + p.count);
              f2 = f2.map(function(d, c) {
                var F = n[l + c];
                return F.length > d.length ? F : d;
              }), p.value = e.join(f2);
            } else p.value = e.join(r.slice(D, D + p.count));
            D += p.count, p.added || (l += p.count);
          }
        }
        return i;
      }
      var ho = new U();
      function hr(e, t) {
        var r;
        for (r = 0; r < e.length && r < t.length; r++) if (e[r] != t[r]) return e.slice(0, r);
        return e.slice(0, r);
      }
      function Er(e, t) {
        var r;
        if (!e || !t || e[e.length - 1] != t[t.length - 1]) return "";
        for (r = 0; r < e.length && r < t.length; r++) if (e[e.length - (r + 1)] != t[t.length - (r + 1)]) return e.slice(-r);
        return e.slice(-r);
      }
      function Bt(e, t, r) {
        if (e.slice(0, t.length) != t) throw Error("string ".concat(JSON.stringify(e), " doesn't start with prefix ").concat(JSON.stringify(t), "; this is a bug"));
        return r + e.slice(t.length);
      }
      function wt(e, t, r) {
        if (!t) return e + r;
        if (e.slice(-t.length) != t) throw Error("string ".concat(JSON.stringify(e), " doesn't end with suffix ").concat(JSON.stringify(t), "; this is a bug"));
        return e.slice(0, -t.length) + r;
      }
      function _e(e, t) {
        return Bt(e, t, "");
      }
      function Ue(e, t) {
        return wt(e, t, "");
      }
      function Cr(e, t) {
        return t.slice(0, Ou(e, t));
      }
      function Ou(e, t) {
        var r = 0;
        e.length > t.length && (r = e.length - t.length);
        var n = t.length;
        e.length < t.length && (n = e.length);
        var u = Array(n), i = 0;
        u[0] = 0;
        for (var o = 1; o < n; o++) {
          for (t[o] == t[i] ? u[o] = u[i] : u[o] = i; i > 0 && t[o] != t[i]; ) i = u[i];
          t[o] == t[i] && i++;
        }
        i = 0;
        for (var s = r; s < e.length; s++) {
          for (; i > 0 && e[s] != t[i]; ) i = u[i];
          e[s] == t[i] && i++;
        }
        return i;
      }
      var ze = "a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}", Su = new RegExp("[".concat(ze, "]+|\\s+|[^").concat(ze, "]"), "ug"), Ke = new U();
      Ke.equals = function(e, t, r) {
        return r.ignoreCase && (e = e.toLowerCase(), t = t.toLowerCase()), e.trim() === t.trim();
      };
      Ke.tokenize = function(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r;
        if (t.intlSegmenter) {
          if (t.intlSegmenter.resolvedOptions().granularity != "word") throw new Error('The segmenter passed must have a granularity of "word"');
          r = Array.from(t.intlSegmenter.segment(e), function(i) {
            return i.segment;
          });
        } else r = e.match(Su) || [];
        var n = [], u = null;
        return r.forEach(function(i) {
          /\s/.test(i) ? u == null ? n.push(i) : n.push(n.pop() + i) : /\s/.test(u) ? n[n.length - 1] == u ? n.push(n.pop() + i) : n.push(u + i) : n.push(i), u = i;
        }), n;
      };
      Ke.join = function(e) {
        return e.map(function(t, r) {
          return r == 0 ? t : t.replace(/^\s+/, "");
        }).join("");
      };
      Ke.postProcess = function(e, t) {
        if (!e || t.oneChangePerToken) return e;
        var r = null, n = null, u = null;
        return e.forEach(function(i) {
          i.added ? n = i : i.removed ? u = i : ((n || u) && gr(r, u, n, i), r = i, n = null, u = null);
        }), (n || u) && gr(r, u, n, null), e;
      };
      function gr(e, t, r, n) {
        if (t && r) {
          var u = t.value.match(/^\s*/)[0], i = t.value.match(/\s*$/)[0], o = r.value.match(/^\s*/)[0], s = r.value.match(/\s*$/)[0];
          if (e) {
            var a2 = hr(u, o);
            e.value = wt(e.value, o, a2), t.value = _e(t.value, a2), r.value = _e(r.value, a2);
          }
          if (n) {
            var D = Er(i, s);
            n.value = Bt(n.value, s, D), t.value = Ue(t.value, D), r.value = Ue(r.value, D);
          }
        } else if (r) e && (r.value = r.value.replace(/^\s*/, "")), n && (n.value = n.value.replace(/^\s*/, ""));
        else if (e && n) {
          var l = n.value.match(/^\s*/)[0], p = t.value.match(/^\s*/)[0], f2 = t.value.match(/\s*$/)[0], d = hr(l, p);
          t.value = _e(t.value, d);
          var c = Er(_e(l, d), f2);
          t.value = Ue(t.value, c), n.value = Bt(n.value, l, c), e.value = wt(e.value, l, l.slice(0, l.length - c.length));
        } else if (n) {
          var F = n.value.match(/^\s*/)[0], m = t.value.match(/\s*$/)[0], h = Cr(m, F);
          t.value = Ue(t.value, h);
        } else if (e) {
          var C = e.value.match(/\s*$/)[0], v = t.value.match(/^\s*/)[0], E = Cr(C, v);
          t.value = _e(t.value, E);
        }
      }
      var Tu = new U();
      Tu.tokenize = function(e) {
        var t = new RegExp("(\\r?\\n)|[".concat(ze, "]+|[^\\S\\n\\r]+|[^").concat(ze, "]"), "ug");
        return e.match(t) || [];
      };
      var bt = new U();
      bt.tokenize = function(e, t) {
        t.stripTrailingCr && (e = e.replace(/\r\n/g, `
`));
        var r = [], n = e.split(/(\n|\r\n)/);
        n[n.length - 1] || n.pop();
        for (var u = 0; u < n.length; u++) {
          var i = n[u];
          u % 2 && !t.newlineIsToken ? r[r.length - 1] += i : r.push(i);
        }
        return r;
      };
      bt.equals = function(e, t, r) {
        return r.ignoreWhitespace ? ((!r.newlineIsToken || !e.includes(`
`)) && (e = e.trim()), (!r.newlineIsToken || !t.includes(`
`)) && (t = t.trim())) : r.ignoreNewlineAtEof && !r.newlineIsToken && (e.endsWith(`
`) && (e = e.slice(0, -1)), t.endsWith(`
`) && (t = t.slice(0, -1))), U.prototype.equals.call(this, e, t, r);
      };
      var ku = new U();
      ku.tokenize = function(e) {
        return e.split(/(\S.+?[.!?])(?=\s+|$)/);
      };
      var Lu = new U();
      Lu.tokenize = function(e) {
        return e.split(/([{}:;,]|\s+)/);
      };
      function _t(e) {
        "@babel/helpers - typeof";
        return _t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
          return typeof t;
        } : function(t) {
          return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        }, _t(e);
      }
      var xe = new U();
      xe.useLongestToken = true;
      xe.tokenize = bt.tokenize;
      xe.castInput = function(e, t) {
        var r = t.undefinedReplacement, n = t.stringifyReplacer, u = n === void 0 ? function(i, o) {
          return typeof o > "u" ? r : o;
        } : n;
        return typeof e == "string" ? e : JSON.stringify(xt(e, null, null, u), u, "  ");
      };
      xe.equals = function(e, t, r) {
        return U.prototype.equals.call(xe, e.replace(/,([\r\n])/g, "$1"), t.replace(/,([\r\n])/g, "$1"), r);
      };
      function xt(e, t, r, n, u) {
        t = t || [], r = r || [], n && (e = n(u, e));
        var i;
        for (i = 0; i < t.length; i += 1) if (t[i] === e) return r[i];
        var o;
        if (Object.prototype.toString.call(e) === "[object Array]") {
          for (t.push(e), o = new Array(e.length), r.push(o), i = 0; i < e.length; i += 1) o[i] = xt(e[i], t, r, n, u);
          return t.pop(), r.pop(), o;
        }
        if (e && e.toJSON && (e = e.toJSON()), _t(e) === "object" && e !== null) {
          t.push(e), o = {}, r.push(o);
          var s = [], a2;
          for (a2 in e) Object.prototype.hasOwnProperty.call(e, a2) && s.push(a2);
          for (s.sort(), i = 0; i < s.length; i += 1) a2 = s[i], o[a2] = xt(e[a2], t, r, n, a2);
          t.pop(), r.pop();
        } else o = e;
        return o;
      }
      var Ge = new U();
      Ge.tokenize = function(e) {
        return e.slice();
      };
      Ge.join = Ge.removeEmpty = function(e) {
        return e;
      };
      function yr(e, t, r) {
        return Ge.diff(e, t, r);
      }
      function Ar(e) {
        let t = e.indexOf("\r");
        return t !== -1 ? e.charAt(t + 1) === `
` ? "crlf" : "cr" : "lf";
      }
      function be(e) {
        switch (e) {
          case "cr":
            return "\r";
          case "crlf":
            return `\r
`;
          default:
            return `
`;
        }
      }
      function Nt(e, t) {
        let r;
        switch (t) {
          case `
`:
            r = /\n/gu;
            break;
          case "\r":
            r = /\r/gu;
            break;
          case `\r
`:
            r = /\r\n/gu;
            break;
          default:
            throw new Error(`Unexpected "eol" ${JSON.stringify(t)}.`);
        }
        let n = e.match(r);
        return n ? n.length : 0;
      }
      function vr(e) {
        return ne(false, e, /\r\n?/gu, `
`);
      }
      var $ = "string", H = "array", z = "cursor", T = "indent", k = "align", L = "trim", B = "group", N = "fill", w = "if-break", P = "indent-if-break", I = "line-suffix", R = "line-suffix-boundary", y = "line", O = "label", _ = "break-parent", Je = /* @__PURE__ */ new Set([z, T, k, L, B, N, w, P, I, R, y, O, _]);
      var Pu = (e, t, r) => {
        if (!(e && t == null)) return Array.isArray(t) || typeof t == "string" ? t[r < 0 ? t.length + r : r] : t.at(r);
      }, A2 = Pu;
      function Iu(e) {
        if (typeof e == "string") return $;
        if (Array.isArray(e)) return H;
        if (!e) return;
        let { type: t } = e;
        if (Je.has(t)) return t;
      }
      var M = Iu;
      var Ru = (e) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e);
      function Yu(e) {
        let t = e === null ? "null" : typeof e;
        if (t !== "string" && t !== "object") return `Unexpected doc '${t}', 
Expected it to be 'string' or 'object'.`;
        if (M(e)) throw new Error("doc is valid.");
        let r = Object.prototype.toString.call(e);
        if (r !== "[object Object]") return `Unexpected doc '${r}'.`;
        let n = Ru([...Je].map((u) => `'${u}'`));
        return `Unexpected doc.type '${e.type}'.
Expected it to be ${n}.`;
      }
      var Ot = class extends Error {
        name = "InvalidDocError";
        constructor(t) {
          super(Yu(t)), this.doc = t;
        }
      }, Q = Ot;
      var Br = {};
      function ju(e, t, r, n) {
        let u = [e];
        for (; u.length > 0; ) {
          let i = u.pop();
          if (i === Br) {
            r(u.pop());
            continue;
          }
          r && u.push(i, Br);
          let o = M(i);
          if (!o) throw new Q(i);
          if ((t == null ? void 0 : t(i)) !== false) switch (o) {
            case H:
            case N: {
              let s = o === H ? i : i.parts;
              for (let a2 = s.length, D = a2 - 1; D >= 0; --D) u.push(s[D]);
              break;
            }
            case w:
              u.push(i.flatContents, i.breakContents);
              break;
            case B:
              if (n && i.expandedStates) for (let s = i.expandedStates.length, a2 = s - 1; a2 >= 0; --a2) u.push(i.expandedStates[a2]);
              else u.push(i.contents);
              break;
            case k:
            case T:
            case P:
            case O:
            case I:
              u.push(i.contents);
              break;
            case $:
            case z:
            case L:
            case R:
            case y:
            case _:
              break;
            default:
              throw new Q(i);
          }
        }
      }
      var Fe = ju;
      function Oe(e, t) {
        if (typeof e == "string") return t(e);
        let r = /* @__PURE__ */ new Map();
        return n(e);
        function n(i) {
          if (r.has(i)) return r.get(i);
          let o = u(i);
          return r.set(i, o), o;
        }
        function u(i) {
          switch (M(i)) {
            case H:
              return t(i.map(n));
            case N:
              return t({ ...i, parts: i.parts.map(n) });
            case w:
              return t({ ...i, breakContents: n(i.breakContents), flatContents: n(i.flatContents) });
            case B: {
              let { expandedStates: o, contents: s } = i;
              return o ? (o = o.map(n), s = o[0]) : s = n(s), t({ ...i, contents: s, expandedStates: o });
            }
            case k:
            case T:
            case P:
            case O:
            case I:
              return t({ ...i, contents: n(i.contents) });
            case $:
            case z:
            case L:
            case R:
            case y:
            case _:
              return t(i);
            default:
              throw new Q(i);
          }
        }
      }
      function qe(e, t, r) {
        let n = r, u = false;
        function i(o) {
          if (u) return false;
          let s = t(o);
          s !== void 0 && (u = true, n = s);
        }
        return Fe(e, i), n;
      }
      function Hu(e) {
        if (e.type === B && e.break || e.type === y && e.hard || e.type === _) return true;
      }
      function xr(e) {
        return qe(e, Hu, false);
      }
      function wr(e) {
        if (e.length > 0) {
          let t = A2(false, e, -1);
          !t.expandedStates && !t.break && (t.break = "propagated");
        }
        return null;
      }
      function br(e) {
        let t = /* @__PURE__ */ new Set(), r = [];
        function n(i) {
          if (i.type === _ && wr(r), i.type === B) {
            if (r.push(i), t.has(i)) return false;
            t.add(i);
          }
        }
        function u(i) {
          i.type === B && r.pop().break && wr(r);
        }
        Fe(e, n, u, true);
      }
      function Wu(e) {
        return e.type === y && !e.hard ? e.soft ? "" : " " : e.type === w ? e.flatContents : e;
      }
      function Nr(e) {
        return Oe(e, Wu);
      }
      function _r(e) {
        for (e = [...e]; e.length >= 2 && A2(false, e, -2).type === y && A2(false, e, -1).type === _; ) e.length -= 2;
        if (e.length > 0) {
          let t = Ne(A2(false, e, -1));
          e[e.length - 1] = t;
        }
        return e;
      }
      function Ne(e) {
        switch (M(e)) {
          case T:
          case P:
          case B:
          case I:
          case O: {
            let t = Ne(e.contents);
            return { ...e, contents: t };
          }
          case w:
            return { ...e, breakContents: Ne(e.breakContents), flatContents: Ne(e.flatContents) };
          case N:
            return { ...e, parts: _r(e.parts) };
          case H:
            return _r(e);
          case $:
            return e.replace(/[\n\r]*$/u, "");
          case k:
          case z:
          case L:
          case R:
          case y:
          case _:
            break;
          default:
            throw new Q(e);
        }
        return e;
      }
      function Xe(e) {
        return Ne(Mu(e));
      }
      function $u(e) {
        switch (M(e)) {
          case N:
            if (e.parts.every((t) => t === "")) return "";
            break;
          case B:
            if (!e.contents && !e.id && !e.break && !e.expandedStates) return "";
            if (e.contents.type === B && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
            break;
          case k:
          case T:
          case P:
          case I:
            if (!e.contents) return "";
            break;
          case w:
            if (!e.flatContents && !e.breakContents) return "";
            break;
          case H: {
            let t = [];
            for (let r of e) {
              if (!r) continue;
              let [n, ...u] = Array.isArray(r) ? r : [r];
              typeof n == "string" && typeof A2(false, t, -1) == "string" ? t[t.length - 1] += n : t.push(n), t.push(...u);
            }
            return t.length === 0 ? "" : t.length === 1 ? t[0] : t;
          }
          case $:
          case z:
          case L:
          case R:
          case y:
          case O:
          case _:
            break;
          default:
            throw new Q(e);
        }
        return e;
      }
      function Mu(e) {
        return Oe(e, (t) => $u(t));
      }
      function Or(e, t = Qe) {
        return Oe(e, (r) => typeof r == "string" ? Se(t, r.split(`
`)) : r);
      }
      function Vu(e) {
        if (e.type === y) return true;
      }
      function Sr(e) {
        return qe(e, Vu, false);
      }
      function me(e, t) {
        return e.type === O ? { ...e, contents: t(e.contents) } : t(e);
      }
      var St = () => {
      }, G = St, Tt = St, Tr = St;
      function le(e) {
        return G(e), { type: T, contents: e };
      }
      function De(e, t) {
        return G(t), { type: k, contents: t, n: e };
      }
      function kt(e, t = {}) {
        return G(e), Tt(t.expandedStates, true), { type: B, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
      }
      function kr(e) {
        return De(Number.NEGATIVE_INFINITY, e);
      }
      function Lr(e) {
        return De({ type: "root" }, e);
      }
      function Pr(e) {
        return De(-1, e);
      }
      function Ir(e, t) {
        return kt(e[0], { ...t, expandedStates: e });
      }
      function Rr(e) {
        return Tr(e), { type: N, parts: e };
      }
      function Yr(e, t = "", r = {}) {
        return G(e), t !== "" && G(t), { type: w, breakContents: e, flatContents: t, groupId: r.groupId };
      }
      function jr(e, t) {
        return G(e), { type: P, contents: e, groupId: t.groupId, negate: t.negate };
      }
      function Te(e) {
        return G(e), { type: I, contents: e };
      }
      var Hr = { type: R }, he = { type: _ }, Wr = { type: L }, ke = { type: y, hard: true }, Lt = { type: y, hard: true, literal: true }, Ze = { type: y }, $r = { type: y, soft: true }, K = [ke, he], Qe = [Lt, he], Z = { type: z };
      function Se(e, t) {
        G(e), Tt(t);
        let r = [];
        for (let n = 0; n < t.length; n++) n !== 0 && r.push(e), r.push(t[n]);
        return r;
      }
      function et(e, t, r) {
        G(e);
        let n = e;
        if (t > 0) {
          for (let u = 0; u < Math.floor(t / r); ++u) n = le(n);
          n = De(t % r, n), n = De(Number.NEGATIVE_INFINITY, n);
        }
        return n;
      }
      function Mr(e, t) {
        return G(t), e ? { type: O, label: e, contents: t } : t;
      }
      function ee(e) {
        var t;
        if (!e) return "";
        if (Array.isArray(e)) {
          let r = [];
          for (let n of e) if (Array.isArray(n)) r.push(...ee(n));
          else {
            let u = ee(n);
            u !== "" && r.push(u);
          }
          return r;
        }
        return e.type === w ? { ...e, breakContents: ee(e.breakContents), flatContents: ee(e.flatContents) } : e.type === B ? { ...e, contents: ee(e.contents), expandedStates: (t = e.expandedStates) == null ? void 0 : t.map(ee) } : e.type === N ? { type: "fill", parts: e.parts.map(ee) } : e.contents ? { ...e, contents: ee(e.contents) } : e;
      }
      function Vr(e) {
        let t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ new Set();
        return n(ee(e));
        function n(i, o, s) {
          var a2, D;
          if (typeof i == "string") return JSON.stringify(i);
          if (Array.isArray(i)) {
            let l = i.map(n).filter(Boolean);
            return l.length === 1 ? l[0] : `[${l.join(", ")}]`;
          }
          if (i.type === y) {
            let l = ((a2 = s == null ? void 0 : s[o + 1]) == null ? void 0 : a2.type) === _;
            return i.literal ? l ? "literalline" : "literallineWithoutBreakParent" : i.hard ? l ? "hardline" : "hardlineWithoutBreakParent" : i.soft ? "softline" : "line";
          }
          if (i.type === _) return ((D = s == null ? void 0 : s[o - 1]) == null ? void 0 : D.type) === y && s[o - 1].hard ? void 0 : "breakParent";
          if (i.type === L) return "trim";
          if (i.type === T) return "indent(" + n(i.contents) + ")";
          if (i.type === k) return i.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + n(i.contents) + ")" : i.n < 0 ? "dedent(" + n(i.contents) + ")" : i.n.type === "root" ? "markAsRoot(" + n(i.contents) + ")" : "align(" + JSON.stringify(i.n) + ", " + n(i.contents) + ")";
          if (i.type === w) return "ifBreak(" + n(i.breakContents) + (i.flatContents ? ", " + n(i.flatContents) : "") + (i.groupId ? (i.flatContents ? "" : ', ""') + `, { groupId: ${u(i.groupId)} }` : "") + ")";
          if (i.type === P) {
            let l = [];
            i.negate && l.push("negate: true"), i.groupId && l.push(`groupId: ${u(i.groupId)}`);
            let p = l.length > 0 ? `, { ${l.join(", ")} }` : "";
            return `indentIfBreak(${n(i.contents)}${p})`;
          }
          if (i.type === B) {
            let l = [];
            i.break && i.break !== "propagated" && l.push("shouldBreak: true"), i.id && l.push(`id: ${u(i.id)}`);
            let p = l.length > 0 ? `, { ${l.join(", ")} }` : "";
            return i.expandedStates ? `conditionalGroup([${i.expandedStates.map((f2) => n(f2)).join(",")}]${p})` : `group(${n(i.contents)}${p})`;
          }
          if (i.type === N) return `fill([${i.parts.map((l) => n(l)).join(", ")}])`;
          if (i.type === I) return "lineSuffix(" + n(i.contents) + ")";
          if (i.type === R) return "lineSuffixBoundary";
          if (i.type === O) return `label(${JSON.stringify(i.label)}, ${n(i.contents)})`;
          throw new Error("Unknown doc type " + i.type);
        }
        function u(i) {
          if (typeof i != "symbol") return JSON.stringify(String(i));
          if (i in t) return t[i];
          let o = i.description || "symbol";
          for (let s = 0; ; s++) {
            let a2 = o + (s > 0 ? ` #${s}` : "");
            if (!r.has(a2)) return r.add(a2), t[i] = `Symbol.for(${JSON.stringify(a2)})`;
          }
        }
      }
      var Ur = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
      function zr(e) {
        return e === 12288 || e >= 65281 && e <= 65376 || e >= 65504 && e <= 65510;
      }
      function Gr(e) {
        return e >= 4352 && e <= 4447 || e === 8986 || e === 8987 || e === 9001 || e === 9002 || e >= 9193 && e <= 9196 || e === 9200 || e === 9203 || e === 9725 || e === 9726 || e === 9748 || e === 9749 || e >= 9776 && e <= 9783 || e >= 9800 && e <= 9811 || e === 9855 || e >= 9866 && e <= 9871 || e === 9875 || e === 9889 || e === 9898 || e === 9899 || e === 9917 || e === 9918 || e === 9924 || e === 9925 || e === 9934 || e === 9940 || e === 9962 || e === 9970 || e === 9971 || e === 9973 || e === 9978 || e === 9981 || e === 9989 || e === 9994 || e === 9995 || e === 10024 || e === 10060 || e === 10062 || e >= 10067 && e <= 10069 || e === 10071 || e >= 10133 && e <= 10135 || e === 10160 || e === 10175 || e === 11035 || e === 11036 || e === 11088 || e === 11093 || e >= 11904 && e <= 11929 || e >= 11931 && e <= 12019 || e >= 12032 && e <= 12245 || e >= 12272 && e <= 12287 || e >= 12289 && e <= 12350 || e >= 12353 && e <= 12438 || e >= 12441 && e <= 12543 || e >= 12549 && e <= 12591 || e >= 12593 && e <= 12686 || e >= 12688 && e <= 12773 || e >= 12783 && e <= 12830 || e >= 12832 && e <= 12871 || e >= 12880 && e <= 42124 || e >= 42128 && e <= 42182 || e >= 43360 && e <= 43388 || e >= 44032 && e <= 55203 || e >= 63744 && e <= 64255 || e >= 65040 && e <= 65049 || e >= 65072 && e <= 65106 || e >= 65108 && e <= 65126 || e >= 65128 && e <= 65131 || e >= 94176 && e <= 94180 || e === 94192 || e === 94193 || e >= 94208 && e <= 100343 || e >= 100352 && e <= 101589 || e >= 101631 && e <= 101640 || e >= 110576 && e <= 110579 || e >= 110581 && e <= 110587 || e === 110589 || e === 110590 || e >= 110592 && e <= 110882 || e === 110898 || e >= 110928 && e <= 110930 || e === 110933 || e >= 110948 && e <= 110951 || e >= 110960 && e <= 111355 || e >= 119552 && e <= 119638 || e >= 119648 && e <= 119670 || e === 126980 || e === 127183 || e === 127374 || e >= 127377 && e <= 127386 || e >= 127488 && e <= 127490 || e >= 127504 && e <= 127547 || e >= 127552 && e <= 127560 || e === 127568 || e === 127569 || e >= 127584 && e <= 127589 || e >= 127744 && e <= 127776 || e >= 127789 && e <= 127797 || e >= 127799 && e <= 127868 || e >= 127870 && e <= 127891 || e >= 127904 && e <= 127946 || e >= 127951 && e <= 127955 || e >= 127968 && e <= 127984 || e === 127988 || e >= 127992 && e <= 128062 || e === 128064 || e >= 128066 && e <= 128252 || e >= 128255 && e <= 128317 || e >= 128331 && e <= 128334 || e >= 128336 && e <= 128359 || e === 128378 || e === 128405 || e === 128406 || e === 128420 || e >= 128507 && e <= 128591 || e >= 128640 && e <= 128709 || e === 128716 || e >= 128720 && e <= 128722 || e >= 128725 && e <= 128727 || e >= 128732 && e <= 128735 || e === 128747 || e === 128748 || e >= 128756 && e <= 128764 || e >= 128992 && e <= 129003 || e === 129008 || e >= 129292 && e <= 129338 || e >= 129340 && e <= 129349 || e >= 129351 && e <= 129535 || e >= 129648 && e <= 129660 || e >= 129664 && e <= 129673 || e >= 129679 && e <= 129734 || e >= 129742 && e <= 129756 || e >= 129759 && e <= 129769 || e >= 129776 && e <= 129784 || e >= 131072 && e <= 196605 || e >= 196608 && e <= 262141;
      }
      var Kr = (e) => !(zr(e) || Gr(e));
      var Uu = /[^\x20-\x7F]/u;
      function zu(e) {
        if (!e) return 0;
        if (!Uu.test(e)) return e.length;
        e = e.replace(Ur(), "  ");
        let t = 0;
        for (let r of e) {
          let n = r.codePointAt(0);
          n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || (t += Kr(n) ? 1 : 2);
        }
        return t;
      }
      var Le = zu;
      var Y = /* @__PURE__ */ Symbol("MODE_BREAK"), J = /* @__PURE__ */ Symbol("MODE_FLAT"), Ee = /* @__PURE__ */ Symbol("cursor"), Pt = /* @__PURE__ */ Symbol("DOC_FILL_PRINTED_LENGTH");
      function Jr() {
        return { value: "", length: 0, queue: [] };
      }
      function Gu(e, t) {
        return It(e, { type: "indent" }, t);
      }
      function Ku(e, t, r) {
        return t === Number.NEGATIVE_INFINITY ? e.root || Jr() : t < 0 ? It(e, { type: "dedent" }, r) : t ? t.type === "root" ? { ...e, root: e } : It(e, { type: typeof t == "string" ? "stringAlign" : "numberAlign", n: t }, r) : e;
      }
      function It(e, t, r) {
        let n = t.type === "dedent" ? e.queue.slice(0, -1) : [...e.queue, t], u = "", i = 0, o = 0, s = 0;
        for (let c of n) switch (c.type) {
          case "indent":
            l(), r.useTabs ? a2(1) : D(r.tabWidth);
            break;
          case "stringAlign":
            l(), u += c.n, i += c.n.length;
            break;
          case "numberAlign":
            o += 1, s += c.n;
            break;
          default:
            throw new Error(`Unexpected type '${c.type}'`);
        }
        return f2(), { ...e, value: u, length: i, queue: n };
        function a2(c) {
          u += "	".repeat(c), i += r.tabWidth * c;
        }
        function D(c) {
          u += " ".repeat(c), i += c;
        }
        function l() {
          r.useTabs ? p() : f2();
        }
        function p() {
          o > 0 && a2(o), d();
        }
        function f2() {
          s > 0 && D(s), d();
        }
        function d() {
          o = 0, s = 0;
        }
      }
      function Rt(e) {
        let t = 0, r = 0, n = e.length;
        e: for (; n--; ) {
          let u = e[n];
          if (u === Ee) {
            r++;
            continue;
          }
          for (let i = u.length - 1; i >= 0; i--) {
            let o = u[i];
            if (o === " " || o === "	") t++;
            else {
              e[n] = u.slice(0, i + 1);
              break e;
            }
          }
        }
        if (t > 0 || r > 0) for (e.length = n + 1; r-- > 0; ) e.push(Ee);
        return t;
      }
      function tt(e, t, r, n, u, i) {
        if (r === Number.POSITIVE_INFINITY) return true;
        let o = t.length, s = [e], a2 = [];
        for (; r >= 0; ) {
          if (s.length === 0) {
            if (o === 0) return true;
            s.push(t[--o]);
            continue;
          }
          let { mode: D, doc: l } = s.pop(), p = M(l);
          switch (p) {
            case $:
              a2.push(l), r -= Le(l);
              break;
            case H:
            case N: {
              let f2 = p === H ? l : l.parts, d = l[Pt] ?? 0;
              for (let c = f2.length - 1; c >= d; c--) s.push({ mode: D, doc: f2[c] });
              break;
            }
            case T:
            case k:
            case P:
            case O:
              s.push({ mode: D, doc: l.contents });
              break;
            case L:
              r += Rt(a2);
              break;
            case B: {
              if (i && l.break) return false;
              let f2 = l.break ? Y : D, d = l.expandedStates && f2 === Y ? A2(false, l.expandedStates, -1) : l.contents;
              s.push({ mode: f2, doc: d });
              break;
            }
            case w: {
              let d = (l.groupId ? u[l.groupId] || J : D) === Y ? l.breakContents : l.flatContents;
              d && s.push({ mode: D, doc: d });
              break;
            }
            case y:
              if (D === Y || l.hard) return true;
              l.soft || (a2.push(" "), r--);
              break;
            case I:
              n = true;
              break;
            case R:
              if (n) return false;
              break;
          }
        }
        return false;
      }
      function Ce(e, t) {
        let r = {}, n = t.printWidth, u = be(t.endOfLine), i = 0, o = [{ ind: Jr(), mode: Y, doc: e }], s = [], a2 = false, D = [], l = 0;
        for (br(e); o.length > 0; ) {
          let { ind: f2, mode: d, doc: c } = o.pop();
          switch (M(c)) {
            case $: {
              let F = u !== `
` ? ne(false, c, `
`, u) : c;
              s.push(F), o.length > 0 && (i += Le(F));
              break;
            }
            case H:
              for (let F = c.length - 1; F >= 0; F--) o.push({ ind: f2, mode: d, doc: c[F] });
              break;
            case z:
              if (l >= 2) throw new Error("There are too many 'cursor' in doc.");
              s.push(Ee), l++;
              break;
            case T:
              o.push({ ind: Gu(f2, t), mode: d, doc: c.contents });
              break;
            case k:
              o.push({ ind: Ku(f2, c.n, t), mode: d, doc: c.contents });
              break;
            case L:
              i -= Rt(s);
              break;
            case B:
              switch (d) {
                case J:
                  if (!a2) {
                    o.push({ ind: f2, mode: c.break ? Y : J, doc: c.contents });
                    break;
                  }
                case Y: {
                  a2 = false;
                  let F = { ind: f2, mode: J, doc: c.contents }, m = n - i, h = D.length > 0;
                  if (!c.break && tt(F, o, m, h, r)) o.push(F);
                  else if (c.expandedStates) {
                    let C = A2(false, c.expandedStates, -1);
                    if (c.break) {
                      o.push({ ind: f2, mode: Y, doc: C });
                      break;
                    } else for (let v = 1; v < c.expandedStates.length + 1; v++) if (v >= c.expandedStates.length) {
                      o.push({ ind: f2, mode: Y, doc: C });
                      break;
                    } else {
                      let E = c.expandedStates[v], g = { ind: f2, mode: J, doc: E };
                      if (tt(g, o, m, h, r)) {
                        o.push(g);
                        break;
                      }
                    }
                  } else o.push({ ind: f2, mode: Y, doc: c.contents });
                  break;
                }
              }
              c.id && (r[c.id] = A2(false, o, -1).mode);
              break;
            case N: {
              let F = n - i, m = c[Pt] ?? 0, { parts: h } = c, C = h.length - m;
              if (C === 0) break;
              let v = h[m + 0], E = h[m + 1], g = { ind: f2, mode: J, doc: v }, j = { ind: f2, mode: Y, doc: v }, b = tt(g, [], F, D.length > 0, r, true);
              if (C === 1) {
                b ? o.push(g) : o.push(j);
                break;
              }
              let X = { ind: f2, mode: J, doc: E }, ae = { ind: f2, mode: Y, doc: E };
              if (C === 2) {
                b ? o.push(X, g) : o.push(ae, j);
                break;
              }
              let $e = h[m + 2], At = { ind: f2, mode: d, doc: { ...c, [Pt]: m + 2 } };
              tt({ ind: f2, mode: J, doc: [v, E, $e] }, [], F, D.length > 0, r, true) ? o.push(At, X, g) : b ? o.push(At, ae, g) : o.push(At, ae, j);
              break;
            }
            case w:
            case P: {
              let F = c.groupId ? r[c.groupId] : d;
              if (F === Y) {
                let m = c.type === w ? c.breakContents : c.negate ? c.contents : le(c.contents);
                m && o.push({ ind: f2, mode: d, doc: m });
              }
              if (F === J) {
                let m = c.type === w ? c.flatContents : c.negate ? le(c.contents) : c.contents;
                m && o.push({ ind: f2, mode: d, doc: m });
              }
              break;
            }
            case I:
              D.push({ ind: f2, mode: d, doc: c.contents });
              break;
            case R:
              D.length > 0 && o.push({ ind: f2, mode: d, doc: ke });
              break;
            case y:
              switch (d) {
                case J:
                  if (c.hard) a2 = true;
                  else {
                    c.soft || (s.push(" "), i += 1);
                    break;
                  }
                case Y:
                  if (D.length > 0) {
                    o.push({ ind: f2, mode: d, doc: c }, ...D.reverse()), D.length = 0;
                    break;
                  }
                  c.literal ? f2.root ? (s.push(u, f2.root.value), i = f2.root.length) : (s.push(u), i = 0) : (i -= Rt(s), s.push(u + f2.value), i = f2.length);
                  break;
              }
              break;
            case O:
              o.push({ ind: f2, mode: d, doc: c.contents });
              break;
            case _:
              break;
            default:
              throw new Q(c);
          }
          o.length === 0 && D.length > 0 && (o.push(...D.reverse()), D.length = 0);
        }
        let p = s.indexOf(Ee);
        if (p !== -1) {
          let f2 = s.indexOf(Ee, p + 1);
          if (f2 === -1) return { formatted: s.filter((m) => m !== Ee).join("") };
          let d = s.slice(0, p).join(""), c = s.slice(p + 1, f2).join(""), F = s.slice(f2 + 1).join("");
          return { formatted: d + c + F, cursorNodeStart: d.length, cursorNodeText: c };
        }
        return { formatted: s.join("") };
      }
      function Ju(e, t, r = 0) {
        let n = 0;
        for (let u = r; u < e.length; ++u) e[u] === "	" ? n = n + t - n % t : n++;
        return n;
      }
      var ge = Ju;
      var te, jt, rt, Yt = class {
        constructor(t) {
          Fr(this, te);
          this.stack = [t];
        }
        get key() {
          let { stack: t, siblings: r } = this;
          return A2(false, t, r === null ? -2 : -4) ?? null;
        }
        get index() {
          return this.siblings === null ? null : A2(false, this.stack, -2);
        }
        get node() {
          return A2(false, this.stack, -1);
        }
        get parent() {
          return this.getNode(1);
        }
        get grandparent() {
          return this.getNode(2);
        }
        get isInArray() {
          return this.siblings !== null;
        }
        get siblings() {
          let { stack: t } = this, r = A2(false, t, -3);
          return Array.isArray(r) ? r : null;
        }
        get next() {
          let { siblings: t } = this;
          return t === null ? null : t[this.index + 1];
        }
        get previous() {
          let { siblings: t } = this;
          return t === null ? null : t[this.index - 1];
        }
        get isFirst() {
          return this.index === 0;
        }
        get isLast() {
          let { siblings: t, index: r } = this;
          return t !== null && r === t.length - 1;
        }
        get isRoot() {
          return this.stack.length === 1;
        }
        get root() {
          return this.stack[0];
        }
        get ancestors() {
          return [...pe(this, te, rt).call(this)];
        }
        getName() {
          let { stack: t } = this, { length: r } = t;
          return r > 1 ? A2(false, t, -2) : null;
        }
        getValue() {
          return A2(false, this.stack, -1);
        }
        getNode(t = 0) {
          let r = pe(this, te, jt).call(this, t);
          return r === -1 ? null : this.stack[r];
        }
        getParentNode(t = 0) {
          return this.getNode(t + 1);
        }
        call(t, ...r) {
          let { stack: n } = this, { length: u } = n, i = A2(false, n, -1);
          for (let o of r) i = i[o], n.push(o, i);
          try {
            return t(this);
          } finally {
            n.length = u;
          }
        }
        callParent(t, r = 0) {
          let n = pe(this, te, jt).call(this, r + 1), u = this.stack.splice(n + 1);
          try {
            return t(this);
          } finally {
            this.stack.push(...u);
          }
        }
        each(t, ...r) {
          let { stack: n } = this, { length: u } = n, i = A2(false, n, -1);
          for (let o of r) i = i[o], n.push(o, i);
          try {
            for (let o = 0; o < i.length; ++o) n.push(o, i[o]), t(this, o, i), n.length -= 2;
          } finally {
            n.length = u;
          }
        }
        map(t, ...r) {
          let n = [];
          return this.each((u, i, o) => {
            n[i] = t(u, i, o);
          }, ...r), n;
        }
        match(...t) {
          let r = this.stack.length - 1, n = null, u = this.stack[r--];
          for (let i of t) {
            if (u === void 0) return false;
            let o = null;
            if (typeof n == "number" && (o = n, n = this.stack[r--], u = this.stack[r--]), i && !i(u, n, o)) return false;
            n = this.stack[r--], u = this.stack[r--];
          }
          return true;
        }
        findAncestor(t) {
          for (let r of pe(this, te, rt).call(this)) if (t(r)) return r;
        }
        hasAncestor(t) {
          for (let r of pe(this, te, rt).call(this)) if (t(r)) return true;
          return false;
        }
      };
      te = /* @__PURE__ */ new WeakSet(), jt = function(t) {
        let { stack: r } = this;
        for (let n = r.length - 1; n >= 0; n -= 2) if (!Array.isArray(r[n]) && --t < 0) return n;
        return -1;
      }, rt = function* () {
        let { stack: t } = this;
        for (let r = t.length - 3; r >= 0; r -= 2) {
          let n = t[r];
          Array.isArray(n) || (yield n);
        }
      };
      var qr = Yt;
      var Xr = new Proxy(() => {
      }, { get: () => Xr }), Pe = Xr;
      function qu(e) {
        return e !== null && typeof e == "object";
      }
      var Qr = qu;
      function* ye(e, t) {
        let { getVisitorKeys: r, filter: n = () => true } = t, u = (i) => Qr(i) && n(i);
        for (let i of r(e)) {
          let o = e[i];
          if (Array.isArray(o)) for (let s of o) u(s) && (yield s);
          else u(o) && (yield o);
        }
      }
      function* Zr(e, t) {
        let r = [e];
        for (let n = 0; n < r.length; n++) {
          let u = r[n];
          for (let i of ye(u, t)) yield i, r.push(i);
        }
      }
      function en(e, t) {
        return ye(e, t).next().done;
      }
      function Ae(e) {
        return (t, r, n) => {
          let u = !!(n != null && n.backwards);
          if (r === false) return false;
          let { length: i } = t, o = r;
          for (; o >= 0 && o < i; ) {
            let s = t.charAt(o);
            if (e instanceof RegExp) {
              if (!e.test(s)) return o;
            } else if (!e.includes(s)) return o;
            u ? o-- : o++;
          }
          return o === -1 || o === i ? o : false;
        };
      }
      var tn = Ae(/\s/u), S = Ae(" 	"), nt = Ae(",; 	"), ut = Ae(/[^\n\r]/u);
      function Xu(e, t, r) {
        let n = !!(r != null && r.backwards);
        if (t === false) return false;
        let u = e.charAt(t);
        if (n) {
          if (e.charAt(t - 1) === "\r" && u === `
`) return t - 2;
          if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029") return t - 1;
        } else {
          if (u === "\r" && e.charAt(t + 1) === `
`) return t + 2;
          if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029") return t + 1;
        }
        return t;
      }
      var W = Xu;
      function Qu(e, t, r = {}) {
        let n = S(e, r.backwards ? t - 1 : t, r), u = W(e, n, r);
        return n !== u;
      }
      var V = Qu;
      function Zu(e) {
        return Array.isArray(e) && e.length > 0;
      }
      var Ht = Zu;
      var rn = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]), ei = (e) => Object.keys(e).filter((t) => !rn.has(t));
      function ti(e) {
        return e ? (t) => e(t, rn) : ei;
      }
      var q = ti;
      function ri(e) {
        let t = e.type || e.kind || "(unknown type)", r = String(e.name || e.id && (typeof e.id == "object" ? e.id.name : e.id) || e.key && (typeof e.key == "object" ? e.key.name : e.key) || e.value && (typeof e.value == "object" ? "" : String(e.value)) || e.operator || "");
        return r.length > 20 && (r = r.slice(0, 19) + "\u2026"), t + (r ? " " + r : "");
      }
      function Wt(e, t) {
        (e.comments ?? (e.comments = [])).push(t), t.printed = false, t.nodeDescription = ri(e);
      }
      function ue(e, t) {
        t.leading = true, t.trailing = false, Wt(e, t);
      }
      function re(e, t, r) {
        t.leading = false, t.trailing = false, r && (t.marker = r), Wt(e, t);
      }
      function ie(e, t) {
        t.leading = false, t.trailing = true, Wt(e, t);
      }
      var $t = /* @__PURE__ */ new WeakMap();
      function it(e, t) {
        if ($t.has(e)) return $t.get(e);
        let { printer: { getCommentChildNodes: r, canAttachComment: n, getVisitorKeys: u }, locStart: i, locEnd: o } = t;
        if (!n) return [];
        let s = ((r == null ? void 0 : r(e, t)) ?? [...ye(e, { getVisitorKeys: q(u) })]).flatMap((a2) => n(a2) ? [a2] : it(a2, t));
        return s.sort((a2, D) => i(a2) - i(D) || o(a2) - o(D)), $t.set(e, s), s;
      }
      function un(e, t, r, n) {
        let { locStart: u, locEnd: i } = r, o = u(t), s = i(t), a2 = it(e, r), D, l, p = 0, f2 = a2.length;
        for (; p < f2; ) {
          let d = p + f2 >> 1, c = a2[d], F = u(c), m = i(c);
          if (F <= o && s <= m) return un(c, t, r, c);
          if (m <= o) {
            D = c, p = d + 1;
            continue;
          }
          if (s <= F) {
            l = c, f2 = d;
            continue;
          }
          throw new Error("Comment location overlaps with node location");
        }
        if ((n == null ? void 0 : n.type) === "TemplateLiteral") {
          let { quasis: d } = n, c = Vt(d, t, r);
          D && Vt(d, D, r) !== c && (D = null), l && Vt(d, l, r) !== c && (l = null);
        }
        return { enclosingNode: n, precedingNode: D, followingNode: l };
      }
      var Mt = () => false;
      function on(e, t) {
        let { comments: r } = e;
        if (delete e.comments, !Ht(r) || !t.printer.canAttachComment) return;
        let n = [], { locStart: u, locEnd: i, printer: { experimentalFeatures: { avoidAstMutation: o = false } = {}, handleComments: s = {} }, originalText: a2 } = t, { ownLine: D = Mt, endOfLine: l = Mt, remaining: p = Mt } = s, f2 = r.map((d, c) => ({ ...un(e, d, t), comment: d, text: a2, options: t, ast: e, isLastComment: r.length - 1 === c }));
        for (let [d, c] of f2.entries()) {
          let { comment: F, precedingNode: m, enclosingNode: h, followingNode: C, text: v, options: E, ast: g, isLastComment: j } = c;
          if (E.parser === "json" || E.parser === "json5" || E.parser === "jsonc" || E.parser === "__js_expression" || E.parser === "__ts_expression" || E.parser === "__vue_expression" || E.parser === "__vue_ts_expression") {
            if (u(F) - u(g) <= 0) {
              ue(g, F);
              continue;
            }
            if (i(F) - i(g) >= 0) {
              ie(g, F);
              continue;
            }
          }
          let b;
          if (o ? b = [c] : (F.enclosingNode = h, F.precedingNode = m, F.followingNode = C, b = [F, v, E, g, j]), ni(v, E, f2, d)) F.placement = "ownLine", D(...b) || (C ? ue(C, F) : m ? ie(m, F) : h ? re(h, F) : re(g, F));
          else if (ui(v, E, f2, d)) F.placement = "endOfLine", l(...b) || (m ? ie(m, F) : C ? ue(C, F) : h ? re(h, F) : re(g, F));
          else if (F.placement = "remaining", !p(...b)) if (m && C) {
            let X = n.length;
            X > 0 && n[X - 1].followingNode !== C && nn(n, E), n.push(c);
          } else m ? ie(m, F) : C ? ue(C, F) : h ? re(h, F) : re(g, F);
        }
        if (nn(n, t), !o) for (let d of r) delete d.precedingNode, delete d.enclosingNode, delete d.followingNode;
      }
      var sn = (e) => !/[\S\n\u2028\u2029]/u.test(e);
      function ni(e, t, r, n) {
        let { comment: u, precedingNode: i } = r[n], { locStart: o, locEnd: s } = t, a2 = o(u);
        if (i) for (let D = n - 1; D >= 0; D--) {
          let { comment: l, precedingNode: p } = r[D];
          if (p !== i || !sn(e.slice(s(l), a2))) break;
          a2 = o(l);
        }
        return V(e, a2, { backwards: true });
      }
      function ui(e, t, r, n) {
        let { comment: u, followingNode: i } = r[n], { locStart: o, locEnd: s } = t, a2 = s(u);
        if (i) for (let D = n + 1; D < r.length; D++) {
          let { comment: l, followingNode: p } = r[D];
          if (p !== i || !sn(e.slice(a2, o(l)))) break;
          a2 = s(l);
        }
        return V(e, a2);
      }
      function nn(e, t) {
        var s, a2;
        let r = e.length;
        if (r === 0) return;
        let { precedingNode: n, followingNode: u } = e[0], i = t.locStart(u), o;
        for (o = r; o > 0; --o) {
          let { comment: D, precedingNode: l, followingNode: p } = e[o - 1];
          Pe.strictEqual(l, n), Pe.strictEqual(p, u);
          let f2 = t.originalText.slice(t.locEnd(D), i);
          if (((a2 = (s = t.printer).isGap) == null ? void 0 : a2.call(s, f2, t)) ?? /^[\s(]*$/u.test(f2)) i = t.locStart(D);
          else break;
        }
        for (let [D, { comment: l }] of e.entries()) D < o ? ie(n, l) : ue(u, l);
        for (let D of [n, u]) D.comments && D.comments.length > 1 && D.comments.sort((l, p) => t.locStart(l) - t.locStart(p));
        e.length = 0;
      }
      function Vt(e, t, r) {
        let n = r.locStart(t) - 1;
        for (let u = 1; u < e.length; ++u) if (n < r.locStart(e[u])) return u - 1;
        return 0;
      }
      function ii(e, t) {
        let r = t - 1;
        r = S(e, r, { backwards: true }), r = W(e, r, { backwards: true }), r = S(e, r, { backwards: true });
        let n = W(e, r, { backwards: true });
        return r !== n;
      }
      var Ie = ii;
      function an(e, t) {
        let r = e.node;
        return r.printed = true, t.printer.printComment(e, t);
      }
      function oi(e, t) {
        var l;
        let r = e.node, n = [an(e, t)], { printer: u, originalText: i, locStart: o, locEnd: s } = t;
        if ((l = u.isBlockComment) == null ? void 0 : l.call(u, r)) {
          let p = V(i, s(r)) ? V(i, o(r), { backwards: true }) ? K : Ze : " ";
          n.push(p);
        } else n.push(K);
        let D = W(i, S(i, s(r)));
        return D !== false && V(i, D) && n.push(K), n;
      }
      function si(e, t, r) {
        var D;
        let n = e.node, u = an(e, t), { printer: i, originalText: o, locStart: s } = t, a2 = (D = i.isBlockComment) == null ? void 0 : D.call(i, n);
        if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || V(o, s(n), { backwards: true })) {
          let l = Ie(o, s(n));
          return { doc: Te([K, l ? K : "", u]), isBlock: a2, hasLineSuffix: true };
        }
        return !a2 || r != null && r.hasLineSuffix ? { doc: [Te([" ", u]), he], isBlock: a2, hasLineSuffix: true } : { doc: [" ", u], isBlock: a2, hasLineSuffix: false };
      }
      function ai(e, t) {
        let r = e.node;
        if (!r) return {};
        let n = t[/* @__PURE__ */ Symbol.for("printedComments")];
        if ((r.comments || []).filter((a2) => !n.has(a2)).length === 0) return { leading: "", trailing: "" };
        let i = [], o = [], s;
        return e.each(() => {
          let a2 = e.node;
          if (n != null && n.has(a2)) return;
          let { leading: D, trailing: l } = a2;
          D ? i.push(oi(e, t)) : l && (s = si(e, t, s), o.push(s.doc));
        }, "comments"), { leading: i, trailing: o };
      }
      function Dn(e, t, r) {
        let { leading: n, trailing: u } = ai(e, r);
        return !n && !u ? t : me(t, (i) => [n, i, u]);
      }
      function ln(e) {
        let { [/* @__PURE__ */ Symbol.for("comments")]: t, [/* @__PURE__ */ Symbol.for("printedComments")]: r } = e;
        for (let n of t) {
          if (!n.printed && !r.has(n)) throw new Error('Comment "' + n.value.trim() + '" was not printed. Please report this error!');
          delete n.printed;
        }
      }
      function Di(e) {
        return () => {
        };
      }
      var cn = Di;
      var Re = class extends Error {
        name = "ConfigError";
      }, Ye = class extends Error {
        name = "UndefinedParserError";
      };
      var fn = { cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (e) => typeof e == "string" || typeof e == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }] }, plugins: { type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e) => typeof e == "string" || typeof e == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: false, description: `Require either '@prettier' or '@format' to be present in the file's first docblock comment
in order for it to be formatted.`, cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
      function ot({ plugins: e = [], showDeprecated: t = false } = {}) {
        let r = e.flatMap((u) => u.languages ?? []), n = [];
        for (let u of ci(Object.assign({}, ...e.map(({ options: i }) => i), fn))) !t && u.deprecated || (Array.isArray(u.choices) && (t || (u.choices = u.choices.filter((i) => !i.deprecated)), u.name === "parser" && (u.choices = [...u.choices, ...li(u.choices, r, e)])), u.pluginDefaults = Object.fromEntries(e.filter((i) => {
          var o;
          return ((o = i.defaultOptions) == null ? void 0 : o[u.name]) !== void 0;
        }).map((i) => [i.name, i.defaultOptions[u.name]])), n.push(u));
        return { languages: r, options: n };
      }
      function* li(e, t, r) {
        let n = new Set(e.map((u) => u.value));
        for (let u of t) if (u.parsers) {
          for (let i of u.parsers) if (!n.has(i)) {
            n.add(i);
            let o = r.find((a2) => a2.parsers && Object.prototype.hasOwnProperty.call(a2.parsers, i)), s = u.name;
            o != null && o.name && (s += ` (plugin: ${o.name})`), yield { value: i, description: s };
          }
        }
      }
      function ci(e) {
        let t = [];
        for (let [r, n] of Object.entries(e)) {
          let u = { name: r, ...n };
          Array.isArray(u.default) && (u.default = A2(false, u.default, -1).value), t.push(u);
        }
        return t;
      }
      var fi = (e) => String(e).split(/[/\\]/u).pop();
      function dn(e, t) {
        if (!t) return;
        let r = fi(t).toLowerCase();
        return e.find(({ filenames: n }) => n == null ? void 0 : n.some((u) => u.toLowerCase() === r)) ?? e.find(({ extensions: n }) => n == null ? void 0 : n.some((u) => r.endsWith(u)));
      }
      function di(e, t) {
        if (t) return e.find(({ name: r }) => r.toLowerCase() === t) ?? e.find(({ aliases: r }) => r == null ? void 0 : r.includes(t)) ?? e.find(({ extensions: r }) => r == null ? void 0 : r.includes(`.${t}`));
      }
      function pi(e, t) {
        let r = e.plugins.flatMap((u) => u.languages ?? []), n = di(r, t.language) ?? dn(r, t.physicalFile) ?? dn(r, t.file) ?? (t.physicalFile, void 0);
        return n == null ? void 0 : n.parsers[0];
      }
      var pn = pi;
      var oe = { key: (e) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e), value(e) {
        if (e === null || typeof e != "object") return JSON.stringify(e);
        if (Array.isArray(e)) return `[${e.map((r) => oe.value(r)).join(", ")}]`;
        let t = Object.keys(e);
        return t.length === 0 ? "{}" : `{ ${t.map((r) => `${oe.key(r)}: ${oe.value(e[r])}`).join(", ")} }`;
      }, pair: ({ key: e, value: t }) => oe.value({ [e]: t }) };
      var Ut = Ve(st(), 1), hn = (e, t, { descriptor: r }) => {
        let n = [`${Ut.default.yellow(typeof e == "string" ? r.key(e) : r.pair(e))} is deprecated`];
        return t && n.push(`we now treat it as ${Ut.default.blue(typeof t == "string" ? r.key(t) : r.pair(t))}`), n.join("; ") + ".";
      };
      var ce = Ve(st(), 1);
      var at = /* @__PURE__ */ Symbol.for("vnopts.VALUE_NOT_EXIST"), ve = /* @__PURE__ */ Symbol.for("vnopts.VALUE_UNCHANGED");
      var En = " ".repeat(2), gn = (e, t, r) => {
        let { text: n, list: u } = r.normalizeExpectedResult(r.schemas[e].expected(r)), i = [];
        return n && i.push(Cn(e, t, n, r.descriptor)), u && i.push([Cn(e, t, u.title, r.descriptor)].concat(u.values.map((o) => yn(o, r.loggerPrintWidth))).join(`
`)), An(i, r.loggerPrintWidth);
      };
      function Cn(e, t, r, n) {
        return [`Invalid ${ce.default.red(n.key(e))} value.`, `Expected ${ce.default.blue(r)},`, `but received ${t === at ? ce.default.gray("nothing") : ce.default.red(n.value(t))}.`].join(" ");
      }
      function yn({ text: e, list: t }, r) {
        let n = [];
        return e && n.push(`- ${ce.default.blue(e)}`), t && n.push([`- ${ce.default.blue(t.title)}:`].concat(t.values.map((u) => yn(u, r - En.length).replace(/^|\n/g, `$&${En}`))).join(`
`)), An(n, r);
      }
      function An(e, t) {
        if (e.length === 1) return e[0];
        let [r, n] = e, [u, i] = e.map((o) => o.split(`
`, 1)[0].length);
        return u > t && u > i ? n : r;
      }
      var Kt = Ve(st(), 1);
      var zt = [], vn = [];
      function Gt(e, t) {
        if (e === t) return 0;
        let r = e;
        e.length > t.length && (e = t, t = r);
        let n = e.length, u = t.length;
        for (; n > 0 && e.charCodeAt(~-n) === t.charCodeAt(~-u); ) n--, u--;
        let i = 0;
        for (; i < n && e.charCodeAt(i) === t.charCodeAt(i); ) i++;
        if (n -= i, u -= i, n === 0) return u;
        let o, s, a2, D, l = 0, p = 0;
        for (; l < n; ) vn[l] = e.charCodeAt(i + l), zt[l] = ++l;
        for (; p < u; ) for (o = t.charCodeAt(i + p), a2 = p++, s = p, l = 0; l < n; l++) D = o === vn[l] ? a2 : a2 + 1, a2 = zt[l], s = zt[l] = a2 > s ? D > s ? s + 1 : D : D > a2 ? a2 + 1 : D;
        return s;
      }
      var Dt = (e, t, { descriptor: r, logger: n, schemas: u }) => {
        let i = [`Ignored unknown option ${Kt.default.yellow(r.pair({ key: e, value: t }))}.`], o = Object.keys(u).sort().find((s) => Gt(e, s) < 3);
        o && i.push(`Did you mean ${Kt.default.blue(r.key(o))}?`), n.warn(i.join(" "));
      };
      var Fi = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
      function mi(e, t) {
        let r = new e(t), n = Object.create(r);
        for (let u of Fi) u in t && (n[u] = hi(t[u], r, x.prototype[u].length));
        return n;
      }
      var x = class {
        static create(t) {
          return mi(this, t);
        }
        constructor(t) {
          this.name = t.name;
        }
        default(t) {
        }
        expected(t) {
          return "nothing";
        }
        validate(t, r) {
          return false;
        }
        deprecated(t, r) {
          return false;
        }
        forward(t, r) {
        }
        redirect(t, r) {
        }
        overlap(t, r, n) {
          return t;
        }
        preprocess(t, r) {
          return t;
        }
        postprocess(t, r) {
          return ve;
        }
      };
      function hi(e, t, r) {
        return typeof e == "function" ? (...n) => e(...n.slice(0, r - 1), t, ...n.slice(r - 1)) : () => e;
      }
      var lt = class extends x {
        constructor(t) {
          super(t), this._sourceName = t.sourceName;
        }
        expected(t) {
          return t.schemas[this._sourceName].expected(t);
        }
        validate(t, r) {
          return r.schemas[this._sourceName].validate(t, r);
        }
        redirect(t, r) {
          return this._sourceName;
        }
      };
      var ct = class extends x {
        expected() {
          return "anything";
        }
        validate() {
          return true;
        }
      };
      var ft = class extends x {
        constructor({ valueSchema: t, name: r = t.name, ...n }) {
          super({ ...n, name: r }), this._valueSchema = t;
        }
        expected(t) {
          let { text: r, list: n } = t.normalizeExpectedResult(this._valueSchema.expected(t));
          return { text: r && `an array of ${r}`, list: n && { title: "an array of the following values", values: [{ list: n }] } };
        }
        validate(t, r) {
          if (!Array.isArray(t)) return false;
          let n = [];
          for (let u of t) {
            let i = r.normalizeValidateResult(this._valueSchema.validate(u, r), u);
            i !== true && n.push(i.value);
          }
          return n.length === 0 ? true : { value: n };
        }
        deprecated(t, r) {
          let n = [];
          for (let u of t) {
            let i = r.normalizeDeprecatedResult(this._valueSchema.deprecated(u, r), u);
            i !== false && n.push(...i.map(({ value: o }) => ({ value: [o] })));
          }
          return n;
        }
        forward(t, r) {
          let n = [];
          for (let u of t) {
            let i = r.normalizeForwardResult(this._valueSchema.forward(u, r), u);
            n.push(...i.map(Bn));
          }
          return n;
        }
        redirect(t, r) {
          let n = [], u = [];
          for (let i of t) {
            let o = r.normalizeRedirectResult(this._valueSchema.redirect(i, r), i);
            "remain" in o && n.push(o.remain), u.push(...o.redirect.map(Bn));
          }
          return n.length === 0 ? { redirect: u } : { redirect: u, remain: n };
        }
        overlap(t, r) {
          return t.concat(r);
        }
      };
      function Bn({ from: e, to: t }) {
        return { from: [e], to: t };
      }
      var dt = class extends x {
        expected() {
          return "true or false";
        }
        validate(t) {
          return typeof t == "boolean";
        }
      };
      function _n(e, t) {
        let r = /* @__PURE__ */ Object.create(null);
        for (let n of e) {
          let u = n[t];
          if (r[u]) throw new Error(`Duplicate ${t} ${JSON.stringify(u)}`);
          r[u] = n;
        }
        return r;
      }
      function xn(e, t) {
        let r = /* @__PURE__ */ new Map();
        for (let n of e) {
          let u = n[t];
          if (r.has(u)) throw new Error(`Duplicate ${t} ${JSON.stringify(u)}`);
          r.set(u, n);
        }
        return r;
      }
      function bn() {
        let e = /* @__PURE__ */ Object.create(null);
        return (t) => {
          let r = JSON.stringify(t);
          return e[r] ? true : (e[r] = true, false);
        };
      }
      function Nn(e, t) {
        let r = [], n = [];
        for (let u of e) t(u) ? r.push(u) : n.push(u);
        return [r, n];
      }
      function On(e) {
        return e === Math.floor(e);
      }
      function Sn(e, t) {
        if (e === t) return 0;
        let r = typeof e, n = typeof t, u = ["undefined", "object", "boolean", "number", "string"];
        return r !== n ? u.indexOf(r) - u.indexOf(n) : r !== "string" ? Number(e) - Number(t) : e.localeCompare(t);
      }
      function Tn(e) {
        return (...t) => {
          let r = e(...t);
          return typeof r == "string" ? new Error(r) : r;
        };
      }
      function Jt(e) {
        return e === void 0 ? {} : e;
      }
      function qt(e) {
        if (typeof e == "string") return { text: e };
        let { text: t, list: r } = e;
        return Ei((t || r) !== void 0, "Unexpected `expected` result, there should be at least one field."), r ? { text: t, list: { title: r.title, values: r.values.map(qt) } } : { text: t };
      }
      function Xt(e, t) {
        return e === true ? true : e === false ? { value: t } : e;
      }
      function Qt(e, t, r = false) {
        return e === false ? false : e === true ? r ? true : [{ value: t }] : "value" in e ? [e] : e.length === 0 ? false : e;
      }
      function wn(e, t) {
        return typeof e == "string" || "key" in e ? { from: t, to: e } : "from" in e ? { from: e.from, to: e.to } : { from: t, to: e.to };
      }
      function pt(e, t) {
        return e === void 0 ? [] : Array.isArray(e) ? e.map((r) => wn(r, t)) : [wn(e, t)];
      }
      function Zt(e, t) {
        let r = pt(typeof e == "object" && "redirect" in e ? e.redirect : e, t);
        return r.length === 0 ? { remain: t, redirect: r } : typeof e == "object" && "remain" in e ? { remain: e.remain, redirect: r } : { redirect: r };
      }
      function Ei(e, t) {
        if (!e) throw new Error(t);
      }
      var Ft = class extends x {
        constructor(t) {
          super(t), this._choices = xn(t.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
        }
        expected({ descriptor: t }) {
          let r = Array.from(this._choices.keys()).map((o) => this._choices.get(o)).filter(({ hidden: o }) => !o).map((o) => o.value).sort(Sn).map(t.value), n = r.slice(0, -2), u = r.slice(-2);
          return { text: n.concat(u.join(" or ")).join(", "), list: { title: "one of the following values", values: r } };
        }
        validate(t) {
          return this._choices.has(t);
        }
        deprecated(t) {
          let r = this._choices.get(t);
          return r && r.deprecated ? { value: t } : false;
        }
        forward(t) {
          let r = this._choices.get(t);
          return r ? r.forward : void 0;
        }
        redirect(t) {
          let r = this._choices.get(t);
          return r ? r.redirect : void 0;
        }
      };
      var mt = class extends x {
        expected() {
          return "a number";
        }
        validate(t, r) {
          return typeof t == "number";
        }
      };
      var ht = class extends mt {
        expected() {
          return "an integer";
        }
        validate(t, r) {
          return r.normalizeValidateResult(super.validate(t, r), t) === true && On(t);
        }
      };
      var je = class extends x {
        expected() {
          return "a string";
        }
        validate(t) {
          return typeof t == "string";
        }
      };
      var kn = oe, Ln = Dt, Pn = gn, In = hn;
      var Et = class {
        constructor(t, r) {
          let { logger: n = console, loggerPrintWidth: u = 80, descriptor: i = kn, unknown: o = Ln, invalid: s = Pn, deprecated: a2 = In, missing: D = () => false, required: l = () => false, preprocess: p = (d) => d, postprocess: f2 = () => ve } = r || {};
          this._utils = { descriptor: i, logger: n || { warn: () => {
          } }, loggerPrintWidth: u, schemas: _n(t, "name"), normalizeDefaultResult: Jt, normalizeExpectedResult: qt, normalizeDeprecatedResult: Qt, normalizeForwardResult: pt, normalizeRedirectResult: Zt, normalizeValidateResult: Xt }, this._unknownHandler = o, this._invalidHandler = Tn(s), this._deprecatedHandler = a2, this._identifyMissing = (d, c) => !(d in c) || D(d, c), this._identifyRequired = l, this._preprocess = p, this._postprocess = f2, this.cleanHistory();
        }
        cleanHistory() {
          this._hasDeprecationWarned = bn();
        }
        normalize(t) {
          let r = {}, u = [this._preprocess(t, this._utils)], i = () => {
            for (; u.length !== 0; ) {
              let o = u.shift(), s = this._applyNormalization(o, r);
              u.push(...s);
            }
          };
          i();
          for (let o of Object.keys(this._utils.schemas)) {
            let s = this._utils.schemas[o];
            if (!(o in r)) {
              let a2 = Jt(s.default(this._utils));
              "value" in a2 && u.push({ [o]: a2.value });
            }
          }
          i();
          for (let o of Object.keys(this._utils.schemas)) {
            if (!(o in r)) continue;
            let s = this._utils.schemas[o], a2 = r[o], D = s.postprocess(a2, this._utils);
            D !== ve && (this._applyValidation(D, o, s), r[o] = D);
          }
          return this._applyPostprocess(r), this._applyRequiredCheck(r), r;
        }
        _applyNormalization(t, r) {
          let n = [], { knownKeys: u, unknownKeys: i } = this._partitionOptionKeys(t);
          for (let o of u) {
            let s = this._utils.schemas[o], a2 = s.preprocess(t[o], this._utils);
            this._applyValidation(a2, o, s);
            let D = ({ from: d, to: c }) => {
              n.push(typeof c == "string" ? { [c]: d } : { [c.key]: c.value });
            }, l = ({ value: d, redirectTo: c }) => {
              let F = Qt(s.deprecated(d, this._utils), a2, true);
              if (F !== false) if (F === true) this._hasDeprecationWarned(o) || this._utils.logger.warn(this._deprecatedHandler(o, c, this._utils));
              else for (let { value: m } of F) {
                let h = { key: o, value: m };
                if (!this._hasDeprecationWarned(h)) {
                  let C = typeof c == "string" ? { key: c, value: m } : c;
                  this._utils.logger.warn(this._deprecatedHandler(h, C, this._utils));
                }
              }
            };
            pt(s.forward(a2, this._utils), a2).forEach(D);
            let f2 = Zt(s.redirect(a2, this._utils), a2);
            if (f2.redirect.forEach(D), "remain" in f2) {
              let d = f2.remain;
              r[o] = o in r ? s.overlap(r[o], d, this._utils) : d, l({ value: d });
            }
            for (let { from: d, to: c } of f2.redirect) l({ value: d, redirectTo: c });
          }
          for (let o of i) {
            let s = t[o];
            this._applyUnknownHandler(o, s, r, (a2, D) => {
              n.push({ [a2]: D });
            });
          }
          return n;
        }
        _applyRequiredCheck(t) {
          for (let r of Object.keys(this._utils.schemas)) if (this._identifyMissing(r, t) && this._identifyRequired(r)) throw this._invalidHandler(r, at, this._utils);
        }
        _partitionOptionKeys(t) {
          let [r, n] = Nn(Object.keys(t).filter((u) => !this._identifyMissing(u, t)), (u) => u in this._utils.schemas);
          return { knownKeys: r, unknownKeys: n };
        }
        _applyValidation(t, r, n) {
          let u = Xt(n.validate(t, this._utils), t);
          if (u !== true) throw this._invalidHandler(r, u.value, this._utils);
        }
        _applyUnknownHandler(t, r, n, u) {
          let i = this._unknownHandler(t, r, this._utils);
          if (i) for (let o of Object.keys(i)) {
            if (this._identifyMissing(o, i)) continue;
            let s = i[o];
            o in this._utils.schemas ? u(o, s) : n[o] = s;
          }
        }
        _applyPostprocess(t) {
          let r = this._postprocess(t, this._utils);
          if (r !== ve) {
            if (r.delete) for (let n of r.delete) delete t[n];
            if (r.override) {
              let { knownKeys: n, unknownKeys: u } = this._partitionOptionKeys(r.override);
              for (let i of n) {
                let o = r.override[i];
                this._applyValidation(o, i, this._utils.schemas[i]), t[i] = o;
              }
              for (let i of u) {
                let o = r.override[i];
                this._applyUnknownHandler(i, o, t, (s, a2) => {
                  let D = this._utils.schemas[s];
                  this._applyValidation(a2, s, D), t[s] = a2;
                });
              }
            }
          }
        }
      };
      var er;
      function gi(e, t, { logger: r = false, isCLI: n = false, passThrough: u = false, FlagSchema: i, descriptor: o } = {}) {
        if (n) {
          if (!i) throw new Error("'FlagSchema' option is required.");
          if (!o) throw new Error("'descriptor' option is required.");
        } else o = oe;
        let s = u ? Array.isArray(u) ? (f2, d) => u.includes(f2) ? { [f2]: d } : void 0 : (f2, d) => ({ [f2]: d }) : (f2, d, c) => {
          let { _: F, ...m } = c.schemas;
          return Dt(f2, d, { ...c, schemas: m });
        }, a2 = yi(t, { isCLI: n, FlagSchema: i }), D = new Et(a2, { logger: r, unknown: s, descriptor: o }), l = r !== false;
        l && er && (D._hasDeprecationWarned = er);
        let p = D.normalize(e);
        return l && (er = D._hasDeprecationWarned), p;
      }
      function yi(e, { isCLI: t, FlagSchema: r }) {
        let n = [];
        t && n.push(ct.create({ name: "_" }));
        for (let u of e) n.push(Ai(u, { isCLI: t, optionInfos: e, FlagSchema: r })), u.alias && t && n.push(lt.create({ name: u.alias, sourceName: u.name }));
        return n;
      }
      function Ai(e, { isCLI: t, optionInfos: r, FlagSchema: n }) {
        let { name: u } = e, i = { name: u }, o, s = {};
        switch (e.type) {
          case "int":
            o = ht, t && (i.preprocess = Number);
            break;
          case "string":
            o = je;
            break;
          case "choice":
            o = Ft, i.choices = e.choices.map((a2) => a2 != null && a2.redirect ? { ...a2, redirect: { to: { key: e.name, value: a2.redirect } } } : a2);
            break;
          case "boolean":
            o = dt;
            break;
          case "flag":
            o = n, i.flags = r.flatMap((a2) => [a2.alias, a2.description && a2.name, a2.oppositeDescription && `no-${a2.name}`].filter(Boolean));
            break;
          case "path":
            o = je;
            break;
          default:
            throw new Error(`Unexpected type ${e.type}`);
        }
        if (e.exception ? i.validate = (a2, D, l) => e.exception(a2) || D.validate(a2, l) : i.validate = (a2, D, l) => a2 === void 0 || D.validate(a2, l), e.redirect && (s.redirect = (a2) => a2 ? { to: typeof e.redirect == "string" ? e.redirect : { key: e.redirect.option, value: e.redirect.value } } : void 0), e.deprecated && (s.deprecated = true), t && !e.array) {
          let a2 = i.preprocess || ((D) => D);
          i.preprocess = (D, l, p) => l.preprocess(a2(Array.isArray(D) ? A2(false, D, -1) : D), p);
        }
        return e.array ? ft.create({ ...t ? { preprocess: (a2) => Array.isArray(a2) ? a2 : [a2] } : {}, ...s, valueSchema: o.create(i) }) : o.create({ ...i, ...s });
      }
      var Rn = gi;
      var vi = (e, t, r) => {
        if (!(e && t == null)) {
          if (t.findLast) return t.findLast(r);
          for (let n = t.length - 1; n >= 0; n--) {
            let u = t[n];
            if (r(u, n, t)) return u;
          }
        }
      }, tr = vi;
      function rr(e, t) {
        if (!t) throw new Error("parserName is required.");
        let r = tr(false, e, (u) => u.parsers && Object.prototype.hasOwnProperty.call(u.parsers, t));
        if (r) return r;
        let n = `Couldn't resolve parser "${t}".`;
        throw n += " Plugins must be explicitly added to the standalone bundle.", new Re(n);
      }
      function Yn(e, t) {
        if (!t) throw new Error("astFormat is required.");
        let r = tr(false, e, (u) => u.printers && Object.prototype.hasOwnProperty.call(u.printers, t));
        if (r) return r;
        let n = `Couldn't find plugin for AST format "${t}".`;
        throw n += " Plugins must be explicitly added to the standalone bundle.", new Re(n);
      }
      function Ct({ plugins: e, parser: t }) {
        let r = rr(e, t);
        return nr(r, t);
      }
      function nr(e, t) {
        let r = e.parsers[t];
        return typeof r == "function" ? r() : r;
      }
      function jn(e, t) {
        let r = e.printers[t];
        return typeof r == "function" ? r() : r;
      }
      var Hn = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
      async function Bi(e, t = {}) {
        var p;
        let r = { ...e };
        if (!r.parser) if (r.filepath) {
          if (r.parser = pn(r, { physicalFile: r.filepath }), !r.parser) throw new Ye(`No parser could be inferred for file "${r.filepath}".`);
        } else throw new Ye("No parser and no file path given, couldn't infer a parser.");
        let n = ot({ plugins: e.plugins, showDeprecated: true }).options, u = { ...Hn, ...Object.fromEntries(n.filter((f2) => f2.default !== void 0).map((f2) => [f2.name, f2.default])) }, i = rr(r.plugins, r.parser), o = await nr(i, r.parser);
        r.astFormat = o.astFormat, r.locEnd = o.locEnd, r.locStart = o.locStart;
        let s = (p = i.printers) != null && p[o.astFormat] ? i : Yn(r.plugins, o.astFormat), a2 = await jn(s, o.astFormat);
        r.printer = a2;
        let D = s.defaultOptions ? Object.fromEntries(Object.entries(s.defaultOptions).filter(([, f2]) => f2 !== void 0)) : {}, l = { ...u, ...D };
        for (let [f2, d] of Object.entries(l)) (r[f2] === null || r[f2] === void 0) && (r[f2] = d);
        return r.parser === "json" && (r.trailingComma = "none"), Rn(r, n, { passThrough: Object.keys(Hn), ...t });
      }
      var se = Bi;
      var Mn = Ve($n(), 1);
      async function bi(e, t) {
        let r = await Ct(t), n = r.preprocess ? r.preprocess(e, t) : e;
        t.originalText = n;
        let u;
        try {
          u = await r.parse(n, t, t);
        } catch (i) {
          Ni(i, e);
        }
        return { text: n, ast: u };
      }
      function Ni(e, t) {
        let { loc: r } = e;
        if (r) {
          let n = (0, Mn.codeFrameColumns)(t, r, { highlightCode: true });
          throw e.message += `
` + n, e.codeFrame = n, e;
        }
        throw e;
      }
      var fe = bi;
      async function Vn(e, t, r, n, u) {
        let { embeddedLanguageFormatting: i, printer: { embed: o, hasPrettierIgnore: s = () => false, getVisitorKeys: a2 } } = r;
        if (!o || i !== "auto") return;
        if (o.length > 2) throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/plugins#optional-embed");
        let D = q(o.getVisitorKeys ?? a2), l = [];
        d();
        let p = e.stack;
        for (let { print: c, node: F, pathStack: m } of l) try {
          e.stack = m;
          let h = await c(f2, t, e, r);
          h && u.set(F, h);
        } catch (h) {
          if (globalThis.PRETTIER_DEBUG) throw h;
        }
        e.stack = p;
        function f2(c, F) {
          return Oi(c, F, r, n);
        }
        function d() {
          let { node: c } = e;
          if (c === null || typeof c != "object" || s(e)) return;
          for (let m of D(c)) Array.isArray(c[m]) ? e.each(d, m) : e.call(d, m);
          let F = o(e, r);
          if (F) {
            if (typeof F == "function") {
              l.push({ print: F, node: c, pathStack: [...e.stack] });
              return;
            }
            u.set(c, F);
          }
        }
      }
      async function Oi(e, t, r, n) {
        let u = await se({ ...r, ...t, parentParser: r.parser, originalText: e }, { passThrough: true }), { ast: i } = await fe(e, u), o = await n(i, u);
        return Xe(o);
      }
      function Si(e, t) {
        let { originalText: r, [/* @__PURE__ */ Symbol.for("comments")]: n, locStart: u, locEnd: i, [/* @__PURE__ */ Symbol.for("printedComments")]: o } = t, { node: s } = e, a2 = u(s), D = i(s);
        for (let l of n) u(l) >= a2 && i(l) <= D && o.add(l);
        return r.slice(a2, D);
      }
      var Un = Si;
      async function He(e, t) {
        ({ ast: e } = await ir(e, t));
        let r = /* @__PURE__ */ new Map(), n = new qr(e), u = cn(t), i = /* @__PURE__ */ new Map();
        await Vn(n, s, t, He, i);
        let o = await zn(n, t, s, void 0, i);
        if (ln(t), t.nodeAfterCursor && !t.nodeBeforeCursor) return [Z, o];
        if (t.nodeBeforeCursor && !t.nodeAfterCursor) return [o, Z];
        return o;
        function s(D, l) {
          return D === void 0 || D === n ? a2(l) : Array.isArray(D) ? n.call(() => a2(l), ...D) : n.call(() => a2(l), D);
        }
        function a2(D) {
          u(n);
          let l = n.node;
          if (l == null) return "";
          let p = l && typeof l == "object" && D === void 0;
          if (p && r.has(l)) return r.get(l);
          let f2 = zn(n, t, s, D, i);
          return p && r.set(l, f2), f2;
        }
      }
      function zn(e, t, r, n, u) {
        var a2;
        let { node: i } = e, { printer: o } = t, s;
        switch ((a2 = o.hasPrettierIgnore) != null && a2.call(o, e) ? s = Un(e, t) : u.has(i) ? s = u.get(i) : s = o.print(e, t, r, n), i) {
          case t.cursorNode:
            s = me(s, (D) => [Z, D, Z]);
            break;
          case t.nodeBeforeCursor:
            s = me(s, (D) => [D, Z]);
            break;
          case t.nodeAfterCursor:
            s = me(s, (D) => [Z, D]);
            break;
        }
        return o.printComment && (!o.willPrintOwnComments || !o.willPrintOwnComments(e, t)) && (s = Dn(e, s, t)), s;
      }
      async function ir(e, t) {
        let r = e.comments ?? [];
        t[/* @__PURE__ */ Symbol.for("comments")] = r, t[/* @__PURE__ */ Symbol.for("tokens")] = e.tokens ?? [], t[/* @__PURE__ */ Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), on(e, t);
        let { printer: { preprocess: n } } = t;
        return e = n ? await n(e, t) : e, { ast: e, comments: r };
      }
      function Ti(e, t) {
        let { cursorOffset: r, locStart: n, locEnd: u } = t, i = q(t.printer.getVisitorKeys), o = (d) => n(d) <= r && u(d) >= r, s = e, a2 = [e];
        for (let d of Zr(e, { getVisitorKeys: i, filter: o })) a2.push(d), s = d;
        if (en(s, { getVisitorKeys: i })) return { cursorNode: s };
        let D, l, p = -1, f2 = Number.POSITIVE_INFINITY;
        for (; a2.length > 0 && (D === void 0 || l === void 0); ) {
          s = a2.pop();
          let d = D !== void 0, c = l !== void 0;
          for (let F of ye(s, { getVisitorKeys: i })) {
            if (!d) {
              let m = u(F);
              m <= r && m > p && (D = F, p = m);
            }
            if (!c) {
              let m = n(F);
              m >= r && m < f2 && (l = F, f2 = m);
            }
          }
        }
        return { nodeBeforeCursor: D, nodeAfterCursor: l };
      }
      var Gn = Ti;
      function ki(e, t) {
        let { printer: { massageAstNode: r, getVisitorKeys: n } } = t;
        if (!r) return e;
        let u = q(n), i = r.ignoredProperties ?? /* @__PURE__ */ new Set();
        return o(e);
        function o(s, a2) {
          if (!(s !== null && typeof s == "object")) return s;
          if (Array.isArray(s)) return s.map((f2) => o(f2, a2)).filter(Boolean);
          let D = {}, l = new Set(u(s));
          for (let f2 in s) !Object.prototype.hasOwnProperty.call(s, f2) || i.has(f2) || (l.has(f2) ? D[f2] = o(s[f2], s) : D[f2] = s[f2]);
          let p = r(s, D, a2);
          if (p !== null) return p ?? D;
        }
      }
      var Kn = ki;
      var Li = (e, t, r) => {
        if (!(e && t == null)) {
          if (t.findLastIndex) return t.findLastIndex(r);
          for (let n = t.length - 1; n >= 0; n--) {
            let u = t[n];
            if (r(u, n, t)) return n;
          }
          return -1;
        }
      }, Jn = Li;
      var Pi = ({ parser: e }) => e === "json" || e === "json5" || e === "jsonc" || e === "json-stringify";
      function Ii(e, t) {
        let r = [e.node, ...e.parentNodes], n = /* @__PURE__ */ new Set([t.node, ...t.parentNodes]);
        return r.find((u) => Qn.has(u.type) && n.has(u));
      }
      function qn(e) {
        let t = Jn(false, e, (r) => r.type !== "Program" && r.type !== "File");
        return t === -1 ? e : e.slice(0, t + 1);
      }
      function Ri(e, t, { locStart: r, locEnd: n }) {
        let u = e.node, i = t.node;
        if (u === i) return { startNode: u, endNode: i };
        let o = r(e.node);
        for (let a2 of qn(t.parentNodes)) if (r(a2) >= o) i = a2;
        else break;
        let s = n(t.node);
        for (let a2 of qn(e.parentNodes)) {
          if (n(a2) <= s) u = a2;
          else break;
          if (u === i) break;
        }
        return { startNode: u, endNode: i };
      }
      function or(e, t, r, n, u = [], i) {
        let { locStart: o, locEnd: s } = r, a2 = o(e), D = s(e);
        if (!(t > D || t < a2 || i === "rangeEnd" && t === a2 || i === "rangeStart" && t === D)) {
          for (let l of it(e, r)) {
            let p = or(l, t, r, n, [e, ...u], i);
            if (p) return p;
          }
          if (!n || n(e, u[0])) return { node: e, parentNodes: u };
        }
      }
      function Yi(e, t) {
        return t !== "DeclareExportDeclaration" && e !== "TypeParameterDeclaration" && (e === "Directive" || e === "TypeAlias" || e === "TSExportAssignment" || e.startsWith("Declare") || e.startsWith("TSDeclare") || e.endsWith("Statement") || e.endsWith("Declaration"));
      }
      var Qn = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), ji = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
      function Xn(e, t, r) {
        if (!t) return false;
        switch (e.parser) {
          case "flow":
          case "babel":
          case "babel-flow":
          case "babel-ts":
          case "typescript":
          case "acorn":
          case "espree":
          case "meriyah":
          case "__babel_estree":
            return Yi(t.type, r == null ? void 0 : r.type);
          case "json":
          case "json5":
          case "jsonc":
          case "json-stringify":
            return Qn.has(t.type);
          case "graphql":
            return ji.has(t.kind);
          case "vue":
            return t.tag !== "root";
        }
        return false;
      }
      function Zn(e, t, r) {
        let { rangeStart: n, rangeEnd: u, locStart: i, locEnd: o } = t;
        Pe.ok(u > n);
        let s = e.slice(n, u).search(/\S/u), a2 = s === -1;
        if (!a2) for (n += s; u > n && !/\S/u.test(e[u - 1]); --u) ;
        let D = or(r, n, t, (d, c) => Xn(t, d, c), [], "rangeStart"), l = a2 ? D : or(r, u, t, (d) => Xn(t, d), [], "rangeEnd");
        if (!D || !l) return { rangeStart: 0, rangeEnd: 0 };
        let p, f2;
        if (Pi(t)) {
          let d = Ii(D, l);
          p = d, f2 = d;
        } else ({ startNode: p, endNode: f2 } = Ri(D, l, t));
        return { rangeStart: Math.min(i(p), i(f2)), rangeEnd: Math.max(o(p), o(f2)) };
      }
      var nu = "\uFEFF", eu = /* @__PURE__ */ Symbol("cursor");
      async function uu(e, t, r = 0) {
        if (!e || e.trim().length === 0) return { formatted: "", cursorOffset: -1, comments: [] };
        let { ast: n, text: u } = await fe(e, t);
        t.cursorOffset >= 0 && (t = { ...t, ...Gn(n, t) });
        let i = await He(n, t, r);
        r > 0 && (i = et([K, i], r, t.tabWidth));
        let o = Ce(i, t);
        if (r > 0) {
          let a2 = o.formatted.trim();
          o.cursorNodeStart !== void 0 && (o.cursorNodeStart -= o.formatted.indexOf(a2), o.cursorNodeStart < 0 && (o.cursorNodeStart = 0, o.cursorNodeText = o.cursorNodeText.trimStart()), o.cursorNodeStart + o.cursorNodeText.length > a2.length && (o.cursorNodeText = o.cursorNodeText.trimEnd())), o.formatted = a2 + be(t.endOfLine);
        }
        let s = t[/* @__PURE__ */ Symbol.for("comments")];
        if (t.cursorOffset >= 0) {
          let a2, D, l, p;
          if ((t.cursorNode || t.nodeBeforeCursor || t.nodeAfterCursor) && o.cursorNodeText) if (l = o.cursorNodeStart, p = o.cursorNodeText, t.cursorNode) a2 = t.locStart(t.cursorNode), D = u.slice(a2, t.locEnd(t.cursorNode));
          else {
            if (!t.nodeBeforeCursor && !t.nodeAfterCursor) throw new Error("Cursor location must contain at least one of cursorNode, nodeBeforeCursor, nodeAfterCursor");
            a2 = t.nodeBeforeCursor ? t.locEnd(t.nodeBeforeCursor) : 0;
            let h = t.nodeAfterCursor ? t.locStart(t.nodeAfterCursor) : u.length;
            D = u.slice(a2, h);
          }
          else a2 = 0, D = u, l = 0, p = o.formatted;
          let f2 = t.cursorOffset - a2;
          if (D === p) return { formatted: o.formatted, cursorOffset: l + f2, comments: s };
          let d = D.split("");
          d.splice(f2, 0, eu);
          let c = p.split(""), F = yr(d, c), m = l;
          for (let h of F) if (h.removed) {
            if (h.value.includes(eu)) break;
          } else m += h.count;
          return { formatted: o.formatted, cursorOffset: m, comments: s };
        }
        return { formatted: o.formatted, cursorOffset: -1, comments: s };
      }
      async function Hi(e, t) {
        let { ast: r, text: n } = await fe(e, t), { rangeStart: u, rangeEnd: i } = Zn(n, t, r), o = n.slice(u, i), s = Math.min(u, n.lastIndexOf(`
`, u) + 1), a2 = n.slice(s, u).match(/^\s*/u)[0], D = ge(a2, t.tabWidth), l = await uu(o, { ...t, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t.cursorOffset > u && t.cursorOffset <= i ? t.cursorOffset - u : -1, endOfLine: "lf" }, D), p = l.formatted.trimEnd(), { cursorOffset: f2 } = t;
        f2 > i ? f2 += p.length - o.length : l.cursorOffset >= 0 && (f2 = l.cursorOffset + u);
        let d = n.slice(0, u) + p + n.slice(i);
        if (t.endOfLine !== "lf") {
          let c = be(t.endOfLine);
          f2 >= 0 && c === `\r
` && (f2 += Nt(d.slice(0, f2), `
`)), d = ne(false, d, `
`, c);
        }
        return { formatted: d, cursorOffset: f2, comments: l.comments };
      }
      function sr(e, t, r) {
        return typeof t != "number" || Number.isNaN(t) || t < 0 || t > e.length ? r : t;
      }
      function tu(e, t) {
        let { cursorOffset: r, rangeStart: n, rangeEnd: u } = t;
        return r = sr(e, r, -1), n = sr(e, n, 0), u = sr(e, u, e.length), { ...t, cursorOffset: r, rangeStart: n, rangeEnd: u };
      }
      function iu(e, t) {
        let { cursorOffset: r, rangeStart: n, rangeEnd: u, endOfLine: i } = tu(e, t), o = e.charAt(0) === nu;
        if (o && (e = e.slice(1), r--, n--, u--), i === "auto" && (i = Ar(e)), e.includes("\r")) {
          let s = (a2) => Nt(e.slice(0, Math.max(a2, 0)), `\r
`);
          r -= s(r), n -= s(n), u -= s(u), e = vr(e);
        }
        return { hasBOM: o, text: e, options: tu(e, { ...t, cursorOffset: r, rangeStart: n, rangeEnd: u, endOfLine: i }) };
      }
      async function ru(e, t) {
        let r = await Ct(t);
        return !r.hasPragma || r.hasPragma(e);
      }
      async function ar(e, t) {
        let { hasBOM: r, text: n, options: u } = iu(e, await se(t));
        if (u.rangeStart >= u.rangeEnd && n !== "" || u.requirePragma && !await ru(n, u)) return { formatted: e, cursorOffset: t.cursorOffset, comments: [] };
        let i;
        return u.rangeStart > 0 || u.rangeEnd < n.length ? i = await Hi(n, u) : (!u.requirePragma && u.insertPragma && u.printer.insertPragma && !await ru(n, u) && (n = u.printer.insertPragma(n)), i = await uu(n, u)), r && (i.formatted = nu + i.formatted, i.cursorOffset >= 0 && i.cursorOffset++), i;
      }
      async function ou(e, t, r) {
        let { text: n, options: u } = iu(e, await se(t)), i = await fe(n, u);
        return r && (r.preprocessForPrint && (i.ast = await ir(i.ast, u)), r.massage && (i.ast = Kn(i.ast, u))), i;
      }
      async function su(e, t) {
        t = await se(t);
        let r = await He(e, t);
        return Ce(r, t);
      }
      async function au(e, t) {
        let r = Vr(e), { formatted: n } = await ar(r, { ...t, parser: "__js_expression" });
        return n;
      }
      async function Du(e, t) {
        t = await se(t);
        let { ast: r } = await fe(e, t);
        return He(r, t);
      }
      async function lu(e, t) {
        return Ce(e, await se(t));
      }
      var Dr = {};
      vt(Dr, { builders: () => $i, printer: () => Mi, utils: () => Vi });
      var $i = { join: Se, line: Ze, softline: $r, hardline: K, literalline: Qe, group: kt, conditionalGroup: Ir, fill: Rr, lineSuffix: Te, lineSuffixBoundary: Hr, cursor: Z, breakParent: he, ifBreak: Yr, trim: Wr, indent: le, indentIfBreak: jr, align: De, addAlignmentToDoc: et, markAsRoot: Lr, dedentToRoot: kr, dedent: Pr, hardlineWithoutBreakParent: ke, literallineWithoutBreakParent: Lt, label: Mr, concat: (e) => e }, Mi = { printDocToString: Ce }, Vi = { willBreak: xr, traverseDoc: Fe, findInDoc: qe, mapDoc: Oe, removeLines: Nr, stripTrailingHardline: Xe, replaceEndOfLine: Or, canBreak: Sr };
      var cu = "3.5.3";
      var cr = {};
      vt(cr, { addDanglingComment: () => re, addLeadingComment: () => ue, addTrailingComment: () => ie, getAlignmentSize: () => ge, getIndentSize: () => fu, getMaxContinuousCount: () => du, getNextNonSpaceNonCommentCharacter: () => pu, getNextNonSpaceNonCommentCharacterIndex: () => no, getPreferredQuote: () => mu, getStringWidth: () => Le, hasNewline: () => V, hasNewlineInRange: () => hu, hasSpaces: () => Eu, isNextLineEmpty: () => so, isNextLineEmptyAfterIndex: () => gt, isPreviousLineEmpty: () => io, makeString: () => Cu, skip: () => Ae, skipEverythingButNewLine: () => ut, skipInlineComment: () => Be, skipNewline: () => W, skipSpaces: () => S, skipToLineEnd: () => nt, skipTrailingComment: () => we, skipWhitespace: () => tn });
      function Ui(e, t) {
        if (t === false) return false;
        if (e.charAt(t) === "/" && e.charAt(t + 1) === "*") {
          for (let r = t + 2; r < e.length; ++r) if (e.charAt(r) === "*" && e.charAt(r + 1) === "/") return r + 2;
        }
        return t;
      }
      var Be = Ui;
      function zi(e, t) {
        return t === false ? false : e.charAt(t) === "/" && e.charAt(t + 1) === "/" ? ut(e, t) : t;
      }
      var we = zi;
      function Gi(e, t) {
        let r = null, n = t;
        for (; n !== r; ) r = n, n = S(e, n), n = Be(e, n), n = we(e, n), n = W(e, n);
        return n;
      }
      var We = Gi;
      function Ki(e, t) {
        let r = null, n = t;
        for (; n !== r; ) r = n, n = nt(e, n), n = Be(e, n), n = S(e, n);
        return n = we(e, n), n = W(e, n), n !== false && V(e, n);
      }
      var gt = Ki;
      function Ji(e, t) {
        let r = e.lastIndexOf(`
`);
        return r === -1 ? 0 : ge(e.slice(r + 1).match(/^[\t ]*/u)[0], t);
      }
      var fu = Ji;
      function lr(e) {
        if (typeof e != "string") throw new TypeError("Expected a string");
        return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      }
      function qi(e, t) {
        let r = e.match(new RegExp(`(${lr(t)})+`, "gu"));
        return r === null ? 0 : r.reduce((n, u) => Math.max(n, u.length / t.length), 0);
      }
      var du = qi;
      function Xi(e, t) {
        let r = We(e, t);
        return r === false ? "" : e.charAt(r);
      }
      var pu = Xi;
      var yt = "'", Fu = '"';
      function Qi(e, t) {
        let r = t === true || t === yt ? yt : Fu, n = r === yt ? Fu : yt, u = 0, i = 0;
        for (let o of e) o === r ? u++ : o === n && i++;
        return u > i ? n : r;
      }
      var mu = Qi;
      function Zi(e, t, r) {
        for (let n = t; n < r; ++n) if (e.charAt(n) === `
`) return true;
        return false;
      }
      var hu = Zi;
      function eo(e, t, r = {}) {
        return S(e, r.backwards ? t - 1 : t, r) !== t;
      }
      var Eu = eo;
      function to(e, t, r) {
        let n = t === '"' ? "'" : '"', i = ne(false, e, /\\(.)|(["'])/gsu, (o, s, a2) => s === n ? s : a2 === t ? "\\" + a2 : a2 || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s) ? s : "\\" + s));
        return t + i + t;
      }
      var Cu = to;
      function ro(e, t, r) {
        return We(e, r(t));
      }
      function no(e, t) {
        return arguments.length === 2 || typeof t == "number" ? We(e, t) : ro(...arguments);
      }
      function uo(e, t, r) {
        return Ie(e, r(t));
      }
      function io(e, t) {
        return arguments.length === 2 || typeof t == "number" ? Ie(e, t) : uo(...arguments);
      }
      function oo(e, t, r) {
        return gt(e, r(t));
      }
      function so(e, t) {
        return arguments.length === 2 || typeof t == "number" ? gt(e, t) : oo(...arguments);
      }
      function de(e, t = 1) {
        return async (...r) => {
          let n = r[t] ?? {}, u = n.plugins ?? [];
          return r[t] = { ...n, plugins: Array.isArray(u) ? u : Object.values(u) }, e(...r);
        };
      }
      var gu = de(ar);
      async function yu(e, t) {
        let { formatted: r } = await gu(e, { ...t, cursorOffset: -1 });
        return r;
      }
      async function ao(e, t) {
        return await yu(e, t) === e;
      }
      var Do = de(ot, 0), lo = { parse: de(ou), formatAST: de(su), formatDoc: de(au), printToDoc: de(Du), printDocToString: de(lu) };
      return xu(co);
    });
  }
});

// node_modules/.pnpm/prettier@3.5.3/node_modules/prettier/plugins/yaml.js
var require_yaml = __commonJS({
  "node_modules/.pnpm/prettier@3.5.3/node_modules/prettier/plugins/yaml.js"(exports, module) {
    (function(f2) {
      function e() {
        var i = f2();
        return i.default || i;
      }
      if (typeof exports == "object" && typeof module == "object") module.exports = e();
      else if (typeof define == "function" && define.amd) define(e);
      else {
        var t = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        t.prettierPlugins = t.prettierPlugins || {}, t.prettierPlugins.yaml = e();
      }
    })(function() {
      "use strict";
      var Ti = Object.create;
      var yt = Object.defineProperty;
      var Ci = Object.getOwnPropertyDescriptor;
      var Mi = Object.getOwnPropertyNames;
      var ki = Object.getPrototypeOf, vi = Object.prototype.hasOwnProperty;
      var te = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), nr = (t, e) => {
        for (var n in e) yt(t, n, { get: e[n], enumerable: true });
      }, rr = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function") for (let s of Mi(e)) !vi.call(t, s) && s !== n && yt(t, s, { get: () => e[s], enumerable: !(r = Ci(e, s)) || r.enumerable });
        return t;
      };
      var sr = (t, e, n) => (n = t != null ? Ti(ki(t)) : {}, rr(e || !t || !t.__esModule ? yt(n, "default", { value: t, enumerable: true }) : n, t)), Ii = (t) => rr(yt({}, "__esModule", { value: true }), t);
      var le = te((U) => {
        "use strict";
        var re = { ANCHOR: "&", COMMENT: "#", TAG: "!", DIRECTIVES_END: "-", DOCUMENT_END: "." }, lt = { ALIAS: "ALIAS", BLANK_LINE: "BLANK_LINE", BLOCK_FOLDED: "BLOCK_FOLDED", BLOCK_LITERAL: "BLOCK_LITERAL", COMMENT: "COMMENT", DIRECTIVE: "DIRECTIVE", DOCUMENT: "DOCUMENT", FLOW_MAP: "FLOW_MAP", FLOW_SEQ: "FLOW_SEQ", MAP: "MAP", MAP_KEY: "MAP_KEY", MAP_VALUE: "MAP_VALUE", PLAIN: "PLAIN", QUOTE_DOUBLE: "QUOTE_DOUBLE", QUOTE_SINGLE: "QUOTE_SINGLE", SEQ: "SEQ", SEQ_ITEM: "SEQ_ITEM" }, Ao = "tag:yaml.org,2002:", To = { MAP: "tag:yaml.org,2002:map", SEQ: "tag:yaml.org,2002:seq", STR: "tag:yaml.org,2002:str" };
        function Ps(t) {
          let e = [0], n = t.indexOf(`
`);
          for (; n !== -1; ) n += 1, e.push(n), n = t.indexOf(`
`, n);
          return e;
        }
        function _s(t) {
          let e, n;
          return typeof t == "string" ? (e = Ps(t), n = t) : (Array.isArray(t) && (t = t[0]), t && t.context && (t.lineStarts || (t.lineStarts = Ps(t.context.src)), e = t.lineStarts, n = t.context.src)), { lineStarts: e, src: n };
        }
        function Tn(t, e) {
          if (typeof t != "number" || t < 0) return null;
          let { lineStarts: n, src: r } = _s(e);
          if (!n || !r || t > r.length) return null;
          for (let i = 0; i < n.length; ++i) {
            let o = n[i];
            if (t < o) return { line: i, col: t - n[i - 1] + 1 };
            if (t === o) return { line: i + 1, col: 1 };
          }
          let s = n.length;
          return { line: s, col: t - n[s - 1] + 1 };
        }
        function Co(t, e) {
          let { lineStarts: n, src: r } = _s(e);
          if (!n || !(t >= 1) || t > n.length) return null;
          let s = n[t - 1], i = n[t];
          for (; i && i > s && r[i - 1] === `
`; ) --i;
          return r.slice(s, i);
        }
        function Mo({ start: t, end: e }, n, r = 80) {
          let s = Co(t.line, n);
          if (!s) return null;
          let { col: i } = t;
          if (s.length > r) if (i <= r - 10) s = s.substr(0, r - 1) + "\u2026";
          else {
            let f2 = Math.round(r / 2);
            s.length > i + f2 && (s = s.substr(0, i + f2 - 1) + "\u2026"), i -= s.length - r, s = "\u2026" + s.substr(1 - r);
          }
          let o = 1, a2 = "";
          e && (e.line === t.line && i + (e.col - t.col) <= r + 1 ? o = e.col - t.col : (o = Math.min(s.length + 1, r) - i, a2 = "\u2026"));
          let c = i > 1 ? " ".repeat(i - 1) : "", l = "^".repeat(o);
          return `${s}
${c}${l}${a2}`;
        }
        var Be = class t {
          static copy(e) {
            return new t(e.start, e.end);
          }
          constructor(e, n) {
            this.start = e, this.end = n || e;
          }
          isEmpty() {
            return typeof this.start != "number" || !this.end || this.end <= this.start;
          }
          setOrigRange(e, n) {
            let { start: r, end: s } = this;
            if (e.length === 0 || s <= e[0]) return this.origStart = r, this.origEnd = s, n;
            let i = n;
            for (; i < e.length && !(e[i] > r); ) ++i;
            this.origStart = r + i;
            let o = i;
            for (; i < e.length && !(e[i] >= s); ) ++i;
            return this.origEnd = s + i, o;
          }
        }, se = class t {
          static addStringTerminator(e, n, r) {
            if (r[r.length - 1] === `
`) return r;
            let s = t.endOfWhiteSpace(e, n);
            return s >= e.length || e[s] === `
` ? r + `
` : r;
          }
          static atDocumentBoundary(e, n, r) {
            let s = e[n];
            if (!s) return true;
            let i = e[n - 1];
            if (i && i !== `
`) return false;
            if (r) {
              if (s !== r) return false;
            } else if (s !== re.DIRECTIVES_END && s !== re.DOCUMENT_END) return false;
            let o = e[n + 1], a2 = e[n + 2];
            if (o !== s || a2 !== s) return false;
            let c = e[n + 3];
            return !c || c === `
` || c === "	" || c === " ";
          }
          static endOfIdentifier(e, n) {
            let r = e[n], s = r === "<", i = s ? [`
`, "	", " ", ">"] : [`
`, "	", " ", "[", "]", "{", "}", ","];
            for (; r && i.indexOf(r) === -1; ) r = e[n += 1];
            return s && r === ">" && (n += 1), n;
          }
          static endOfIndent(e, n) {
            let r = e[n];
            for (; r === " "; ) r = e[n += 1];
            return n;
          }
          static endOfLine(e, n) {
            let r = e[n];
            for (; r && r !== `
`; ) r = e[n += 1];
            return n;
          }
          static endOfWhiteSpace(e, n) {
            let r = e[n];
            for (; r === "	" || r === " "; ) r = e[n += 1];
            return n;
          }
          static startOfLine(e, n) {
            let r = e[n - 1];
            if (r === `
`) return n;
            for (; r && r !== `
`; ) r = e[n -= 1];
            return n + 1;
          }
          static endOfBlockIndent(e, n, r) {
            let s = t.endOfIndent(e, r);
            if (s > r + n) return s;
            {
              let i = t.endOfWhiteSpace(e, s), o = e[i];
              if (!o || o === `
`) return i;
            }
            return null;
          }
          static atBlank(e, n, r) {
            let s = e[n];
            return s === `
` || s === "	" || s === " " || r && !s;
          }
          static nextNodeIsIndented(e, n, r) {
            return !e || n < 0 ? false : n > 0 ? true : r && e === "-";
          }
          static normalizeOffset(e, n) {
            let r = e[n];
            return r ? r !== `
` && e[n - 1] === `
` ? n - 1 : t.endOfWhiteSpace(e, n) : n;
          }
          static foldNewline(e, n, r) {
            let s = 0, i = false, o = "", a2 = e[n + 1];
            for (; a2 === " " || a2 === "	" || a2 === `
`; ) {
              switch (a2) {
                case `
`:
                  s = 0, n += 1, o += `
`;
                  break;
                case "	":
                  s <= r && (i = true), n = t.endOfWhiteSpace(e, n + 2) - 1;
                  break;
                case " ":
                  s += 1, n += 1;
                  break;
              }
              a2 = e[n + 1];
            }
            return o || (o = " "), a2 && s <= r && (i = true), { fold: o, offset: n, error: i };
          }
          constructor(e, n, r) {
            Object.defineProperty(this, "context", { value: r || null, writable: true }), this.error = null, this.range = null, this.valueRange = null, this.props = n || [], this.type = e, this.value = null;
          }
          getPropValue(e, n, r) {
            if (!this.context) return null;
            let { src: s } = this.context, i = this.props[e];
            return i && s[i.start] === n ? s.slice(i.start + (r ? 1 : 0), i.end) : null;
          }
          get anchor() {
            for (let e = 0; e < this.props.length; ++e) {
              let n = this.getPropValue(e, re.ANCHOR, true);
              if (n != null) return n;
            }
            return null;
          }
          get comment() {
            let e = [];
            for (let n = 0; n < this.props.length; ++n) {
              let r = this.getPropValue(n, re.COMMENT, true);
              r != null && e.push(r);
            }
            return e.length > 0 ? e.join(`
`) : null;
          }
          commentHasRequiredWhitespace(e) {
            let { src: n } = this.context;
            if (this.header && e === this.header.end || !this.valueRange) return false;
            let { end: r } = this.valueRange;
            return e !== r || t.atBlank(n, r - 1);
          }
          get hasComment() {
            if (this.context) {
              let { src: e } = this.context;
              for (let n = 0; n < this.props.length; ++n) if (e[this.props[n].start] === re.COMMENT) return true;
            }
            return false;
          }
          get hasProps() {
            if (this.context) {
              let { src: e } = this.context;
              for (let n = 0; n < this.props.length; ++n) if (e[this.props[n].start] !== re.COMMENT) return true;
            }
            return false;
          }
          get includesTrailingLines() {
            return false;
          }
          get jsonLike() {
            return [lt.FLOW_MAP, lt.FLOW_SEQ, lt.QUOTE_DOUBLE, lt.QUOTE_SINGLE].indexOf(this.type) !== -1;
          }
          get rangeAsLinePos() {
            if (!this.range || !this.context) return;
            let e = Tn(this.range.start, this.context.root);
            if (!e) return;
            let n = Tn(this.range.end, this.context.root);
            return { start: e, end: n };
          }
          get rawValue() {
            if (!this.valueRange || !this.context) return null;
            let { start: e, end: n } = this.valueRange;
            return this.context.src.slice(e, n);
          }
          get tag() {
            for (let e = 0; e < this.props.length; ++e) {
              let n = this.getPropValue(e, re.TAG, false);
              if (n != null) {
                if (n[1] === "<") return { verbatim: n.slice(2, -1) };
                {
                  let [r, s, i] = n.match(/^(.*!)([^!]*)$/);
                  return { handle: s, suffix: i };
                }
              }
            }
            return null;
          }
          get valueRangeContainsNewline() {
            if (!this.valueRange || !this.context) return false;
            let { start: e, end: n } = this.valueRange, { src: r } = this.context;
            for (let s = e; s < n; ++s) if (r[s] === `
`) return true;
            return false;
          }
          parseComment(e) {
            let { src: n } = this.context;
            if (n[e] === re.COMMENT) {
              let r = t.endOfLine(n, e + 1), s = new Be(e, r);
              return this.props.push(s), r;
            }
            return e;
          }
          setOrigRanges(e, n) {
            return this.range && (n = this.range.setOrigRange(e, n)), this.valueRange && this.valueRange.setOrigRange(e, n), this.props.forEach((r) => r.setOrigRange(e, n)), n;
          }
          toString() {
            let { context: { src: e }, range: n, value: r } = this;
            if (r != null) return r;
            let s = e.slice(n.start, n.end);
            return t.addStringTerminator(e, n.end, s);
          }
        }, ye = class extends Error {
          constructor(e, n, r) {
            if (!r || !(n instanceof se)) throw new Error(`Invalid arguments for new ${e}`);
            super(), this.name = e, this.message = r, this.source = n;
          }
          makePretty() {
            if (!this.source) return;
            this.nodeType = this.source.type;
            let e = this.source.context && this.source.context.root;
            if (typeof this.offset == "number") {
              this.range = new Be(this.offset, this.offset + 1);
              let n = e && Tn(this.offset, e);
              if (n) {
                let r = { line: n.line, col: n.col + 1 };
                this.linePos = { start: n, end: r };
              }
              delete this.offset;
            } else this.range = this.source.range, this.linePos = this.source.rangeAsLinePos;
            if (this.linePos) {
              let { line: n, col: r } = this.linePos.start;
              this.message += ` at line ${n}, column ${r}`;
              let s = e && Mo(this.linePos, e);
              s && (this.message += `:

${s}
`);
            }
            delete this.source;
          }
        }, Cn = class extends ye {
          constructor(e, n) {
            super("YAMLReferenceError", e, n);
          }
        }, ft = class extends ye {
          constructor(e, n) {
            super("YAMLSemanticError", e, n);
          }
        }, Mn = class extends ye {
          constructor(e, n) {
            super("YAMLSyntaxError", e, n);
          }
        }, kn = class extends ye {
          constructor(e, n) {
            super("YAMLWarning", e, n);
          }
        };
        function ko(t, e, n) {
          return e in t ? Object.defineProperty(t, e, { value: n, enumerable: true, configurable: true, writable: true }) : t[e] = n, t;
        }
        var vn = class t extends se {
          static endOfLine(e, n, r) {
            let s = e[n], i = n;
            for (; s && s !== `
` && !(r && (s === "[" || s === "]" || s === "{" || s === "}" || s === ",")); ) {
              let o = e[i + 1];
              if (s === ":" && (!o || o === `
` || o === "	" || o === " " || r && o === ",") || (s === " " || s === "	") && o === "#") break;
              i += 1, s = o;
            }
            return i;
          }
          get strValue() {
            if (!this.valueRange || !this.context) return null;
            let { start: e, end: n } = this.valueRange, { src: r } = this.context, s = r[n - 1];
            for (; e < n && (s === `
` || s === "	" || s === " "); ) s = r[--n - 1];
            let i = "";
            for (let a2 = e; a2 < n; ++a2) {
              let c = r[a2];
              if (c === `
`) {
                let { fold: l, offset: f2 } = se.foldNewline(r, a2, -1);
                i += l, a2 = f2;
              } else if (c === " " || c === "	") {
                let l = a2, f2 = r[a2 + 1];
                for (; a2 < n && (f2 === " " || f2 === "	"); ) a2 += 1, f2 = r[a2 + 1];
                f2 !== `
` && (i += a2 > l ? r.slice(l, a2 + 1) : c);
              } else i += c;
            }
            let o = r[e];
            switch (o) {
              case "	": {
                let a2 = "Plain value cannot start with a tab character";
                return { errors: [new ft(this, a2)], str: i };
              }
              case "@":
              case "`": {
                let a2 = `Plain value cannot start with reserved character ${o}`;
                return { errors: [new ft(this, a2)], str: i };
              }
              default:
                return i;
            }
          }
          parseBlockValue(e) {
            let { indent: n, inFlow: r, src: s } = this.context, i = e, o = e;
            for (let a2 = s[i]; a2 === `
` && !se.atDocumentBoundary(s, i + 1); a2 = s[i]) {
              let c = se.endOfBlockIndent(s, n, i + 1);
              if (c === null || s[c] === "#") break;
              s[c] === `
` ? i = c : (o = t.endOfLine(s, c, r), i = o);
            }
            return this.valueRange.isEmpty() && (this.valueRange.start = e), this.valueRange.end = o, o;
          }
          parse(e, n) {
            this.context = e;
            let { inFlow: r, src: s } = e, i = n, o = s[i];
            return o && o !== "#" && o !== `
` && (i = t.endOfLine(s, n, r)), this.valueRange = new Be(n, i), i = se.endOfWhiteSpace(s, i), i = this.parseComment(i), (!this.hasComment || this.valueRange.isEmpty()) && (i = this.parseBlockValue(i)), i;
          }
        };
        U.Char = re;
        U.Node = se;
        U.PlainValue = vn;
        U.Range = Be;
        U.Type = lt;
        U.YAMLError = ye;
        U.YAMLReferenceError = Cn;
        U.YAMLSemanticError = ft;
        U.YAMLSyntaxError = Mn;
        U.YAMLWarning = kn;
        U._defineProperty = ko;
        U.defaultTagPrefix = Ao;
        U.defaultTags = To;
      });
      var Rs = te((xs) => {
        "use strict";
        var u = le(), Se = class extends u.Node {
          constructor() {
            super(u.Type.BLANK_LINE);
          }
          get includesTrailingLines() {
            return true;
          }
          parse(e, n) {
            return this.context = e, this.range = new u.Range(n, n + 1), n + 1;
          }
        }, ut = class extends u.Node {
          constructor(e, n) {
            super(e, n), this.node = null;
          }
          get includesTrailingLines() {
            return !!this.node && this.node.includesTrailingLines;
          }
          parse(e, n) {
            this.context = e;
            let { parseNode: r, src: s } = e, { atLineStart: i, lineStart: o } = e;
            !i && this.type === u.Type.SEQ_ITEM && (this.error = new u.YAMLSemanticError(this, "Sequence items must not have preceding content on the same line"));
            let a2 = i ? n - o : e.indent, c = u.Node.endOfWhiteSpace(s, n + 1), l = s[c], f2 = l === "#", m = [], d = null;
            for (; l === `
` || l === "#"; ) {
              if (l === "#") {
                let h = u.Node.endOfLine(s, c + 1);
                m.push(new u.Range(c, h)), c = h;
              } else {
                i = true, o = c + 1;
                let h = u.Node.endOfWhiteSpace(s, o);
                s[h] === `
` && m.length === 0 && (d = new Se(), o = d.parse({ src: s }, o)), c = u.Node.endOfIndent(s, o);
              }
              l = s[c];
            }
            if (u.Node.nextNodeIsIndented(l, c - (o + a2), this.type !== u.Type.SEQ_ITEM) ? this.node = r({ atLineStart: i, inCollection: false, indent: a2, lineStart: o, parent: this }, c) : l && o > n + 1 && (c = o - 1), this.node) {
              if (d) {
                let h = e.parent.items || e.parent.contents;
                h && h.push(d);
              }
              m.length && Array.prototype.push.apply(this.props, m), c = this.node.range.end;
            } else if (f2) {
              let h = m[0];
              this.props.push(h), c = h.end;
            } else c = u.Node.endOfLine(s, n + 1);
            let y = this.node ? this.node.valueRange.end : c;
            return this.valueRange = new u.Range(n, y), c;
          }
          setOrigRanges(e, n) {
            return n = super.setOrigRanges(e, n), this.node ? this.node.setOrigRanges(e, n) : n;
          }
          toString() {
            let { context: { src: e }, node: n, range: r, value: s } = this;
            if (s != null) return s;
            let i = n ? e.slice(r.start, n.range.start) + String(n) : e.slice(r.start, r.end);
            return u.Node.addStringTerminator(e, r.end, i);
          }
        }, Ee = class extends u.Node {
          constructor() {
            super(u.Type.COMMENT);
          }
          parse(e, n) {
            this.context = e;
            let r = this.parseComment(n);
            return this.range = new u.Range(n, r), r;
          }
        };
        function In(t) {
          let e = t;
          for (; e instanceof ut; ) e = e.node;
          if (!(e instanceof Bt)) return null;
          let n = e.items.length, r = -1;
          for (let o = n - 1; o >= 0; --o) {
            let a2 = e.items[o];
            if (a2.type === u.Type.COMMENT) {
              let { indent: c, lineStart: l } = a2.context;
              if (c > 0 && a2.range.start >= l + c) break;
              r = o;
            } else if (a2.type === u.Type.BLANK_LINE) r = o;
            else break;
          }
          if (r === -1) return null;
          let s = e.items.splice(r, n - r), i = s[0].range.start;
          for (; e.range.end = i, e.valueRange && e.valueRange.end > i && (e.valueRange.end = i), e !== t; ) e = e.context.parent;
          return s;
        }
        var Bt = class t extends u.Node {
          static nextContentHasIndent(e, n, r) {
            let s = u.Node.endOfLine(e, n) + 1;
            n = u.Node.endOfWhiteSpace(e, s);
            let i = e[n];
            return i ? n >= s + r ? true : i !== "#" && i !== `
` ? false : t.nextContentHasIndent(e, n, r) : false;
          }
          constructor(e) {
            super(e.type === u.Type.SEQ_ITEM ? u.Type.SEQ : u.Type.MAP);
            for (let r = e.props.length - 1; r >= 0; --r) if (e.props[r].start < e.context.lineStart) {
              this.props = e.props.slice(0, r + 1), e.props = e.props.slice(r + 1);
              let s = e.props[0] || e.valueRange;
              e.range.start = s.start;
              break;
            }
            this.items = [e];
            let n = In(e);
            n && Array.prototype.push.apply(this.items, n);
          }
          get includesTrailingLines() {
            return this.items.length > 0;
          }
          parse(e, n) {
            this.context = e;
            let { parseNode: r, src: s } = e, i = u.Node.startOfLine(s, n), o = this.items[0];
            o.context.parent = this, this.valueRange = u.Range.copy(o.valueRange);
            let a2 = o.range.start - o.context.lineStart, c = n;
            c = u.Node.normalizeOffset(s, c);
            let l = s[c], f2 = u.Node.endOfWhiteSpace(s, i) === c, m = false;
            for (; l; ) {
              for (; l === `
` || l === "#"; ) {
                if (f2 && l === `
` && !m) {
                  let h = new Se();
                  if (c = h.parse({ src: s }, c), this.valueRange.end = c, c >= s.length) {
                    l = null;
                    break;
                  }
                  this.items.push(h), c -= 1;
                } else if (l === "#") {
                  if (c < i + a2 && !t.nextContentHasIndent(s, c, a2)) return c;
                  let h = new Ee();
                  if (c = h.parse({ indent: a2, lineStart: i, src: s }, c), this.items.push(h), this.valueRange.end = c, c >= s.length) {
                    l = null;
                    break;
                  }
                }
                if (i = c + 1, c = u.Node.endOfIndent(s, i), u.Node.atBlank(s, c)) {
                  let h = u.Node.endOfWhiteSpace(s, c), g = s[h];
                  (!g || g === `
` || g === "#") && (c = h);
                }
                l = s[c], f2 = true;
              }
              if (!l) break;
              if (c !== i + a2 && (f2 || l !== ":")) {
                if (c < i + a2) {
                  i > n && (c = i);
                  break;
                } else if (!this.error) {
                  let h = "All collection items must start at the same column";
                  this.error = new u.YAMLSyntaxError(this, h);
                }
              }
              if (o.type === u.Type.SEQ_ITEM) {
                if (l !== "-") {
                  i > n && (c = i);
                  break;
                }
              } else if (l === "-" && !this.error) {
                let h = s[c + 1];
                if (!h || h === `
` || h === "	" || h === " ") {
                  let g = "A collection cannot be both a mapping and a sequence";
                  this.error = new u.YAMLSyntaxError(this, g);
                }
              }
              let d = r({ atLineStart: f2, inCollection: true, indent: a2, lineStart: i, parent: this }, c);
              if (!d) return c;
              if (this.items.push(d), this.valueRange.end = d.valueRange.end, c = u.Node.normalizeOffset(s, d.range.end), l = s[c], f2 = false, m = d.includesTrailingLines, l) {
                let h = c - 1, g = s[h];
                for (; g === " " || g === "	"; ) g = s[--h];
                g === `
` && (i = h + 1, f2 = true);
              }
              let y = In(d);
              y && Array.prototype.push.apply(this.items, y);
            }
            return c;
          }
          setOrigRanges(e, n) {
            return n = super.setOrigRanges(e, n), this.items.forEach((r) => {
              n = r.setOrigRanges(e, n);
            }), n;
          }
          toString() {
            let { context: { src: e }, items: n, range: r, value: s } = this;
            if (s != null) return s;
            let i = e.slice(r.start, n[0].range.start) + String(n[0]);
            for (let o = 1; o < n.length; ++o) {
              let a2 = n[o], { atLineStart: c, indent: l } = a2.context;
              if (c) for (let f2 = 0; f2 < l; ++f2) i += " ";
              i += String(a2);
            }
            return u.Node.addStringTerminator(e, r.end, i);
          }
        }, Pn = class extends u.Node {
          constructor() {
            super(u.Type.DIRECTIVE), this.name = null;
          }
          get parameters() {
            let e = this.rawValue;
            return e ? e.trim().split(/[ \t]+/) : [];
          }
          parseName(e) {
            let { src: n } = this.context, r = e, s = n[r];
            for (; s && s !== `
` && s !== "	" && s !== " "; ) s = n[r += 1];
            return this.name = n.slice(e, r), r;
          }
          parseParameters(e) {
            let { src: n } = this.context, r = e, s = n[r];
            for (; s && s !== `
` && s !== "#"; ) s = n[r += 1];
            return this.valueRange = new u.Range(e, r), r;
          }
          parse(e, n) {
            this.context = e;
            let r = this.parseName(n + 1);
            return r = this.parseParameters(r), r = this.parseComment(r), this.range = new u.Range(n, r), r;
          }
        }, _n = class t extends u.Node {
          static startCommentOrEndBlankLine(e, n) {
            let r = u.Node.endOfWhiteSpace(e, n), s = e[r];
            return s === "#" || s === `
` ? r : n;
          }
          constructor() {
            super(u.Type.DOCUMENT), this.directives = null, this.contents = null, this.directivesEndMarker = null, this.documentEndMarker = null;
          }
          parseDirectives(e) {
            let { src: n } = this.context;
            this.directives = [];
            let r = true, s = false, i = e;
            for (; !u.Node.atDocumentBoundary(n, i, u.Char.DIRECTIVES_END); ) switch (i = t.startCommentOrEndBlankLine(n, i), n[i]) {
              case `
`:
                if (r) {
                  let o = new Se();
                  i = o.parse({ src: n }, i), i < n.length && this.directives.push(o);
                } else i += 1, r = true;
                break;
              case "#":
                {
                  let o = new Ee();
                  i = o.parse({ src: n }, i), this.directives.push(o), r = false;
                }
                break;
              case "%":
                {
                  let o = new Pn();
                  i = o.parse({ parent: this, src: n }, i), this.directives.push(o), s = true, r = false;
                }
                break;
              default:
                return s ? this.error = new u.YAMLSemanticError(this, "Missing directives-end indicator line") : this.directives.length > 0 && (this.contents = this.directives, this.directives = []), i;
            }
            return n[i] ? (this.directivesEndMarker = new u.Range(i, i + 3), i + 3) : (s ? this.error = new u.YAMLSemanticError(this, "Missing directives-end indicator line") : this.directives.length > 0 && (this.contents = this.directives, this.directives = []), i);
          }
          parseContents(e) {
            let { parseNode: n, src: r } = this.context;
            this.contents || (this.contents = []);
            let s = e;
            for (; r[s - 1] === "-"; ) s -= 1;
            let i = u.Node.endOfWhiteSpace(r, e), o = s === e;
            for (this.valueRange = new u.Range(i); !u.Node.atDocumentBoundary(r, i, u.Char.DOCUMENT_END); ) {
              switch (r[i]) {
                case `
`:
                  if (o) {
                    let a2 = new Se();
                    i = a2.parse({ src: r }, i), i < r.length && this.contents.push(a2);
                  } else i += 1, o = true;
                  s = i;
                  break;
                case "#":
                  {
                    let a2 = new Ee();
                    i = a2.parse({ src: r }, i), this.contents.push(a2), o = false;
                  }
                  break;
                default: {
                  let a2 = u.Node.endOfIndent(r, i), l = n({ atLineStart: o, indent: -1, inFlow: false, inCollection: false, lineStart: s, parent: this }, a2);
                  if (!l) return this.valueRange.end = a2;
                  this.contents.push(l), i = l.range.end, o = false;
                  let f2 = In(l);
                  f2 && Array.prototype.push.apply(this.contents, f2);
                }
              }
              i = t.startCommentOrEndBlankLine(r, i);
            }
            if (this.valueRange.end = i, r[i] && (this.documentEndMarker = new u.Range(i, i + 3), i += 3, r[i])) {
              if (i = u.Node.endOfWhiteSpace(r, i), r[i] === "#") {
                let a2 = new Ee();
                i = a2.parse({ src: r }, i), this.contents.push(a2);
              }
              switch (r[i]) {
                case `
`:
                  i += 1;
                  break;
                case void 0:
                  break;
                default:
                  this.error = new u.YAMLSyntaxError(this, "Document end marker line cannot have a non-comment suffix");
              }
            }
            return i;
          }
          parse(e, n) {
            e.root = this, this.context = e;
            let { src: r } = e, s = r.charCodeAt(n) === 65279 ? n + 1 : n;
            return s = this.parseDirectives(s), s = this.parseContents(s), s;
          }
          setOrigRanges(e, n) {
            return n = super.setOrigRanges(e, n), this.directives.forEach((r) => {
              n = r.setOrigRanges(e, n);
            }), this.directivesEndMarker && (n = this.directivesEndMarker.setOrigRange(e, n)), this.contents.forEach((r) => {
              n = r.setOrigRanges(e, n);
            }), this.documentEndMarker && (n = this.documentEndMarker.setOrigRange(e, n)), n;
          }
          toString() {
            let { contents: e, directives: n, value: r } = this;
            if (r != null) return r;
            let s = n.join("");
            return e.length > 0 && ((n.length > 0 || e[0].type === u.Type.COMMENT) && (s += `---
`), s += e.join("")), s[s.length - 1] !== `
` && (s += `
`), s;
          }
        }, xn = class extends u.Node {
          parse(e, n) {
            this.context = e;
            let { src: r } = e, s = u.Node.endOfIdentifier(r, n + 1);
            return this.valueRange = new u.Range(n + 1, s), s = u.Node.endOfWhiteSpace(r, s), s = this.parseComment(s), s;
          }
        }, fe = { CLIP: "CLIP", KEEP: "KEEP", STRIP: "STRIP" }, Rn = class extends u.Node {
          constructor(e, n) {
            super(e, n), this.blockIndent = null, this.chomping = fe.CLIP, this.header = null;
          }
          get includesTrailingLines() {
            return this.chomping === fe.KEEP;
          }
          get strValue() {
            if (!this.valueRange || !this.context) return null;
            let { start: e, end: n } = this.valueRange, { indent: r, src: s } = this.context;
            if (this.valueRange.isEmpty()) return "";
            let i = null, o = s[n - 1];
            for (; o === `
` || o === "	" || o === " "; ) {
              if (n -= 1, n <= e) {
                if (this.chomping === fe.KEEP) break;
                return "";
              }
              o === `
` && (i = n), o = s[n - 1];
            }
            let a2 = n + 1;
            i && (this.chomping === fe.KEEP ? (a2 = i, n = this.valueRange.end) : n = i);
            let c = r + this.blockIndent, l = this.type === u.Type.BLOCK_FOLDED, f2 = true, m = "", d = "", y = false;
            for (let h = e; h < n; ++h) {
              for (let w = 0; w < c && s[h] === " "; ++w) h += 1;
              let g = s[h];
              if (g === `
`) d === `
` ? m += `
` : d = `
`;
              else {
                let w = u.Node.endOfLine(s, h), C = s.slice(h, w);
                h = w, l && (g === " " || g === "	") && h < a2 ? (d === " " ? d = `
` : !y && !f2 && d === `
` && (d = `

`), m += d + C, d = w < n && s[w] || "", y = true) : (m += d + C, d = l && h < a2 ? " " : `
`, y = false), f2 && C !== "" && (f2 = false);
              }
            }
            return this.chomping === fe.STRIP ? m : m + `
`;
          }
          parseBlockHeader(e) {
            let { src: n } = this.context, r = e + 1, s = "";
            for (; ; ) {
              let i = n[r];
              switch (i) {
                case "-":
                  this.chomping = fe.STRIP;
                  break;
                case "+":
                  this.chomping = fe.KEEP;
                  break;
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                  s += i;
                  break;
                default:
                  return this.blockIndent = Number(s) || null, this.header = new u.Range(e, r), r;
              }
              r += 1;
            }
          }
          parseBlockValue(e) {
            let { indent: n, src: r } = this.context, s = !!this.blockIndent, i = e, o = e, a2 = 1;
            for (let c = r[i]; c === `
` && (i += 1, !u.Node.atDocumentBoundary(r, i)); c = r[i]) {
              let l = u.Node.endOfBlockIndent(r, n, i);
              if (l === null) break;
              let f2 = r[l], m = l - (i + n);
              if (this.blockIndent) {
                if (f2 && f2 !== `
` && m < this.blockIndent) {
                  if (r[l] === "#") break;
                  if (!this.error) {
                    let y = `Block scalars must not be less indented than their ${s ? "explicit indentation indicator" : "first line"}`;
                    this.error = new u.YAMLSemanticError(this, y);
                  }
                }
              } else if (r[l] !== `
`) {
                if (m < a2) {
                  let d = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                  this.error = new u.YAMLSemanticError(this, d);
                }
                this.blockIndent = m;
              } else m > a2 && (a2 = m);
              r[l] === `
` ? i = l : i = o = u.Node.endOfLine(r, l);
            }
            return this.chomping !== fe.KEEP && (i = r[o] ? o + 1 : o), this.valueRange = new u.Range(e + 1, i), i;
          }
          parse(e, n) {
            this.context = e;
            let { src: r } = e, s = this.parseBlockHeader(n);
            return s = u.Node.endOfWhiteSpace(r, s), s = this.parseComment(s), s = this.parseBlockValue(s), s;
          }
          setOrigRanges(e, n) {
            return n = super.setOrigRanges(e, n), this.header ? this.header.setOrigRange(e, n) : n;
          }
        }, Dn = class extends u.Node {
          constructor(e, n) {
            super(e, n), this.items = null;
          }
          prevNodeIsJsonLike(e = this.items.length) {
            let n = this.items[e - 1];
            return !!n && (n.jsonLike || n.type === u.Type.COMMENT && this.prevNodeIsJsonLike(e - 1));
          }
          parse(e, n) {
            this.context = e;
            let { parseNode: r, src: s } = e, { indent: i, lineStart: o } = e, a2 = s[n];
            this.items = [{ char: a2, offset: n }];
            let c = u.Node.endOfWhiteSpace(s, n + 1);
            for (a2 = s[c]; a2 && a2 !== "]" && a2 !== "}"; ) {
              switch (a2) {
                case `
`:
                  {
                    o = c + 1;
                    let l = u.Node.endOfWhiteSpace(s, o);
                    if (s[l] === `
`) {
                      let f2 = new Se();
                      o = f2.parse({ src: s }, o), this.items.push(f2);
                    }
                    if (c = u.Node.endOfIndent(s, o), c <= o + i && (a2 = s[c], c < o + i || a2 !== "]" && a2 !== "}")) {
                      let f2 = "Insufficient indentation in flow collection";
                      this.error = new u.YAMLSemanticError(this, f2);
                    }
                  }
                  break;
                case ",":
                  this.items.push({ char: a2, offset: c }), c += 1;
                  break;
                case "#":
                  {
                    let l = new Ee();
                    c = l.parse({ src: s }, c), this.items.push(l);
                  }
                  break;
                case "?":
                case ":": {
                  let l = s[c + 1];
                  if (l === `
` || l === "	" || l === " " || l === "," || a2 === ":" && this.prevNodeIsJsonLike()) {
                    this.items.push({ char: a2, offset: c }), c += 1;
                    break;
                  }
                }
                default: {
                  let l = r({ atLineStart: false, inCollection: false, inFlow: true, indent: -1, lineStart: o, parent: this }, c);
                  if (!l) return this.valueRange = new u.Range(n, c), c;
                  this.items.push(l), c = u.Node.normalizeOffset(s, l.range.end);
                }
              }
              c = u.Node.endOfWhiteSpace(s, c), a2 = s[c];
            }
            return this.valueRange = new u.Range(n, c + 1), a2 && (this.items.push({ char: a2, offset: c }), c = u.Node.endOfWhiteSpace(s, c + 1), c = this.parseComment(c)), c;
          }
          setOrigRanges(e, n) {
            return n = super.setOrigRanges(e, n), this.items.forEach((r) => {
              if (r instanceof u.Node) n = r.setOrigRanges(e, n);
              else if (e.length === 0) r.origOffset = r.offset;
              else {
                let s = n;
                for (; s < e.length && !(e[s] > r.offset); ) ++s;
                r.origOffset = r.offset + s, n = s;
              }
            }), n;
          }
          toString() {
            let { context: { src: e }, items: n, range: r, value: s } = this;
            if (s != null) return s;
            let i = n.filter((c) => c instanceof u.Node), o = "", a2 = r.start;
            return i.forEach((c) => {
              let l = e.slice(a2, c.range.start);
              a2 = c.range.end, o += l + String(c), o[o.length - 1] === `
` && e[a2 - 1] !== `
` && e[a2] === `
` && (a2 += 1);
            }), o += e.slice(a2, r.end), u.Node.addStringTerminator(e, r.end, o);
          }
        }, Yn = class t extends u.Node {
          static endOfQuote(e, n) {
            let r = e[n];
            for (; r && r !== '"'; ) n += r === "\\" ? 2 : 1, r = e[n];
            return n + 1;
          }
          get strValue() {
            if (!this.valueRange || !this.context) return null;
            let e = [], { start: n, end: r } = this.valueRange, { indent: s, src: i } = this.context;
            i[r - 1] !== '"' && e.push(new u.YAMLSyntaxError(this, 'Missing closing "quote'));
            let o = "";
            for (let a2 = n + 1; a2 < r - 1; ++a2) {
              let c = i[a2];
              if (c === `
`) {
                u.Node.atDocumentBoundary(i, a2 + 1) && e.push(new u.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
                let { fold: l, offset: f2, error: m } = u.Node.foldNewline(i, a2, s);
                o += l, a2 = f2, m && e.push(new u.YAMLSemanticError(this, "Multi-line double-quoted string needs to be sufficiently indented"));
              } else if (c === "\\") switch (a2 += 1, i[a2]) {
                case "0":
                  o += "\0";
                  break;
                case "a":
                  o += "\x07";
                  break;
                case "b":
                  o += "\b";
                  break;
                case "e":
                  o += "\x1B";
                  break;
                case "f":
                  o += "\f";
                  break;
                case "n":
                  o += `
`;
                  break;
                case "r":
                  o += "\r";
                  break;
                case "t":
                  o += "	";
                  break;
                case "v":
                  o += "\v";
                  break;
                case "N":
                  o += "\x85";
                  break;
                case "_":
                  o += "\xA0";
                  break;
                case "L":
                  o += "\u2028";
                  break;
                case "P":
                  o += "\u2029";
                  break;
                case " ":
                  o += " ";
                  break;
                case '"':
                  o += '"';
                  break;
                case "/":
                  o += "/";
                  break;
                case "\\":
                  o += "\\";
                  break;
                case "	":
                  o += "	";
                  break;
                case "x":
                  o += this.parseCharCode(a2 + 1, 2, e), a2 += 2;
                  break;
                case "u":
                  o += this.parseCharCode(a2 + 1, 4, e), a2 += 4;
                  break;
                case "U":
                  o += this.parseCharCode(a2 + 1, 8, e), a2 += 8;
                  break;
                case `
`:
                  for (; i[a2 + 1] === " " || i[a2 + 1] === "	"; ) a2 += 1;
                  break;
                default:
                  e.push(new u.YAMLSyntaxError(this, `Invalid escape sequence ${i.substr(a2 - 1, 2)}`)), o += "\\" + i[a2];
              }
              else if (c === " " || c === "	") {
                let l = a2, f2 = i[a2 + 1];
                for (; f2 === " " || f2 === "	"; ) a2 += 1, f2 = i[a2 + 1];
                f2 !== `
` && (o += a2 > l ? i.slice(l, a2 + 1) : c);
              } else o += c;
            }
            return e.length > 0 ? { errors: e, str: o } : o;
          }
          parseCharCode(e, n, r) {
            let { src: s } = this.context, i = s.substr(e, n), a2 = i.length === n && /^[0-9a-fA-F]+$/.test(i) ? parseInt(i, 16) : NaN;
            return isNaN(a2) ? (r.push(new u.YAMLSyntaxError(this, `Invalid escape sequence ${s.substr(e - 2, n + 2)}`)), s.substr(e - 2, n + 2)) : String.fromCodePoint(a2);
          }
          parse(e, n) {
            this.context = e;
            let { src: r } = e, s = t.endOfQuote(r, n + 1);
            return this.valueRange = new u.Range(n, s), s = u.Node.endOfWhiteSpace(r, s), s = this.parseComment(s), s;
          }
        }, $n = class t extends u.Node {
          static endOfQuote(e, n) {
            let r = e[n];
            for (; r; ) if (r === "'") {
              if (e[n + 1] !== "'") break;
              r = e[n += 2];
            } else r = e[n += 1];
            return n + 1;
          }
          get strValue() {
            if (!this.valueRange || !this.context) return null;
            let e = [], { start: n, end: r } = this.valueRange, { indent: s, src: i } = this.context;
            i[r - 1] !== "'" && e.push(new u.YAMLSyntaxError(this, "Missing closing 'quote"));
            let o = "";
            for (let a2 = n + 1; a2 < r - 1; ++a2) {
              let c = i[a2];
              if (c === `
`) {
                u.Node.atDocumentBoundary(i, a2 + 1) && e.push(new u.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
                let { fold: l, offset: f2, error: m } = u.Node.foldNewline(i, a2, s);
                o += l, a2 = f2, m && e.push(new u.YAMLSemanticError(this, "Multi-line single-quoted string needs to be sufficiently indented"));
              } else if (c === "'") o += c, a2 += 1, i[a2] !== "'" && e.push(new u.YAMLSyntaxError(this, "Unescaped single quote? This should not happen."));
              else if (c === " " || c === "	") {
                let l = a2, f2 = i[a2 + 1];
                for (; f2 === " " || f2 === "	"; ) a2 += 1, f2 = i[a2 + 1];
                f2 !== `
` && (o += a2 > l ? i.slice(l, a2 + 1) : c);
              } else o += c;
            }
            return e.length > 0 ? { errors: e, str: o } : o;
          }
          parse(e, n) {
            this.context = e;
            let { src: r } = e, s = t.endOfQuote(r, n + 1);
            return this.valueRange = new u.Range(n, s), s = u.Node.endOfWhiteSpace(r, s), s = this.parseComment(s), s;
          }
        };
        function vo(t, e) {
          switch (t) {
            case u.Type.ALIAS:
              return new xn(t, e);
            case u.Type.BLOCK_FOLDED:
            case u.Type.BLOCK_LITERAL:
              return new Rn(t, e);
            case u.Type.FLOW_MAP:
            case u.Type.FLOW_SEQ:
              return new Dn(t, e);
            case u.Type.MAP_KEY:
            case u.Type.MAP_VALUE:
            case u.Type.SEQ_ITEM:
              return new ut(t, e);
            case u.Type.COMMENT:
            case u.Type.PLAIN:
              return new u.PlainValue(t, e);
            case u.Type.QUOTE_DOUBLE:
              return new Yn(t, e);
            case u.Type.QUOTE_SINGLE:
              return new $n(t, e);
            default:
              return null;
          }
        }
        var Bn = class t {
          static parseType(e, n, r) {
            switch (e[n]) {
              case "*":
                return u.Type.ALIAS;
              case ">":
                return u.Type.BLOCK_FOLDED;
              case "|":
                return u.Type.BLOCK_LITERAL;
              case "{":
                return u.Type.FLOW_MAP;
              case "[":
                return u.Type.FLOW_SEQ;
              case "?":
                return !r && u.Node.atBlank(e, n + 1, true) ? u.Type.MAP_KEY : u.Type.PLAIN;
              case ":":
                return !r && u.Node.atBlank(e, n + 1, true) ? u.Type.MAP_VALUE : u.Type.PLAIN;
              case "-":
                return !r && u.Node.atBlank(e, n + 1, true) ? u.Type.SEQ_ITEM : u.Type.PLAIN;
              case '"':
                return u.Type.QUOTE_DOUBLE;
              case "'":
                return u.Type.QUOTE_SINGLE;
              default:
                return u.Type.PLAIN;
            }
          }
          constructor(e = {}, { atLineStart: n, inCollection: r, inFlow: s, indent: i, lineStart: o, parent: a2 } = {}) {
            u._defineProperty(this, "parseNode", (c, l) => {
              if (u.Node.atDocumentBoundary(this.src, l)) return null;
              let f2 = new t(this, c), { props: m, type: d, valueStart: y } = f2.parseProps(l), h = vo(d, m), g = h.parse(f2, y);
              if (h.range = new u.Range(l, g), g <= l && (h.error = new Error("Node#parse consumed no characters"), h.error.parseEnd = g, h.error.source = h, h.range.end = l + 1), f2.nodeStartsCollection(h)) {
                !h.error && !f2.atLineStart && f2.parent.type === u.Type.DOCUMENT && (h.error = new u.YAMLSyntaxError(h, "Block collection must not have preceding content here (e.g. directives-end indicator)"));
                let w = new Bt(h);
                return g = w.parse(new t(f2), g), w.range = new u.Range(l, g), w;
              }
              return h;
            }), this.atLineStart = n ?? (e.atLineStart || false), this.inCollection = r ?? (e.inCollection || false), this.inFlow = s ?? (e.inFlow || false), this.indent = i ?? e.indent, this.lineStart = o ?? e.lineStart, this.parent = a2 ?? (e.parent || {}), this.root = e.root, this.src = e.src;
          }
          nodeStartsCollection(e) {
            let { inCollection: n, inFlow: r, src: s } = this;
            if (n || r) return false;
            if (e instanceof ut) return true;
            let i = e.range.end;
            return s[i] === `
` || s[i - 1] === `
` ? false : (i = u.Node.endOfWhiteSpace(s, i), s[i] === ":");
          }
          parseProps(e) {
            let { inFlow: n, parent: r, src: s } = this, i = [], o = false;
            e = this.atLineStart ? u.Node.endOfIndent(s, e) : u.Node.endOfWhiteSpace(s, e);
            let a2 = s[e];
            for (; a2 === u.Char.ANCHOR || a2 === u.Char.COMMENT || a2 === u.Char.TAG || a2 === `
`; ) {
              if (a2 === `
`) {
                let l = e, f2;
                do
                  f2 = l + 1, l = u.Node.endOfIndent(s, f2);
                while (s[l] === `
`);
                let m = l - (f2 + this.indent), d = r.type === u.Type.SEQ_ITEM && r.context.atLineStart;
                if (s[l] !== "#" && !u.Node.nextNodeIsIndented(s[l], m, !d)) break;
                this.atLineStart = true, this.lineStart = f2, o = false, e = l;
              } else if (a2 === u.Char.COMMENT) {
                let l = u.Node.endOfLine(s, e + 1);
                i.push(new u.Range(e, l)), e = l;
              } else {
                let l = u.Node.endOfIdentifier(s, e + 1);
                a2 === u.Char.TAG && s[l] === "," && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(s.slice(e + 1, l + 13)) && (l = u.Node.endOfIdentifier(s, l + 5)), i.push(new u.Range(e, l)), o = true, e = u.Node.endOfWhiteSpace(s, l);
              }
              a2 = s[e];
            }
            o && a2 === ":" && u.Node.atBlank(s, e + 1, true) && (e -= 1);
            let c = t.parseType(s, e, n);
            return { props: i, type: c, valueStart: e };
          }
        };
        function Io(t) {
          let e = [];
          t.indexOf("\r") !== -1 && (t = t.replace(/\r\n?/g, (s, i) => (s.length > 1 && e.push(i), `
`)));
          let n = [], r = 0;
          do {
            let s = new _n(), i = new Bn({ src: t });
            r = s.parse(i, r), n.push(s);
          } while (r < t.length);
          return n.setOrigRanges = () => {
            if (e.length === 0) return false;
            for (let i = 1; i < e.length; ++i) e[i] -= i;
            let s = 0;
            for (let i = 0; i < n.length; ++i) s = n[i].setOrigRanges(e, s);
            return e.splice(0, e.length), true;
          }, n.toString = () => n.join(`...
`), n;
        }
        xs.parse = Io;
      });
      var qe = te((k) => {
        "use strict";
        var p = le();
        function Po(t, e, n) {
          return n ? `#${n.replace(/[\s\S]^/gm, `$&${e}#`)}
${e}${t}` : t;
        }
        function Fe(t, e, n) {
          return n ? n.indexOf(`
`) === -1 ? `${t} #${n}` : `${t}
` + n.replace(/^/gm, `${e || ""}#`) : t;
        }
        var W = class {
        };
        function ue(t, e, n) {
          if (Array.isArray(t)) return t.map((r, s) => ue(r, String(s), n));
          if (t && typeof t.toJSON == "function") {
            let r = n && n.anchors && n.anchors.get(t);
            r && (n.onCreate = (i) => {
              r.res = i, delete n.onCreate;
            });
            let s = t.toJSON(e, n);
            return r && n.onCreate && n.onCreate(s), s;
          }
          return (!n || !n.keep) && typeof t == "bigint" ? Number(t) : t;
        }
        var P = class extends W {
          constructor(e) {
            super(), this.value = e;
          }
          toJSON(e, n) {
            return n && n.keep ? this.value : ue(this.value, e, n);
          }
          toString() {
            return String(this.value);
          }
        };
        function Ds(t, e, n) {
          let r = n;
          for (let s = e.length - 1; s >= 0; --s) {
            let i = e[s];
            if (Number.isInteger(i) && i >= 0) {
              let o = [];
              o[i] = r, r = o;
            } else {
              let o = {};
              Object.defineProperty(o, i, { value: r, writable: true, enumerable: true, configurable: true }), r = o;
            }
          }
          return t.createNode(r, false);
        }
        var Bs = (t) => t == null || typeof t == "object" && t[Symbol.iterator]().next().done, j = class t extends W {
          constructor(e) {
            super(), p._defineProperty(this, "items", []), this.schema = e;
          }
          addIn(e, n) {
            if (Bs(e)) this.add(n);
            else {
              let [r, ...s] = e, i = this.get(r, true);
              if (i instanceof t) i.addIn(s, n);
              else if (i === void 0 && this.schema) this.set(r, Ds(this.schema, s, n));
              else throw new Error(`Expected YAML collection at ${r}. Remaining path: ${s}`);
            }
          }
          deleteIn([e, ...n]) {
            if (n.length === 0) return this.delete(e);
            let r = this.get(e, true);
            if (r instanceof t) return r.deleteIn(n);
            throw new Error(`Expected YAML collection at ${e}. Remaining path: ${n}`);
          }
          getIn([e, ...n], r) {
            let s = this.get(e, true);
            return n.length === 0 ? !r && s instanceof P ? s.value : s : s instanceof t ? s.getIn(n, r) : void 0;
          }
          hasAllNullValues() {
            return this.items.every((e) => {
              if (!e || e.type !== "PAIR") return false;
              let n = e.value;
              return n == null || n instanceof P && n.value == null && !n.commentBefore && !n.comment && !n.tag;
            });
          }
          hasIn([e, ...n]) {
            if (n.length === 0) return this.has(e);
            let r = this.get(e, true);
            return r instanceof t ? r.hasIn(n) : false;
          }
          setIn([e, ...n], r) {
            if (n.length === 0) this.set(e, r);
            else {
              let s = this.get(e, true);
              if (s instanceof t) s.setIn(n, r);
              else if (s === void 0 && this.schema) this.set(e, Ds(this.schema, n, r));
              else throw new Error(`Expected YAML collection at ${e}. Remaining path: ${n}`);
            }
          }
          toJSON() {
            return null;
          }
          toString(e, { blockItem: n, flowChars: r, isMap: s, itemIndent: i }, o, a2) {
            let { indent: c, indentStep: l, stringify: f2 } = e, m = this.type === p.Type.FLOW_MAP || this.type === p.Type.FLOW_SEQ || e.inFlow;
            m && (i += l);
            let d = s && this.hasAllNullValues();
            e = Object.assign({}, e, { allNullValues: d, indent: i, inFlow: m, type: null });
            let y = false, h = false, g = this.items.reduce((C, L, M) => {
              let A2;
              L && (!y && L.spaceBefore && C.push({ type: "comment", str: "" }), L.commentBefore && L.commentBefore.match(/^.*$/gm).forEach((Ai) => {
                C.push({ type: "comment", str: `#${Ai}` });
              }), L.comment && (A2 = L.comment), m && (!y && L.spaceBefore || L.commentBefore || L.comment || L.key && (L.key.commentBefore || L.key.comment) || L.value && (L.value.commentBefore || L.value.comment)) && (h = true)), y = false;
              let _ = f2(L, e, () => A2 = null, () => y = true);
              return m && !h && _.includes(`
`) && (h = true), m && M < this.items.length - 1 && (_ += ","), _ = Fe(_, i, A2), y && (A2 || m) && (y = false), C.push({ type: "item", str: _ }), C;
            }, []), w;
            if (g.length === 0) w = r.start + r.end;
            else if (m) {
              let { start: C, end: L } = r, M = g.map((A2) => A2.str);
              if (h || M.reduce((A2, _) => A2 + _.length + 2, 2) > t.maxFlowStringSingleLineLength) {
                w = C;
                for (let A2 of M) w += A2 ? `
${l}${c}${A2}` : `
`;
                w += `
${c}${L}`;
              } else w = `${C} ${M.join(" ")} ${L}`;
            } else {
              let C = g.map(n);
              w = C.shift();
              for (let L of C) w += L ? `
${c}${L}` : `
`;
            }
            return this.comment ? (w += `
` + this.comment.replace(/^/gm, `${c}#`), o && o()) : y && a2 && a2(), w;
          }
        };
        p._defineProperty(j, "maxFlowStringSingleLineLength", 60);
        function Ft(t) {
          let e = t instanceof P ? t.value : t;
          return e && typeof e == "string" && (e = Number(e)), Number.isInteger(e) && e >= 0 ? e : null;
        }
        var pe = class extends j {
          add(e) {
            this.items.push(e);
          }
          delete(e) {
            let n = Ft(e);
            return typeof n != "number" ? false : this.items.splice(n, 1).length > 0;
          }
          get(e, n) {
            let r = Ft(e);
            if (typeof r != "number") return;
            let s = this.items[r];
            return !n && s instanceof P ? s.value : s;
          }
          has(e) {
            let n = Ft(e);
            return typeof n == "number" && n < this.items.length;
          }
          set(e, n) {
            let r = Ft(e);
            if (typeof r != "number") throw new Error(`Expected a valid index, not ${e}.`);
            this.items[r] = n;
          }
          toJSON(e, n) {
            let r = [];
            n && n.onCreate && n.onCreate(r);
            let s = 0;
            for (let i of this.items) r.push(ue(i, String(s++), n));
            return r;
          }
          toString(e, n, r) {
            return e ? super.toString(e, { blockItem: (s) => s.type === "comment" ? s.str : `- ${s.str}`, flowChars: { start: "[", end: "]" }, isMap: false, itemIndent: (e.indent || "") + "  " }, n, r) : JSON.stringify(this);
          }
        }, _o = (t, e, n) => e === null ? "" : typeof e != "object" ? String(e) : t instanceof W && n && n.doc ? t.toString({ anchors: /* @__PURE__ */ Object.create(null), doc: n.doc, indent: "", indentStep: n.indentStep, inFlow: true, inStringifyKey: true, stringify: n.stringify }) : JSON.stringify(e), T = class t extends W {
          constructor(e, n = null) {
            super(), this.key = e, this.value = n, this.type = t.Type.PAIR;
          }
          get commentBefore() {
            return this.key instanceof W ? this.key.commentBefore : void 0;
          }
          set commentBefore(e) {
            if (this.key == null && (this.key = new P(null)), this.key instanceof W) this.key.commentBefore = e;
            else {
              let n = "Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";
              throw new Error(n);
            }
          }
          addToJSMap(e, n) {
            let r = ue(this.key, "", e);
            if (n instanceof Map) {
              let s = ue(this.value, r, e);
              n.set(r, s);
            } else if (n instanceof Set) n.add(r);
            else {
              let s = _o(this.key, r, e), i = ue(this.value, s, e);
              s in n ? Object.defineProperty(n, s, { value: i, writable: true, enumerable: true, configurable: true }) : n[s] = i;
            }
            return n;
          }
          toJSON(e, n) {
            let r = n && n.mapAsMap ? /* @__PURE__ */ new Map() : {};
            return this.addToJSMap(n, r);
          }
          toString(e, n, r) {
            if (!e || !e.doc) return JSON.stringify(this);
            let { indent: s, indentSeq: i, simpleKeys: o } = e.doc.options, { key: a2, value: c } = this, l = a2 instanceof W && a2.comment;
            if (o) {
              if (l) throw new Error("With simple keys, key nodes cannot have comments");
              if (a2 instanceof j) {
                let _ = "With simple keys, collection cannot be used as a key value";
                throw new Error(_);
              }
            }
            let f2 = !o && (!a2 || l || (a2 instanceof W ? a2 instanceof j || a2.type === p.Type.BLOCK_FOLDED || a2.type === p.Type.BLOCK_LITERAL : typeof a2 == "object")), { doc: m, indent: d, indentStep: y, stringify: h } = e;
            e = Object.assign({}, e, { implicitKey: !f2, indent: d + y });
            let g = false, w = h(a2, e, () => l = null, () => g = true);
            if (w = Fe(w, e.indent, l), !f2 && w.length > 1024) {
              if (o) throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
              f2 = true;
            }
            if (e.allNullValues && !o) return this.comment ? (w = Fe(w, e.indent, this.comment), n && n()) : g && !l && r && r(), e.inFlow && !f2 ? w : `? ${w}`;
            w = f2 ? `? ${w}
${d}:` : `${w}:`, this.comment && (w = Fe(w, e.indent, this.comment), n && n());
            let C = "", L = null;
            if (c instanceof W) {
              if (c.spaceBefore && (C = `
`), c.commentBefore) {
                let _ = c.commentBefore.replace(/^/gm, `${e.indent}#`);
                C += `
${_}`;
              }
              L = c.comment;
            } else c && typeof c == "object" && (c = m.schema.createNode(c, true));
            e.implicitKey = false, !f2 && !this.comment && c instanceof P && (e.indentAtStart = w.length + 1), g = false, !i && s >= 2 && !e.inFlow && !f2 && c instanceof pe && c.type !== p.Type.FLOW_SEQ && !c.tag && !m.anchors.getName(c) && (e.indent = e.indent.substr(2));
            let M = h(c, e, () => L = null, () => g = true), A2 = " ";
            return C || this.comment ? A2 = `${C}
${e.indent}` : !f2 && c instanceof j ? (!(M[0] === "[" || M[0] === "{") || M.includes(`
`)) && (A2 = `
${e.indent}`) : M[0] === `
` && (A2 = ""), g && !L && r && r(), Fe(w + A2 + M, e.indent, L);
          }
        };
        p._defineProperty(T, "Type", { PAIR: "PAIR", MERGE_PAIR: "MERGE_PAIR" });
        var qt = (t, e) => {
          if (t instanceof be) {
            let n = e.get(t.source);
            return n.count * n.aliasCount;
          } else if (t instanceof j) {
            let n = 0;
            for (let r of t.items) {
              let s = qt(r, e);
              s > n && (n = s);
            }
            return n;
          } else if (t instanceof T) {
            let n = qt(t.key, e), r = qt(t.value, e);
            return Math.max(n, r);
          }
          return 1;
        }, be = class t extends W {
          static stringify({ range: e, source: n }, { anchors: r, doc: s, implicitKey: i, inStringifyKey: o }) {
            let a2 = Object.keys(r).find((l) => r[l] === n);
            if (!a2 && o && (a2 = s.anchors.getName(n) || s.anchors.newName()), a2) return `*${a2}${i ? " " : ""}`;
            let c = s.anchors.getName(n) ? "Alias node must be after source node" : "Source node not found for alias node";
            throw new Error(`${c} [${e}]`);
          }
          constructor(e) {
            super(), this.source = e, this.type = p.Type.ALIAS;
          }
          set tag(e) {
            throw new Error("Alias nodes cannot have tags");
          }
          toJSON(e, n) {
            if (!n) return ue(this.source, e, n);
            let { anchors: r, maxAliasCount: s } = n, i = r.get(this.source);
            if (!i || i.res === void 0) {
              let o = "This should not happen: Alias anchor was not resolved?";
              throw this.cstNode ? new p.YAMLReferenceError(this.cstNode, o) : new ReferenceError(o);
            }
            if (s >= 0 && (i.count += 1, i.aliasCount === 0 && (i.aliasCount = qt(this.source, r)), i.count * i.aliasCount > s)) {
              let o = "Excessive alias count indicates a resource exhaustion attack";
              throw this.cstNode ? new p.YAMLReferenceError(this.cstNode, o) : new ReferenceError(o);
            }
            return i.res;
          }
          toString(e) {
            return t.stringify(this, e);
          }
        };
        p._defineProperty(be, "default", true);
        function pt(t, e) {
          let n = e instanceof P ? e.value : e;
          for (let r of t) if (r instanceof T && (r.key === e || r.key === n || r.key && r.key.value === n)) return r;
        }
        var mt = class extends j {
          add(e, n) {
            e ? e instanceof T || (e = new T(e.key || e, e.value)) : e = new T(e);
            let r = pt(this.items, e.key), s = this.schema && this.schema.sortMapEntries;
            if (r) if (n) r.value = e.value;
            else throw new Error(`Key ${e.key} already set`);
            else if (s) {
              let i = this.items.findIndex((o) => s(e, o) < 0);
              i === -1 ? this.items.push(e) : this.items.splice(i, 0, e);
            } else this.items.push(e);
          }
          delete(e) {
            let n = pt(this.items, e);
            return n ? this.items.splice(this.items.indexOf(n), 1).length > 0 : false;
          }
          get(e, n) {
            let r = pt(this.items, e), s = r && r.value;
            return !n && s instanceof P ? s.value : s;
          }
          has(e) {
            return !!pt(this.items, e);
          }
          set(e, n) {
            this.add(new T(e, n), true);
          }
          toJSON(e, n, r) {
            let s = r ? new r() : n && n.mapAsMap ? /* @__PURE__ */ new Map() : {};
            n && n.onCreate && n.onCreate(s);
            for (let i of this.items) i.addToJSMap(n, s);
            return s;
          }
          toString(e, n, r) {
            if (!e) return JSON.stringify(this);
            for (let s of this.items) if (!(s instanceof T)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(s)} instead`);
            return super.toString(e, { blockItem: (s) => s.str, flowChars: { start: "{", end: "}" }, isMap: true, itemIndent: e.indent || "" }, n, r);
          }
        }, Fs = "<<", Vt = class extends T {
          constructor(e) {
            if (e instanceof T) {
              let n = e.value;
              n instanceof pe || (n = new pe(), n.items.push(e.value), n.range = e.value.range), super(e.key, n), this.range = e.range;
            } else super(new P(Fs), new pe());
            this.type = T.Type.MERGE_PAIR;
          }
          addToJSMap(e, n) {
            for (let { source: r } of this.value.items) {
              if (!(r instanceof mt)) throw new Error("Merge sources must be maps");
              let s = r.toJSON(null, e, Map);
              for (let [i, o] of s) n instanceof Map ? n.has(i) || n.set(i, o) : n instanceof Set ? n.add(i) : Object.prototype.hasOwnProperty.call(n, i) || Object.defineProperty(n, i, { value: o, writable: true, enumerable: true, configurable: true });
            }
            return n;
          }
          toString(e, n) {
            let r = this.value;
            if (r.items.length > 1) return super.toString(e, n);
            this.value = r.items[0];
            let s = super.toString(e, n);
            return this.value = r, s;
          }
        }, xo = { defaultType: p.Type.BLOCK_LITERAL, lineWidth: 76 }, Ro = { trueStr: "true", falseStr: "false" }, Do = { asBigInt: false }, Yo = { nullStr: "null" }, Ne = { defaultType: p.Type.PLAIN, doubleQuoted: { jsonEncoding: false, minMultiLineLength: 40 }, fold: { lineWidth: 80, minContentWidth: 20 } };
        function qn(t, e, n) {
          for (let { format: r, test: s, resolve: i } of e) if (s) {
            let o = t.match(s);
            if (o) {
              let a2 = i.apply(null, o);
              return a2 instanceof P || (a2 = new P(a2)), r && (a2.format = r), a2;
            }
          }
          return n && (t = n(t)), new P(t);
        }
        var qs = "flow", Fn = "block", Ut = "quoted", Ys = (t, e) => {
          let n = t[e + 1];
          for (; n === " " || n === "	"; ) {
            do
              n = t[e += 1];
            while (n && n !== `
`);
            n = t[e + 1];
          }
          return e;
        };
        function Wt(t, e, n, { indentAtStart: r, lineWidth: s = 80, minContentWidth: i = 20, onFold: o, onOverflow: a2 }) {
          if (!s || s < 0) return t;
          let c = Math.max(1 + i, 1 + s - e.length);
          if (t.length <= c) return t;
          let l = [], f2 = {}, m = s - e.length;
          typeof r == "number" && (r > s - Math.max(2, i) ? l.push(0) : m = s - r);
          let d, y, h = false, g = -1, w = -1, C = -1;
          n === Fn && (g = Ys(t, g), g !== -1 && (m = g + c));
          for (let M; M = t[g += 1]; ) {
            if (n === Ut && M === "\\") {
              switch (w = g, t[g + 1]) {
                case "x":
                  g += 3;
                  break;
                case "u":
                  g += 5;
                  break;
                case "U":
                  g += 9;
                  break;
                default:
                  g += 1;
              }
              C = g;
            }
            if (M === `
`) n === Fn && (g = Ys(t, g)), m = g + c, d = void 0;
            else {
              if (M === " " && y && y !== " " && y !== `
` && y !== "	") {
                let A2 = t[g + 1];
                A2 && A2 !== " " && A2 !== `
` && A2 !== "	" && (d = g);
              }
              if (g >= m) if (d) l.push(d), m = d + c, d = void 0;
              else if (n === Ut) {
                for (; y === " " || y === "	"; ) y = M, M = t[g += 1], h = true;
                let A2 = g > C + 1 ? g - 2 : w - 1;
                if (f2[A2]) return t;
                l.push(A2), f2[A2] = true, m = A2 + c, d = void 0;
              } else h = true;
            }
            y = M;
          }
          if (h && a2 && a2(), l.length === 0) return t;
          o && o();
          let L = t.slice(0, l[0]);
          for (let M = 0; M < l.length; ++M) {
            let A2 = l[M], _ = l[M + 1] || t.length;
            A2 === 0 ? L = `
${e}${t.slice(0, _)}` : (n === Ut && f2[A2] && (L += `${t[A2]}\\`), L += `
${e}${t.slice(A2 + 1, _)}`);
          }
          return L;
        }
        var Un = ({ indentAtStart: t }) => t ? Object.assign({ indentAtStart: t }, Ne.fold) : Ne.fold, jt = (t) => /^(%|---|\.\.\.)/m.test(t);
        function $o(t, e, n) {
          if (!e || e < 0) return false;
          let r = e - n, s = t.length;
          if (s <= r) return false;
          for (let i = 0, o = 0; i < s; ++i) if (t[i] === `
`) {
            if (i - o > r) return true;
            if (o = i + 1, s - o <= r) return false;
          }
          return true;
        }
        function we(t, e) {
          let { implicitKey: n } = e, { jsonEncoding: r, minMultiLineLength: s } = Ne.doubleQuoted, i = JSON.stringify(t);
          if (r) return i;
          let o = e.indent || (jt(t) ? "  " : ""), a2 = "", c = 0;
          for (let l = 0, f2 = i[l]; f2; f2 = i[++l]) if (f2 === " " && i[l + 1] === "\\" && i[l + 2] === "n" && (a2 += i.slice(c, l) + "\\ ", l += 1, c = l, f2 = "\\"), f2 === "\\") switch (i[l + 1]) {
            case "u":
              {
                a2 += i.slice(c, l);
                let m = i.substr(l + 2, 4);
                switch (m) {
                  case "0000":
                    a2 += "\\0";
                    break;
                  case "0007":
                    a2 += "\\a";
                    break;
                  case "000b":
                    a2 += "\\v";
                    break;
                  case "001b":
                    a2 += "\\e";
                    break;
                  case "0085":
                    a2 += "\\N";
                    break;
                  case "00a0":
                    a2 += "\\_";
                    break;
                  case "2028":
                    a2 += "\\L";
                    break;
                  case "2029":
                    a2 += "\\P";
                    break;
                  default:
                    m.substr(0, 2) === "00" ? a2 += "\\x" + m.substr(2) : a2 += i.substr(l, 6);
                }
                l += 5, c = l + 1;
              }
              break;
            case "n":
              if (n || i[l + 2] === '"' || i.length < s) l += 1;
              else {
                for (a2 += i.slice(c, l) + `

`; i[l + 2] === "\\" && i[l + 3] === "n" && i[l + 4] !== '"'; ) a2 += `
`, l += 2;
                a2 += o, i[l + 2] === " " && (a2 += "\\"), l += 1, c = l + 1;
              }
              break;
            default:
              l += 1;
          }
          return a2 = c ? a2 + i.slice(c) : i, n ? a2 : Wt(a2, o, Ut, Un(e));
        }
        function Us(t, e) {
          if (e.implicitKey) {
            if (/\n/.test(t)) return we(t, e);
          } else if (/[ \t]\n|\n[ \t]/.test(t)) return we(t, e);
          let n = e.indent || (jt(t) ? "  " : ""), r = "'" + t.replace(/'/g, "''").replace(/\n+/g, `$&
${n}`) + "'";
          return e.implicitKey ? r : Wt(r, n, qs, Un(e));
        }
        function Kt({ comment: t, type: e, value: n }, r, s, i) {
          if (/\n[\t ]+$/.test(n) || /^\s*$/.test(n)) return we(n, r);
          let o = r.indent || (r.forceBlockIndent || jt(n) ? "  " : ""), a2 = o ? "2" : "1", c = e === p.Type.BLOCK_FOLDED ? false : e === p.Type.BLOCK_LITERAL ? true : !$o(n, Ne.fold.lineWidth, o.length), l = c ? "|" : ">";
          if (!n) return l + `
`;
          let f2 = "", m = "";
          if (n = n.replace(/[\n\t ]*$/, (y) => {
            let h = y.indexOf(`
`);
            return h === -1 ? l += "-" : (n === y || h !== y.length - 1) && (l += "+", i && i()), m = y.replace(/\n$/, ""), "";
          }).replace(/^[\n ]*/, (y) => {
            y.indexOf(" ") !== -1 && (l += a2);
            let h = y.match(/ +$/);
            return h ? (f2 = y.slice(0, -h[0].length), h[0]) : (f2 = y, "");
          }), m && (m = m.replace(/\n+(?!\n|$)/g, `$&${o}`)), f2 && (f2 = f2.replace(/\n+/g, `$&${o}`)), t && (l += " #" + t.replace(/ ?[\r\n]+/g, " "), s && s()), !n) return `${l}${a2}
${o}${m}`;
          if (c) return n = n.replace(/\n+/g, `$&${o}`), `${l}
${o}${f2}${n}${m}`;
          n = n.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${o}`);
          let d = Wt(`${f2}${n}${m}`, o, Fn, Ne.fold);
          return `${l}
${o}${d}`;
        }
        function Bo(t, e, n, r) {
          let { comment: s, type: i, value: o } = t, { actualString: a2, implicitKey: c, indent: l, inFlow: f2 } = e;
          if (c && /[\n[\]{},]/.test(o) || f2 && /[[\]{},]/.test(o)) return we(o, e);
          if (!o || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(o)) return c || f2 || o.indexOf(`
`) === -1 ? o.indexOf('"') !== -1 && o.indexOf("'") === -1 ? Us(o, e) : we(o, e) : Kt(t, e, n, r);
          if (!c && !f2 && i !== p.Type.PLAIN && o.indexOf(`
`) !== -1) return Kt(t, e, n, r);
          if (l === "" && jt(o)) return e.forceBlockIndent = true, Kt(t, e, n, r);
          let m = o.replace(/\n+/g, `$&
${l}`);
          if (a2) {
            let { tags: y } = e.doc.schema;
            if (typeof qn(m, y, y.scalarFallback).value != "string") return we(o, e);
          }
          let d = c ? m : Wt(m, l, qs, Un(e));
          return s && !f2 && (d.indexOf(`
`) !== -1 || s.indexOf(`
`) !== -1) ? (n && n(), Po(d, l, s)) : d;
        }
        function Fo(t, e, n, r) {
          let { defaultType: s } = Ne, { implicitKey: i, inFlow: o } = e, { type: a2, value: c } = t;
          typeof c != "string" && (c = String(c), t = Object.assign({}, t, { value: c }));
          let l = (m) => {
            switch (m) {
              case p.Type.BLOCK_FOLDED:
              case p.Type.BLOCK_LITERAL:
                return Kt(t, e, n, r);
              case p.Type.QUOTE_DOUBLE:
                return we(c, e);
              case p.Type.QUOTE_SINGLE:
                return Us(c, e);
              case p.Type.PLAIN:
                return Bo(t, e, n, r);
              default:
                return null;
            }
          };
          (a2 !== p.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(c) || (i || o) && (a2 === p.Type.BLOCK_FOLDED || a2 === p.Type.BLOCK_LITERAL)) && (a2 = p.Type.QUOTE_DOUBLE);
          let f2 = l(a2);
          if (f2 === null && (f2 = l(s), f2 === null)) throw new Error(`Unsupported default string type ${s}`);
          return f2;
        }
        function qo({ format: t, minFractionDigits: e, tag: n, value: r }) {
          if (typeof r == "bigint") return String(r);
          if (!isFinite(r)) return isNaN(r) ? ".nan" : r < 0 ? "-.inf" : ".inf";
          let s = JSON.stringify(r);
          if (!t && e && (!n || n === "tag:yaml.org,2002:float") && /^\d/.test(s)) {
            let i = s.indexOf(".");
            i < 0 && (i = s.length, s += ".");
            let o = e - (s.length - i - 1);
            for (; o-- > 0; ) s += "0";
          }
          return s;
        }
        function Ks(t, e) {
          let n, r;
          switch (e.type) {
            case p.Type.FLOW_MAP:
              n = "}", r = "flow map";
              break;
            case p.Type.FLOW_SEQ:
              n = "]", r = "flow sequence";
              break;
            default:
              t.push(new p.YAMLSemanticError(e, "Not a flow collection!?"));
              return;
          }
          let s;
          for (let i = e.items.length - 1; i >= 0; --i) {
            let o = e.items[i];
            if (!o || o.type !== p.Type.COMMENT) {
              s = o;
              break;
            }
          }
          if (s && s.char !== n) {
            let i = `Expected ${r} to end with ${n}`, o;
            typeof s.offset == "number" ? (o = new p.YAMLSemanticError(e, i), o.offset = s.offset + 1) : (o = new p.YAMLSemanticError(s, i), s.range && s.range.end && (o.offset = s.range.end - s.range.start)), t.push(o);
          }
        }
        function Vs(t, e) {
          let n = e.context.src[e.range.start - 1];
          if (n !== `
` && n !== "	" && n !== " ") {
            let r = "Comments must be separated from other tokens by white space characters";
            t.push(new p.YAMLSemanticError(e, r));
          }
        }
        function Ws(t, e) {
          let n = String(e), r = n.substr(0, 8) + "..." + n.substr(-8);
          return new p.YAMLSemanticError(t, `The "${r}" key is too long`);
        }
        function js(t, e) {
          for (let { afterKey: n, before: r, comment: s } of e) {
            let i = t.items[r];
            i ? (n && i.value && (i = i.value), s === void 0 ? (n || !i.commentBefore) && (i.spaceBefore = true) : i.commentBefore ? i.commentBefore += `
` + s : i.commentBefore = s) : s !== void 0 && (t.comment ? t.comment += `
` + s : t.comment = s);
          }
        }
        function Kn(t, e) {
          let n = e.strValue;
          return n ? typeof n == "string" ? n : (n.errors.forEach((r) => {
            r.source || (r.source = e), t.errors.push(r);
          }), n.str) : "";
        }
        function Uo(t, e) {
          let { handle: n, suffix: r } = e.tag, s = t.tagPrefixes.find((i) => i.handle === n);
          if (!s) {
            let i = t.getDefaults().tagPrefixes;
            if (i && (s = i.find((o) => o.handle === n)), !s) throw new p.YAMLSemanticError(e, `The ${n} tag handle is non-default and was not declared.`);
          }
          if (!r) throw new p.YAMLSemanticError(e, `The ${n} tag has no suffix.`);
          if (n === "!" && (t.version || t.options.version) === "1.0") {
            if (r[0] === "^") return t.warnings.push(new p.YAMLWarning(e, "YAML 1.0 ^ tag expansion is not supported")), r;
            if (/[:/]/.test(r)) {
              let i = r.match(/^([a-z0-9-]+)\/(.*)/i);
              return i ? `tag:${i[1]}.yaml.org,2002:${i[2]}` : `tag:${r}`;
            }
          }
          return s.prefix + decodeURIComponent(r);
        }
        function Ko(t, e) {
          let { tag: n, type: r } = e, s = false;
          if (n) {
            let { handle: i, suffix: o, verbatim: a2 } = n;
            if (a2) {
              if (a2 !== "!" && a2 !== "!!") return a2;
              let c = `Verbatim tags aren't resolved, so ${a2} is invalid.`;
              t.errors.push(new p.YAMLSemanticError(e, c));
            } else if (i === "!" && !o) s = true;
            else try {
              return Uo(t, e);
            } catch (c) {
              t.errors.push(c);
            }
          }
          switch (r) {
            case p.Type.BLOCK_FOLDED:
            case p.Type.BLOCK_LITERAL:
            case p.Type.QUOTE_DOUBLE:
            case p.Type.QUOTE_SINGLE:
              return p.defaultTags.STR;
            case p.Type.FLOW_MAP:
            case p.Type.MAP:
              return p.defaultTags.MAP;
            case p.Type.FLOW_SEQ:
            case p.Type.SEQ:
              return p.defaultTags.SEQ;
            case p.Type.PLAIN:
              return s ? p.defaultTags.STR : null;
            default:
              return null;
          }
        }
        function $s(t, e, n) {
          let { tags: r } = t.schema, s = [];
          for (let o of r) if (o.tag === n) if (o.test) s.push(o);
          else {
            let a2 = o.resolve(t, e);
            return a2 instanceof j ? a2 : new P(a2);
          }
          let i = Kn(t, e);
          return typeof i == "string" && s.length > 0 ? qn(i, s, r.scalarFallback) : null;
        }
        function Vo({ type: t }) {
          switch (t) {
            case p.Type.FLOW_MAP:
            case p.Type.MAP:
              return p.defaultTags.MAP;
            case p.Type.FLOW_SEQ:
            case p.Type.SEQ:
              return p.defaultTags.SEQ;
            default:
              return p.defaultTags.STR;
          }
        }
        function Wo(t, e, n) {
          try {
            let r = $s(t, e, n);
            if (r) return n && e.tag && (r.tag = n), r;
          } catch (r) {
            return r.source || (r.source = e), t.errors.push(r), null;
          }
          try {
            let r = Vo(e);
            if (!r) throw new Error(`The tag ${n} is unavailable`);
            let s = `The tag ${n} is unavailable, falling back to ${r}`;
            t.warnings.push(new p.YAMLWarning(e, s));
            let i = $s(t, e, r);
            return i.tag = n, i;
          } catch (r) {
            let s = new p.YAMLReferenceError(e, r.message);
            return s.stack = r.stack, t.errors.push(s), null;
          }
        }
        var jo = (t) => {
          if (!t) return false;
          let { type: e } = t;
          return e === p.Type.MAP_KEY || e === p.Type.MAP_VALUE || e === p.Type.SEQ_ITEM;
        };
        function Qo(t, e) {
          let n = { before: [], after: [] }, r = false, s = false, i = jo(e.context.parent) ? e.context.parent.props.concat(e.props) : e.props;
          for (let { start: o, end: a2 } of i) switch (e.context.src[o]) {
            case p.Char.COMMENT: {
              if (!e.commentHasRequiredWhitespace(o)) {
                let m = "Comments must be separated from other tokens by white space characters";
                t.push(new p.YAMLSemanticError(e, m));
              }
              let { header: c, valueRange: l } = e;
              (l && (o > l.start || c && o > c.start) ? n.after : n.before).push(e.context.src.slice(o + 1, a2));
              break;
            }
            case p.Char.ANCHOR:
              if (r) {
                let c = "A node can have at most one anchor";
                t.push(new p.YAMLSemanticError(e, c));
              }
              r = true;
              break;
            case p.Char.TAG:
              if (s) {
                let c = "A node can have at most one tag";
                t.push(new p.YAMLSemanticError(e, c));
              }
              s = true;
              break;
          }
          return { comments: n, hasAnchor: r, hasTag: s };
        }
        function Jo(t, e) {
          let { anchors: n, errors: r, schema: s } = t;
          if (e.type === p.Type.ALIAS) {
            let o = e.rawValue, a2 = n.getNode(o);
            if (!a2) {
              let l = `Aliased anchor not found: ${o}`;
              return r.push(new p.YAMLReferenceError(e, l)), null;
            }
            let c = new be(a2);
            return n._cstAliases.push(c), c;
          }
          let i = Ko(t, e);
          if (i) return Wo(t, e, i);
          if (e.type !== p.Type.PLAIN) {
            let o = `Failed to resolve ${e.type} node here`;
            return r.push(new p.YAMLSyntaxError(e, o)), null;
          }
          try {
            let o = Kn(t, e);
            return qn(o, s.tags, s.tags.scalarFallback);
          } catch (o) {
            return o.source || (o.source = e), r.push(o), null;
          }
        }
        function me(t, e) {
          if (!e) return null;
          e.error && t.errors.push(e.error);
          let { comments: n, hasAnchor: r, hasTag: s } = Qo(t.errors, e);
          if (r) {
            let { anchors: o } = t, a2 = e.anchor, c = o.getNode(a2);
            c && (o.map[o.newName(a2)] = c), o.map[a2] = e;
          }
          if (e.type === p.Type.ALIAS && (r || s)) {
            let o = "An alias node must not specify any properties";
            t.errors.push(new p.YAMLSemanticError(e, o));
          }
          let i = Jo(t, e);
          if (i) {
            i.range = [e.range.start, e.range.end], t.options.keepCstNodes && (i.cstNode = e), t.options.keepNodeTypes && (i.type = e.type);
            let o = n.before.join(`
`);
            o && (i.commentBefore = i.commentBefore ? `${i.commentBefore}
${o}` : o);
            let a2 = n.after.join(`
`);
            a2 && (i.comment = i.comment ? `${i.comment}
${a2}` : a2);
          }
          return e.resolved = i;
        }
        function Go(t, e) {
          if (e.type !== p.Type.MAP && e.type !== p.Type.FLOW_MAP) {
            let o = `A ${e.type} node cannot be resolved as a mapping`;
            return t.errors.push(new p.YAMLSyntaxError(e, o)), null;
          }
          let { comments: n, items: r } = e.type === p.Type.FLOW_MAP ? Zo(t, e) : zo(t, e), s = new mt();
          s.items = r, js(s, n);
          let i = false;
          for (let o = 0; o < r.length; ++o) {
            let { key: a2 } = r[o];
            if (a2 instanceof j && (i = true), t.schema.merge && a2 && a2.value === Fs) {
              r[o] = new Vt(r[o]);
              let c = r[o].value.items, l = null;
              c.some((f2) => {
                if (f2 instanceof be) {
                  let { type: m } = f2.source;
                  return m === p.Type.MAP || m === p.Type.FLOW_MAP ? false : l = "Merge nodes aliases can only point to maps";
                }
                return l = "Merge nodes can only have Alias nodes as values";
              }), l && t.errors.push(new p.YAMLSemanticError(e, l));
            } else for (let c = o + 1; c < r.length; ++c) {
              let { key: l } = r[c];
              if (a2 === l || a2 && l && Object.prototype.hasOwnProperty.call(a2, "value") && a2.value === l.value) {
                let f2 = `Map keys must be unique; "${a2}" is repeated`;
                t.errors.push(new p.YAMLSemanticError(e, f2));
                break;
              }
            }
          }
          if (i && !t.options.mapAsMap) {
            let o = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
            t.warnings.push(new p.YAMLWarning(e, o));
          }
          return e.resolved = s, s;
        }
        var Ho = ({ context: { lineStart: t, node: e, src: n }, props: r }) => {
          if (r.length === 0) return false;
          let { start: s } = r[0];
          if (e && s > e.valueRange.start || n[s] !== p.Char.COMMENT) return false;
          for (let i = t; i < s; ++i) if (n[i] === `
`) return false;
          return true;
        };
        function Xo(t, e) {
          if (!Ho(t)) return;
          let n = t.getPropValue(0, p.Char.COMMENT, true), r = false, s = e.value.commentBefore;
          if (s && s.startsWith(n)) e.value.commentBefore = s.substr(n.length + 1), r = true;
          else {
            let i = e.value.comment;
            !t.node && i && i.startsWith(n) && (e.value.comment = i.substr(n.length + 1), r = true);
          }
          r && (e.comment = n);
        }
        function zo(t, e) {
          let n = [], r = [], s, i = null;
          for (let o = 0; o < e.items.length; ++o) {
            let a2 = e.items[o];
            switch (a2.type) {
              case p.Type.BLANK_LINE:
                n.push({ afterKey: !!s, before: r.length });
                break;
              case p.Type.COMMENT:
                n.push({ afterKey: !!s, before: r.length, comment: a2.comment });
                break;
              case p.Type.MAP_KEY:
                s !== void 0 && r.push(new T(s)), a2.error && t.errors.push(a2.error), s = me(t, a2.node), i = null;
                break;
              case p.Type.MAP_VALUE:
                {
                  if (s === void 0 && (s = null), a2.error && t.errors.push(a2.error), !a2.context.atLineStart && a2.node && a2.node.type === p.Type.MAP && !a2.node.context.atLineStart) {
                    let f2 = "Nested mappings are not allowed in compact mappings";
                    t.errors.push(new p.YAMLSemanticError(a2.node, f2));
                  }
                  let c = a2.node;
                  if (!c && a2.props.length > 0) {
                    c = new p.PlainValue(p.Type.PLAIN, []), c.context = { parent: a2, src: a2.context.src };
                    let f2 = a2.range.start + 1;
                    if (c.range = { start: f2, end: f2 }, c.valueRange = { start: f2, end: f2 }, typeof a2.range.origStart == "number") {
                      let m = a2.range.origStart + 1;
                      c.range.origStart = c.range.origEnd = m, c.valueRange.origStart = c.valueRange.origEnd = m;
                    }
                  }
                  let l = new T(s, me(t, c));
                  Xo(a2, l), r.push(l), s && typeof i == "number" && a2.range.start > i + 1024 && t.errors.push(Ws(e, s)), s = void 0, i = null;
                }
                break;
              default:
                s !== void 0 && r.push(new T(s)), s = me(t, a2), i = a2.range.start, a2.error && t.errors.push(a2.error);
                e: for (let c = o + 1; ; ++c) {
                  let l = e.items[c];
                  switch (l && l.type) {
                    case p.Type.BLANK_LINE:
                    case p.Type.COMMENT:
                      continue e;
                    case p.Type.MAP_VALUE:
                      break e;
                    default: {
                      let f2 = "Implicit map keys need to be followed by map values";
                      t.errors.push(new p.YAMLSemanticError(a2, f2));
                      break e;
                    }
                  }
                }
                if (a2.valueRangeContainsNewline) {
                  let c = "Implicit map keys need to be on a single line";
                  t.errors.push(new p.YAMLSemanticError(a2, c));
                }
            }
          }
          return s !== void 0 && r.push(new T(s)), { comments: n, items: r };
        }
        function Zo(t, e) {
          let n = [], r = [], s, i = false, o = "{";
          for (let a2 = 0; a2 < e.items.length; ++a2) {
            let c = e.items[a2];
            if (typeof c.char == "string") {
              let { char: l, offset: f2 } = c;
              if (l === "?" && s === void 0 && !i) {
                i = true, o = ":";
                continue;
              }
              if (l === ":") {
                if (s === void 0 && (s = null), o === ":") {
                  o = ",";
                  continue;
                }
              } else if (i && (s === void 0 && l !== "," && (s = null), i = false), s !== void 0 && (r.push(new T(s)), s = void 0, l === ",")) {
                o = ":";
                continue;
              }
              if (l === "}") {
                if (a2 === e.items.length - 1) continue;
              } else if (l === o) {
                o = ":";
                continue;
              }
              let m = `Flow map contains an unexpected ${l}`, d = new p.YAMLSyntaxError(e, m);
              d.offset = f2, t.errors.push(d);
            } else c.type === p.Type.BLANK_LINE ? n.push({ afterKey: !!s, before: r.length }) : c.type === p.Type.COMMENT ? (Vs(t.errors, c), n.push({ afterKey: !!s, before: r.length, comment: c.comment })) : s === void 0 ? (o === "," && t.errors.push(new p.YAMLSemanticError(c, "Separator , missing in flow map")), s = me(t, c)) : (o !== "," && t.errors.push(new p.YAMLSemanticError(c, "Indicator : missing in flow map entry")), r.push(new T(s, me(t, c))), s = void 0, i = false);
          }
          return Ks(t.errors, e), s !== void 0 && r.push(new T(s)), { comments: n, items: r };
        }
        function ea(t, e) {
          if (e.type !== p.Type.SEQ && e.type !== p.Type.FLOW_SEQ) {
            let i = `A ${e.type} node cannot be resolved as a sequence`;
            return t.errors.push(new p.YAMLSyntaxError(e, i)), null;
          }
          let { comments: n, items: r } = e.type === p.Type.FLOW_SEQ ? na(t, e) : ta(t, e), s = new pe();
          if (s.items = r, js(s, n), !t.options.mapAsMap && r.some((i) => i instanceof T && i.key instanceof j)) {
            let i = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
            t.warnings.push(new p.YAMLWarning(e, i));
          }
          return e.resolved = s, s;
        }
        function ta(t, e) {
          let n = [], r = [];
          for (let s = 0; s < e.items.length; ++s) {
            let i = e.items[s];
            switch (i.type) {
              case p.Type.BLANK_LINE:
                n.push({ before: r.length });
                break;
              case p.Type.COMMENT:
                n.push({ comment: i.comment, before: r.length });
                break;
              case p.Type.SEQ_ITEM:
                if (i.error && t.errors.push(i.error), r.push(me(t, i.node)), i.hasProps) {
                  let o = "Sequence items cannot have tags or anchors before the - indicator";
                  t.errors.push(new p.YAMLSemanticError(i, o));
                }
                break;
              default:
                i.error && t.errors.push(i.error), t.errors.push(new p.YAMLSyntaxError(i, `Unexpected ${i.type} node in sequence`));
            }
          }
          return { comments: n, items: r };
        }
        function na(t, e) {
          let n = [], r = [], s = false, i, o = null, a2 = "[", c = null;
          for (let l = 0; l < e.items.length; ++l) {
            let f2 = e.items[l];
            if (typeof f2.char == "string") {
              let { char: m, offset: d } = f2;
              if (m !== ":" && (s || i !== void 0) && (s && i === void 0 && (i = a2 ? r.pop() : null), r.push(new T(i)), s = false, i = void 0, o = null), m === a2) a2 = null;
              else if (!a2 && m === "?") s = true;
              else if (a2 !== "[" && m === ":" && i === void 0) {
                if (a2 === ",") {
                  if (i = r.pop(), i instanceof T) {
                    let y = "Chaining flow sequence pairs is invalid", h = new p.YAMLSemanticError(e, y);
                    h.offset = d, t.errors.push(h);
                  }
                  if (!s && typeof o == "number") {
                    let y = f2.range ? f2.range.start : f2.offset;
                    y > o + 1024 && t.errors.push(Ws(e, i));
                    let { src: h } = c.context;
                    for (let g = o; g < y; ++g) if (h[g] === `
`) {
                      let w = "Implicit keys of flow sequence pairs need to be on a single line";
                      t.errors.push(new p.YAMLSemanticError(c, w));
                      break;
                    }
                  }
                } else i = null;
                o = null, s = false, a2 = null;
              } else if (a2 === "[" || m !== "]" || l < e.items.length - 1) {
                let y = `Flow sequence contains an unexpected ${m}`, h = new p.YAMLSyntaxError(e, y);
                h.offset = d, t.errors.push(h);
              }
            } else if (f2.type === p.Type.BLANK_LINE) n.push({ before: r.length });
            else if (f2.type === p.Type.COMMENT) Vs(t.errors, f2), n.push({ comment: f2.comment, before: r.length });
            else {
              if (a2) {
                let d = `Expected a ${a2} in flow sequence`;
                t.errors.push(new p.YAMLSemanticError(f2, d));
              }
              let m = me(t, f2);
              i === void 0 ? (r.push(m), c = f2) : (r.push(new T(i, m)), i = void 0), o = f2.range.start, a2 = ",";
            }
          }
          return Ks(t.errors, e), i !== void 0 && r.push(new T(i)), { comments: n, items: r };
        }
        k.Alias = be;
        k.Collection = j;
        k.Merge = Vt;
        k.Node = W;
        k.Pair = T;
        k.Scalar = P;
        k.YAMLMap = mt;
        k.YAMLSeq = pe;
        k.addComment = Fe;
        k.binaryOptions = xo;
        k.boolOptions = Ro;
        k.findPair = pt;
        k.intOptions = Do;
        k.isEmptyPath = Bs;
        k.nullOptions = Yo;
        k.resolveMap = Go;
        k.resolveNode = me;
        k.resolveSeq = ea;
        k.resolveString = Kn;
        k.strOptions = Ne;
        k.stringifyNumber = qo;
        k.stringifyString = Fo;
        k.toJSON = ue;
      });
      var Qn = te((z) => {
        "use strict";
        var Q = le(), O = qe(), ra = { identify: (t) => t instanceof Uint8Array, default: false, tag: "tag:yaml.org,2002:binary", resolve: (t, e) => {
          let n = O.resolveString(t, e);
          if (typeof Buffer == "function") return Buffer.from(n, "base64");
          if (typeof atob == "function") {
            let r = atob(n.replace(/[\n\r]/g, "")), s = new Uint8Array(r.length);
            for (let i = 0; i < r.length; ++i) s[i] = r.charCodeAt(i);
            return s;
          } else {
            let r = "This environment does not support reading binary tags; either Buffer or atob is required";
            return t.errors.push(new Q.YAMLReferenceError(e, r)), null;
          }
        }, options: O.binaryOptions, stringify: ({ comment: t, type: e, value: n }, r, s, i) => {
          let o;
          if (typeof Buffer == "function") o = n instanceof Buffer ? n.toString("base64") : Buffer.from(n.buffer).toString("base64");
          else if (typeof btoa == "function") {
            let a2 = "";
            for (let c = 0; c < n.length; ++c) a2 += String.fromCharCode(n[c]);
            o = btoa(a2);
          } else throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
          if (e || (e = O.binaryOptions.defaultType), e === Q.Type.QUOTE_DOUBLE) n = o;
          else {
            let { lineWidth: a2 } = O.binaryOptions, c = Math.ceil(o.length / a2), l = new Array(c);
            for (let f2 = 0, m = 0; f2 < c; ++f2, m += a2) l[f2] = o.substr(m, a2);
            n = l.join(e === Q.Type.BLOCK_LITERAL ? `
` : " ");
          }
          return O.stringifyString({ comment: t, type: e, value: n }, r, s, i);
        } };
        function Js(t, e) {
          let n = O.resolveSeq(t, e);
          for (let r = 0; r < n.items.length; ++r) {
            let s = n.items[r];
            if (!(s instanceof O.Pair)) {
              if (s instanceof O.YAMLMap) {
                if (s.items.length > 1) {
                  let o = "Each pair must have its own sequence indicator";
                  throw new Q.YAMLSemanticError(e, o);
                }
                let i = s.items[0] || new O.Pair();
                s.commentBefore && (i.commentBefore = i.commentBefore ? `${s.commentBefore}
${i.commentBefore}` : s.commentBefore), s.comment && (i.comment = i.comment ? `${s.comment}
${i.comment}` : s.comment), s = i;
              }
              n.items[r] = s instanceof O.Pair ? s : new O.Pair(s);
            }
          }
          return n;
        }
        function Gs(t, e, n) {
          let r = new O.YAMLSeq(t);
          r.tag = "tag:yaml.org,2002:pairs";
          for (let s of e) {
            let i, o;
            if (Array.isArray(s)) if (s.length === 2) i = s[0], o = s[1];
            else throw new TypeError(`Expected [key, value] tuple: ${s}`);
            else if (s && s instanceof Object) {
              let c = Object.keys(s);
              if (c.length === 1) i = c[0], o = s[i];
              else throw new TypeError(`Expected { key: value } tuple: ${s}`);
            } else i = s;
            let a2 = t.createPair(i, o, n);
            r.items.push(a2);
          }
          return r;
        }
        var sa = { default: false, tag: "tag:yaml.org,2002:pairs", resolve: Js, createNode: Gs }, Ue = class t extends O.YAMLSeq {
          constructor() {
            super(), Q._defineProperty(this, "add", O.YAMLMap.prototype.add.bind(this)), Q._defineProperty(this, "delete", O.YAMLMap.prototype.delete.bind(this)), Q._defineProperty(this, "get", O.YAMLMap.prototype.get.bind(this)), Q._defineProperty(this, "has", O.YAMLMap.prototype.has.bind(this)), Q._defineProperty(this, "set", O.YAMLMap.prototype.set.bind(this)), this.tag = t.tag;
          }
          toJSON(e, n) {
            let r = /* @__PURE__ */ new Map();
            n && n.onCreate && n.onCreate(r);
            for (let s of this.items) {
              let i, o;
              if (s instanceof O.Pair ? (i = O.toJSON(s.key, "", n), o = O.toJSON(s.value, i, n)) : i = O.toJSON(s, "", n), r.has(i)) throw new Error("Ordered maps must not include duplicate keys");
              r.set(i, o);
            }
            return r;
          }
        };
        Q._defineProperty(Ue, "tag", "tag:yaml.org,2002:omap");
        function ia(t, e) {
          let n = Js(t, e), r = [];
          for (let { key: s } of n.items) if (s instanceof O.Scalar) if (r.includes(s.value)) {
            let i = "Ordered maps must not include duplicate keys";
            throw new Q.YAMLSemanticError(e, i);
          } else r.push(s.value);
          return Object.assign(new Ue(), n);
        }
        function oa(t, e, n) {
          let r = Gs(t, e, n), s = new Ue();
          return s.items = r.items, s;
        }
        var aa = { identify: (t) => t instanceof Map, nodeClass: Ue, default: false, tag: "tag:yaml.org,2002:omap", resolve: ia, createNode: oa }, Ke = class t extends O.YAMLMap {
          constructor() {
            super(), this.tag = t.tag;
          }
          add(e) {
            let n = e instanceof O.Pair ? e : new O.Pair(e);
            O.findPair(this.items, n.key) || this.items.push(n);
          }
          get(e, n) {
            let r = O.findPair(this.items, e);
            return !n && r instanceof O.Pair ? r.key instanceof O.Scalar ? r.key.value : r.key : r;
          }
          set(e, n) {
            if (typeof n != "boolean") throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof n}`);
            let r = O.findPair(this.items, e);
            r && !n ? this.items.splice(this.items.indexOf(r), 1) : !r && n && this.items.push(new O.Pair(e));
          }
          toJSON(e, n) {
            return super.toJSON(e, n, Set);
          }
          toString(e, n, r) {
            if (!e) return JSON.stringify(this);
            if (this.hasAllNullValues()) return super.toString(e, n, r);
            throw new Error("Set items must all have null values");
          }
        };
        Q._defineProperty(Ke, "tag", "tag:yaml.org,2002:set");
        function ca(t, e) {
          let n = O.resolveMap(t, e);
          if (!n.hasAllNullValues()) throw new Q.YAMLSemanticError(e, "Set items must all have null values");
          return Object.assign(new Ke(), n);
        }
        function la(t, e, n) {
          let r = new Ke();
          for (let s of e) r.items.push(t.createPair(s, null, n));
          return r;
        }
        var fa = { identify: (t) => t instanceof Set, nodeClass: Ke, default: false, tag: "tag:yaml.org,2002:set", resolve: ca, createNode: la }, Vn = (t, e) => {
          let n = e.split(":").reduce((r, s) => r * 60 + Number(s), 0);
          return t === "-" ? -n : n;
        }, Hs = ({ value: t }) => {
          if (isNaN(t) || !isFinite(t)) return O.stringifyNumber(t);
          let e = "";
          t < 0 && (e = "-", t = Math.abs(t));
          let n = [t % 60];
          return t < 60 ? n.unshift(0) : (t = Math.round((t - n[0]) / 60), n.unshift(t % 60), t >= 60 && (t = Math.round((t - n[0]) / 60), n.unshift(t))), e + n.map((r) => r < 10 ? "0" + String(r) : String(r)).join(":").replace(/000000\d*$/, "");
        }, ua = { identify: (t) => typeof t == "number", default: true, tag: "tag:yaml.org,2002:int", format: "TIME", test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/, resolve: (t, e, n) => Vn(e, n.replace(/_/g, "")), stringify: Hs }, pa = { identify: (t) => typeof t == "number", default: true, tag: "tag:yaml.org,2002:float", format: "TIME", test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/, resolve: (t, e, n) => Vn(e, n.replace(/_/g, "")), stringify: Hs }, ma = { identify: (t) => t instanceof Date, default: true, tag: "tag:yaml.org,2002:timestamp", test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"), resolve: (t, e, n, r, s, i, o, a2, c) => {
          a2 && (a2 = (a2 + "00").substr(1, 3));
          let l = Date.UTC(e, n - 1, r, s || 0, i || 0, o || 0, a2 || 0);
          if (c && c !== "Z") {
            let f2 = Vn(c[0], c.slice(1));
            Math.abs(f2) < 30 && (f2 *= 60), l -= 6e4 * f2;
          }
          return new Date(l);
        }, stringify: ({ value: t }) => t.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "") };
        function Wn(t) {
          let e = {};
          return t ? typeof YAML_SILENCE_DEPRECATION_WARNINGS < "u" ? !YAML_SILENCE_DEPRECATION_WARNINGS : !e.YAML_SILENCE_DEPRECATION_WARNINGS : typeof YAML_SILENCE_WARNINGS < "u" ? !YAML_SILENCE_WARNINGS : !e.YAML_SILENCE_WARNINGS;
        }
        function jn(t, e) {
          Wn(false) && console.warn(e ? `${e}: ${t}` : t);
        }
        function ha(t) {
          if (Wn(true)) {
            let e = t.replace(/.*yaml[/\\]/i, "").replace(/\.js$/, "").replace(/\\/g, "/");
            jn(`The endpoint 'yaml/${e}' will be removed in a future release.`, "DeprecationWarning");
          }
        }
        var Qs = {};
        function ga(t, e) {
          if (!Qs[t] && Wn(true)) {
            Qs[t] = true;
            let n = `The option '${t}' will be removed in a future release`;
            n += e ? `, use '${e}' instead.` : ".", jn(n, "DeprecationWarning");
          }
        }
        z.binary = ra;
        z.floatTime = pa;
        z.intTime = ua;
        z.omap = aa;
        z.pairs = sa;
        z.set = fa;
        z.timestamp = ma;
        z.warn = jn;
        z.warnFileDeprecation = ha;
        z.warnOptionDeprecation = ga;
      });
      var Xn = te((li) => {
        "use strict";
        var Gt = le(), E = qe(), D = Qn();
        function da(t, e, n) {
          let r = new E.YAMLMap(t);
          if (e instanceof Map) for (let [s, i] of e) r.items.push(t.createPair(s, i, n));
          else if (e && typeof e == "object") for (let s of Object.keys(e)) r.items.push(t.createPair(s, e[s], n));
          return typeof t.sortMapEntries == "function" && r.items.sort(t.sortMapEntries), r;
        }
        var gt = { createNode: da, default: true, nodeClass: E.YAMLMap, tag: "tag:yaml.org,2002:map", resolve: E.resolveMap };
        function ya(t, e, n) {
          let r = new E.YAMLSeq(t);
          if (e && e[Symbol.iterator]) for (let s of e) {
            let i = t.createNode(s, n.wrapScalars, null, n);
            r.items.push(i);
          }
          return r;
        }
        var Ht = { createNode: ya, default: true, nodeClass: E.YAMLSeq, tag: "tag:yaml.org,2002:seq", resolve: E.resolveSeq }, Ea = { identify: (t) => typeof t == "string", default: true, tag: "tag:yaml.org,2002:str", resolve: E.resolveString, stringify(t, e, n, r) {
          return e = Object.assign({ actualString: true }, e), E.stringifyString(t, e, n, r);
        }, options: E.strOptions }, Gn = [gt, Ht, Ea], Xt = (t) => typeof t == "bigint" || Number.isInteger(t), Hn = (t, e, n) => E.intOptions.asBigInt ? BigInt(t) : parseInt(e, n);
        function Zs(t, e, n) {
          let { value: r } = t;
          return Xt(r) && r >= 0 ? n + r.toString(e) : E.stringifyNumber(t);
        }
        var ei = { identify: (t) => t == null, createNode: (t, e, n) => n.wrapScalars ? new E.Scalar(null) : null, default: true, tag: "tag:yaml.org,2002:null", test: /^(?:~|[Nn]ull|NULL)?$/, resolve: () => null, options: E.nullOptions, stringify: () => E.nullOptions.nullStr }, ti = { identify: (t) => typeof t == "boolean", default: true, tag: "tag:yaml.org,2002:bool", test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/, resolve: (t) => t[0] === "t" || t[0] === "T", options: E.boolOptions, stringify: ({ value: t }) => t ? E.boolOptions.trueStr : E.boolOptions.falseStr }, ni = { identify: (t) => Xt(t) && t >= 0, default: true, tag: "tag:yaml.org,2002:int", format: "OCT", test: /^0o([0-7]+)$/, resolve: (t, e) => Hn(t, e, 8), options: E.intOptions, stringify: (t) => Zs(t, 8, "0o") }, ri = { identify: Xt, default: true, tag: "tag:yaml.org,2002:int", test: /^[-+]?[0-9]+$/, resolve: (t) => Hn(t, t, 10), options: E.intOptions, stringify: E.stringifyNumber }, si = { identify: (t) => Xt(t) && t >= 0, default: true, tag: "tag:yaml.org,2002:int", format: "HEX", test: /^0x([0-9a-fA-F]+)$/, resolve: (t, e) => Hn(t, e, 16), options: E.intOptions, stringify: (t) => Zs(t, 16, "0x") }, ii = { identify: (t) => typeof t == "number", default: true, tag: "tag:yaml.org,2002:float", test: /^(?:[-+]?\.inf|(\.nan))$/i, resolve: (t, e) => e ? NaN : t[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, stringify: E.stringifyNumber }, oi = { identify: (t) => typeof t == "number", default: true, tag: "tag:yaml.org,2002:float", format: "EXP", test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/, resolve: (t) => parseFloat(t), stringify: ({ value: t }) => Number(t).toExponential() }, ai = { identify: (t) => typeof t == "number", default: true, tag: "tag:yaml.org,2002:float", test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/, resolve(t, e, n) {
          let r = e || n, s = new E.Scalar(parseFloat(t));
          return r && r[r.length - 1] === "0" && (s.minFractionDigits = r.length), s;
        }, stringify: E.stringifyNumber }, Sa = Gn.concat([ei, ti, ni, ri, si, ii, oi, ai]), Xs = (t) => typeof t == "bigint" || Number.isInteger(t), Qt = ({ value: t }) => JSON.stringify(t), ci = [gt, Ht, { identify: (t) => typeof t == "string", default: true, tag: "tag:yaml.org,2002:str", resolve: E.resolveString, stringify: Qt }, { identify: (t) => t == null, createNode: (t, e, n) => n.wrapScalars ? new E.Scalar(null) : null, default: true, tag: "tag:yaml.org,2002:null", test: /^null$/, resolve: () => null, stringify: Qt }, { identify: (t) => typeof t == "boolean", default: true, tag: "tag:yaml.org,2002:bool", test: /^true|false$/, resolve: (t) => t === "true", stringify: Qt }, { identify: Xs, default: true, tag: "tag:yaml.org,2002:int", test: /^-?(?:0|[1-9][0-9]*)$/, resolve: (t) => E.intOptions.asBigInt ? BigInt(t) : parseInt(t, 10), stringify: ({ value: t }) => Xs(t) ? t.toString() : JSON.stringify(t) }, { identify: (t) => typeof t == "number", default: true, tag: "tag:yaml.org,2002:float", test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/, resolve: (t) => parseFloat(t), stringify: Qt }];
        ci.scalarFallback = (t) => {
          throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(t)}`);
        };
        var zs = ({ value: t }) => t ? E.boolOptions.trueStr : E.boolOptions.falseStr, ht = (t) => typeof t == "bigint" || Number.isInteger(t);
        function Jt(t, e, n) {
          let r = e.replace(/_/g, "");
          if (E.intOptions.asBigInt) {
            switch (n) {
              case 2:
                r = `0b${r}`;
                break;
              case 8:
                r = `0o${r}`;
                break;
              case 16:
                r = `0x${r}`;
                break;
            }
            let i = BigInt(r);
            return t === "-" ? BigInt(-1) * i : i;
          }
          let s = parseInt(r, n);
          return t === "-" ? -1 * s : s;
        }
        function Jn(t, e, n) {
          let { value: r } = t;
          if (ht(r)) {
            let s = r.toString(e);
            return r < 0 ? "-" + n + s.substr(1) : n + s;
          }
          return E.stringifyNumber(t);
        }
        var wa = Gn.concat([{ identify: (t) => t == null, createNode: (t, e, n) => n.wrapScalars ? new E.Scalar(null) : null, default: true, tag: "tag:yaml.org,2002:null", test: /^(?:~|[Nn]ull|NULL)?$/, resolve: () => null, options: E.nullOptions, stringify: () => E.nullOptions.nullStr }, { identify: (t) => typeof t == "boolean", default: true, tag: "tag:yaml.org,2002:bool", test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/, resolve: () => true, options: E.boolOptions, stringify: zs }, { identify: (t) => typeof t == "boolean", default: true, tag: "tag:yaml.org,2002:bool", test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i, resolve: () => false, options: E.boolOptions, stringify: zs }, { identify: ht, default: true, tag: "tag:yaml.org,2002:int", format: "BIN", test: /^([-+]?)0b([0-1_]+)$/, resolve: (t, e, n) => Jt(e, n, 2), stringify: (t) => Jn(t, 2, "0b") }, { identify: ht, default: true, tag: "tag:yaml.org,2002:int", format: "OCT", test: /^([-+]?)0([0-7_]+)$/, resolve: (t, e, n) => Jt(e, n, 8), stringify: (t) => Jn(t, 8, "0") }, { identify: ht, default: true, tag: "tag:yaml.org,2002:int", test: /^([-+]?)([0-9][0-9_]*)$/, resolve: (t, e, n) => Jt(e, n, 10), stringify: E.stringifyNumber }, { identify: ht, default: true, tag: "tag:yaml.org,2002:int", format: "HEX", test: /^([-+]?)0x([0-9a-fA-F_]+)$/, resolve: (t, e, n) => Jt(e, n, 16), stringify: (t) => Jn(t, 16, "0x") }, { identify: (t) => typeof t == "number", default: true, tag: "tag:yaml.org,2002:float", test: /^(?:[-+]?\.inf|(\.nan))$/i, resolve: (t, e) => e ? NaN : t[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, stringify: E.stringifyNumber }, { identify: (t) => typeof t == "number", default: true, tag: "tag:yaml.org,2002:float", format: "EXP", test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/, resolve: (t) => parseFloat(t.replace(/_/g, "")), stringify: ({ value: t }) => Number(t).toExponential() }, { identify: (t) => typeof t == "number", default: true, tag: "tag:yaml.org,2002:float", test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/, resolve(t, e) {
          let n = new E.Scalar(parseFloat(t.replace(/_/g, "")));
          if (e) {
            let r = e.replace(/_/g, "");
            r[r.length - 1] === "0" && (n.minFractionDigits = r.length);
          }
          return n;
        }, stringify: E.stringifyNumber }], D.binary, D.omap, D.pairs, D.set, D.intTime, D.floatTime, D.timestamp), ba = { core: Sa, failsafe: Gn, json: ci, yaml11: wa }, Na = { binary: D.binary, bool: ti, float: ai, floatExp: oi, floatNaN: ii, floatTime: D.floatTime, int: ri, intHex: si, intOct: ni, intTime: D.intTime, map: gt, null: ei, omap: D.omap, pairs: D.pairs, seq: Ht, set: D.set, timestamp: D.timestamp };
        function Oa(t, e, n) {
          if (e) {
            let r = n.filter((i) => i.tag === e), s = r.find((i) => !i.format) || r[0];
            if (!s) throw new Error(`Tag ${e} not found`);
            return s;
          }
          return n.find((r) => (r.identify && r.identify(t) || r.class && t instanceof r.class) && !r.format);
        }
        function La(t, e, n) {
          if (t instanceof E.Node) return t;
          let { defaultPrefix: r, onTagObj: s, prevObjects: i, schema: o, wrapScalars: a2 } = n;
          e && e.startsWith("!!") && (e = r + e.slice(2));
          let c = Oa(t, e, o.tags);
          if (!c) {
            if (typeof t.toJSON == "function" && (t = t.toJSON()), !t || typeof t != "object") return a2 ? new E.Scalar(t) : t;
            c = t instanceof Map ? gt : t[Symbol.iterator] ? Ht : gt;
          }
          s && (s(c), delete n.onTagObj);
          let l = { value: void 0, node: void 0 };
          if (t && typeof t == "object" && i) {
            let f2 = i.get(t);
            if (f2) {
              let m = new E.Alias(f2);
              return n.aliasNodes.push(m), m;
            }
            l.value = t, i.set(t, l);
          }
          return l.node = c.createNode ? c.createNode(n.schema, t, n) : a2 ? new E.Scalar(t) : t, e && l.node instanceof E.Node && (l.node.tag = e), l.node;
        }
        function Aa(t, e, n, r) {
          let s = t[r.replace(/\W/g, "")];
          if (!s) {
            let i = Object.keys(t).map((o) => JSON.stringify(o)).join(", ");
            throw new Error(`Unknown schema "${r}"; use one of ${i}`);
          }
          if (Array.isArray(n)) for (let i of n) s = s.concat(i);
          else typeof n == "function" && (s = n(s.slice()));
          for (let i = 0; i < s.length; ++i) {
            let o = s[i];
            if (typeof o == "string") {
              let a2 = e[o];
              if (!a2) {
                let c = Object.keys(e).map((l) => JSON.stringify(l)).join(", ");
                throw new Error(`Unknown custom tag "${o}"; use one of ${c}`);
              }
              s[i] = a2;
            }
          }
          return s;
        }
        var Ta = (t, e) => t.key < e.key ? -1 : t.key > e.key ? 1 : 0, dt = class t {
          constructor({ customTags: e, merge: n, schema: r, sortMapEntries: s, tags: i }) {
            this.merge = !!n, this.name = r, this.sortMapEntries = s === true ? Ta : s || null, !e && i && D.warnOptionDeprecation("tags", "customTags"), this.tags = Aa(ba, Na, e || i, r);
          }
          createNode(e, n, r, s) {
            let i = { defaultPrefix: t.defaultPrefix, schema: this, wrapScalars: n }, o = s ? Object.assign(s, i) : i;
            return La(e, r, o);
          }
          createPair(e, n, r) {
            r || (r = { wrapScalars: true });
            let s = this.createNode(e, r.wrapScalars, null, r), i = this.createNode(n, r.wrapScalars, null, r);
            return new E.Pair(s, i);
          }
        };
        Gt._defineProperty(dt, "defaultPrefix", Gt.defaultTagPrefix);
        Gt._defineProperty(dt, "defaultTags", Gt.defaultTags);
        li.Schema = dt;
      });
      var mi = te((tn) => {
        "use strict";
        var Y = le(), S = qe(), fi = Xn(), Ca = { anchorPrefix: "a", customTags: null, indent: 2, indentSeq: true, keepCstNodes: false, keepNodeTypes: true, keepBlobsInJSON: true, mapAsMap: false, maxAliasCount: 100, prettyErrors: false, simpleKeys: false, version: "1.2" }, Ma = { get binary() {
          return S.binaryOptions;
        }, set binary(t) {
          Object.assign(S.binaryOptions, t);
        }, get bool() {
          return S.boolOptions;
        }, set bool(t) {
          Object.assign(S.boolOptions, t);
        }, get int() {
          return S.intOptions;
        }, set int(t) {
          Object.assign(S.intOptions, t);
        }, get null() {
          return S.nullOptions;
        }, set null(t) {
          Object.assign(S.nullOptions, t);
        }, get str() {
          return S.strOptions;
        }, set str(t) {
          Object.assign(S.strOptions, t);
        } }, pi = { "1.0": { schema: "yaml-1.1", merge: true, tagPrefixes: [{ handle: "!", prefix: Y.defaultTagPrefix }, { handle: "!!", prefix: "tag:private.yaml.org,2002:" }] }, 1.1: { schema: "yaml-1.1", merge: true, tagPrefixes: [{ handle: "!", prefix: "!" }, { handle: "!!", prefix: Y.defaultTagPrefix }] }, 1.2: { schema: "core", merge: false, tagPrefixes: [{ handle: "!", prefix: "!" }, { handle: "!!", prefix: Y.defaultTagPrefix }] } };
        function ui(t, e) {
          if ((t.version || t.options.version) === "1.0") {
            let s = e.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
            if (s) return "!" + s[1];
            let i = e.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
            return i ? `!${i[1]}/${i[2]}` : `!${e.replace(/^tag:/, "")}`;
          }
          let n = t.tagPrefixes.find((s) => e.indexOf(s.prefix) === 0);
          if (!n) {
            let s = t.getDefaults().tagPrefixes;
            n = s && s.find((i) => e.indexOf(i.prefix) === 0);
          }
          if (!n) return e[0] === "!" ? e : `!<${e}>`;
          let r = e.substr(n.prefix.length).replace(/[!,[\]{}]/g, (s) => ({ "!": "%21", ",": "%2C", "[": "%5B", "]": "%5D", "{": "%7B", "}": "%7D" })[s]);
          return n.handle + r;
        }
        function ka(t, e) {
          if (e instanceof S.Alias) return S.Alias;
          if (e.tag) {
            let s = t.filter((i) => i.tag === e.tag);
            if (s.length > 0) return s.find((i) => i.format === e.format) || s[0];
          }
          let n, r;
          if (e instanceof S.Scalar) {
            r = e.value;
            let s = t.filter((i) => i.identify && i.identify(r) || i.class && r instanceof i.class);
            n = s.find((i) => i.format === e.format) || s.find((i) => !i.format);
          } else r = e, n = t.find((s) => s.nodeClass && r instanceof s.nodeClass);
          if (!n) {
            let s = r && r.constructor ? r.constructor.name : typeof r;
            throw new Error(`Tag not resolved for ${s} value`);
          }
          return n;
        }
        function va(t, e, { anchors: n, doc: r }) {
          let s = [], i = r.anchors.getName(t);
          return i && (n[i] = t, s.push(`&${i}`)), t.tag ? s.push(ui(r, t.tag)) : e.default || s.push(ui(r, e.tag)), s.join(" ");
        }
        function zt(t, e, n, r) {
          let { anchors: s, schema: i } = e.doc, o;
          if (!(t instanceof S.Node)) {
            let l = { aliasNodes: [], onTagObj: (f2) => o = f2, prevObjects: /* @__PURE__ */ new Map() };
            t = i.createNode(t, true, null, l);
            for (let f2 of l.aliasNodes) {
              f2.source = f2.source.node;
              let m = s.getName(f2.source);
              m || (m = s.newName(), s.map[m] = f2.source);
            }
          }
          if (t instanceof S.Pair) return t.toString(e, n, r);
          o || (o = ka(i.tags, t));
          let a2 = va(t, o, e);
          a2.length > 0 && (e.indentAtStart = (e.indentAtStart || 0) + a2.length + 1);
          let c = typeof o.stringify == "function" ? o.stringify(t, e, n, r) : t instanceof S.Scalar ? S.stringifyString(t, e, n, r) : t.toString(e, n, r);
          return a2 ? t instanceof S.Scalar || c[0] === "{" || c[0] === "[" ? `${a2} ${c}` : `${a2}
${e.indent}${c}` : c;
        }
        var zn = class t {
          static validAnchorNode(e) {
            return e instanceof S.Scalar || e instanceof S.YAMLSeq || e instanceof S.YAMLMap;
          }
          constructor(e) {
            Y._defineProperty(this, "map", /* @__PURE__ */ Object.create(null)), this.prefix = e;
          }
          createAlias(e, n) {
            return this.setAnchor(e, n), new S.Alias(e);
          }
          createMergePair(...e) {
            let n = new S.Merge();
            return n.value.items = e.map((r) => {
              if (r instanceof S.Alias) {
                if (r.source instanceof S.YAMLMap) return r;
              } else if (r instanceof S.YAMLMap) return this.createAlias(r);
              throw new Error("Merge sources must be Map nodes or their Aliases");
            }), n;
          }
          getName(e) {
            let { map: n } = this;
            return Object.keys(n).find((r) => n[r] === e);
          }
          getNames() {
            return Object.keys(this.map);
          }
          getNode(e) {
            return this.map[e];
          }
          newName(e) {
            e || (e = this.prefix);
            let n = Object.keys(this.map);
            for (let r = 1; ; ++r) {
              let s = `${e}${r}`;
              if (!n.includes(s)) return s;
            }
          }
          resolveNodes() {
            let { map: e, _cstAliases: n } = this;
            Object.keys(e).forEach((r) => {
              e[r] = e[r].resolved;
            }), n.forEach((r) => {
              r.source = r.source.resolved;
            }), delete this._cstAliases;
          }
          setAnchor(e, n) {
            if (e != null && !t.validAnchorNode(e)) throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");
            if (n && /[\x00-\x19\s,[\]{}]/.test(n)) throw new Error("Anchor names must not contain whitespace or control characters");
            let { map: r } = this, s = e && Object.keys(r).find((i) => r[i] === e);
            if (s) if (n) s !== n && (delete r[s], r[n] = e);
            else return s;
            else {
              if (!n) {
                if (!e) return null;
                n = this.newName();
              }
              r[n] = e;
            }
            return n;
          }
        }, Zt = (t, e) => {
          if (t && typeof t == "object") {
            let { tag: n } = t;
            t instanceof S.Collection ? (n && (e[n] = true), t.items.forEach((r) => Zt(r, e))) : t instanceof S.Pair ? (Zt(t.key, e), Zt(t.value, e)) : t instanceof S.Scalar && n && (e[n] = true);
          }
          return e;
        }, Ia = (t) => Object.keys(Zt(t, {}));
        function Pa(t, e) {
          let n = { before: [], after: [] }, r, s = false;
          for (let i of e) if (i.valueRange) {
            if (r !== void 0) {
              let a2 = "Document contains trailing content not separated by a ... or --- line";
              t.errors.push(new Y.YAMLSyntaxError(i, a2));
              break;
            }
            let o = S.resolveNode(t, i);
            s && (o.spaceBefore = true, s = false), r = o;
          } else i.comment !== null ? (r === void 0 ? n.before : n.after).push(i.comment) : i.type === Y.Type.BLANK_LINE && (s = true, r === void 0 && n.before.length > 0 && !t.commentBefore && (t.commentBefore = n.before.join(`
`), n.before = []));
          if (t.contents = r || null, !r) t.comment = n.before.concat(n.after).join(`
`) || null;
          else {
            let i = n.before.join(`
`);
            if (i) {
              let o = r instanceof S.Collection && r.items[0] ? r.items[0] : r;
              o.commentBefore = o.commentBefore ? `${i}
${o.commentBefore}` : i;
            }
            t.comment = n.after.join(`
`) || null;
          }
        }
        function _a4({ tagPrefixes: t }, e) {
          let [n, r] = e.parameters;
          if (!n || !r) {
            let s = "Insufficient parameters given for %TAG directive";
            throw new Y.YAMLSemanticError(e, s);
          }
          if (t.some((s) => s.handle === n)) {
            let s = "The %TAG directive must only be given at most once per handle in the same document.";
            throw new Y.YAMLSemanticError(e, s);
          }
          return { handle: n, prefix: r };
        }
        function xa(t, e) {
          let [n] = e.parameters;
          if (e.name === "YAML:1.0" && (n = "1.0"), !n) {
            let r = "Insufficient parameters given for %YAML directive";
            throw new Y.YAMLSemanticError(e, r);
          }
          if (!pi[n]) {
            let s = `Document will be parsed as YAML ${t.version || t.options.version} rather than YAML ${n}`;
            t.warnings.push(new Y.YAMLWarning(e, s));
          }
          return n;
        }
        function Ra(t, e, n) {
          let r = [], s = false;
          for (let i of e) {
            let { comment: o, name: a2 } = i;
            switch (a2) {
              case "TAG":
                try {
                  t.tagPrefixes.push(_a4(t, i));
                } catch (c) {
                  t.errors.push(c);
                }
                s = true;
                break;
              case "YAML":
              case "YAML:1.0":
                if (t.version) {
                  let c = "The %YAML directive must only be given at most once per document.";
                  t.errors.push(new Y.YAMLSemanticError(i, c));
                }
                try {
                  t.version = xa(t, i);
                } catch (c) {
                  t.errors.push(c);
                }
                s = true;
                break;
              default:
                if (a2) {
                  let c = `YAML only supports %TAG and %YAML directives, and not %${a2}`;
                  t.warnings.push(new Y.YAMLWarning(i, c));
                }
            }
            o && r.push(o);
          }
          if (n && !s && (t.version || n.version || t.options.version) === "1.1") {
            let i = ({ handle: o, prefix: a2 }) => ({ handle: o, prefix: a2 });
            t.tagPrefixes = n.tagPrefixes.map(i), t.version = n.version;
          }
          t.commentBefore = r.join(`
`) || null;
        }
        function Ve(t) {
          if (t instanceof S.Collection) return true;
          throw new Error("Expected a YAML collection as document contents");
        }
        var en = class t {
          constructor(e) {
            this.anchors = new zn(e.anchorPrefix), this.commentBefore = null, this.comment = null, this.contents = null, this.directivesEndMarker = null, this.errors = [], this.options = e, this.schema = null, this.tagPrefixes = [], this.version = null, this.warnings = [];
          }
          add(e) {
            return Ve(this.contents), this.contents.add(e);
          }
          addIn(e, n) {
            Ve(this.contents), this.contents.addIn(e, n);
          }
          delete(e) {
            return Ve(this.contents), this.contents.delete(e);
          }
          deleteIn(e) {
            return S.isEmptyPath(e) ? this.contents == null ? false : (this.contents = null, true) : (Ve(this.contents), this.contents.deleteIn(e));
          }
          getDefaults() {
            return t.defaults[this.version] || t.defaults[this.options.version] || {};
          }
          get(e, n) {
            return this.contents instanceof S.Collection ? this.contents.get(e, n) : void 0;
          }
          getIn(e, n) {
            return S.isEmptyPath(e) ? !n && this.contents instanceof S.Scalar ? this.contents.value : this.contents : this.contents instanceof S.Collection ? this.contents.getIn(e, n) : void 0;
          }
          has(e) {
            return this.contents instanceof S.Collection ? this.contents.has(e) : false;
          }
          hasIn(e) {
            return S.isEmptyPath(e) ? this.contents !== void 0 : this.contents instanceof S.Collection ? this.contents.hasIn(e) : false;
          }
          set(e, n) {
            Ve(this.contents), this.contents.set(e, n);
          }
          setIn(e, n) {
            S.isEmptyPath(e) ? this.contents = n : (Ve(this.contents), this.contents.setIn(e, n));
          }
          setSchema(e, n) {
            if (!e && !n && this.schema) return;
            typeof e == "number" && (e = e.toFixed(1)), e === "1.0" || e === "1.1" || e === "1.2" ? (this.version ? this.version = e : this.options.version = e, delete this.options.schema) : e && typeof e == "string" && (this.options.schema = e), Array.isArray(n) && (this.options.customTags = n);
            let r = Object.assign({}, this.getDefaults(), this.options);
            this.schema = new fi.Schema(r);
          }
          parse(e, n) {
            this.options.keepCstNodes && (this.cstNode = e), this.options.keepNodeTypes && (this.type = "DOCUMENT");
            let { directives: r = [], contents: s = [], directivesEndMarker: i, error: o, valueRange: a2 } = e;
            if (o && (o.source || (o.source = this), this.errors.push(o)), Ra(this, r, n), i && (this.directivesEndMarker = true), this.range = a2 ? [a2.start, a2.end] : null, this.setSchema(), this.anchors._cstAliases = [], Pa(this, s), this.anchors.resolveNodes(), this.options.prettyErrors) {
              for (let c of this.errors) c instanceof Y.YAMLError && c.makePretty();
              for (let c of this.warnings) c instanceof Y.YAMLError && c.makePretty();
            }
            return this;
          }
          listNonDefaultTags() {
            return Ia(this.contents).filter((e) => e.indexOf(fi.Schema.defaultPrefix) !== 0);
          }
          setTagPrefix(e, n) {
            if (e[0] !== "!" || e[e.length - 1] !== "!") throw new Error("Handle must start and end with !");
            if (n) {
              let r = this.tagPrefixes.find((s) => s.handle === e);
              r ? r.prefix = n : this.tagPrefixes.push({ handle: e, prefix: n });
            } else this.tagPrefixes = this.tagPrefixes.filter((r) => r.handle !== e);
          }
          toJSON(e, n) {
            let { keepBlobsInJSON: r, mapAsMap: s, maxAliasCount: i } = this.options, o = r && (typeof e != "string" || !(this.contents instanceof S.Scalar)), a2 = { doc: this, indentStep: "  ", keep: o, mapAsMap: o && !!s, maxAliasCount: i, stringify: zt }, c = Object.keys(this.anchors.map);
            c.length > 0 && (a2.anchors = new Map(c.map((f2) => [this.anchors.map[f2], { alias: [], aliasCount: 0, count: 1 }])));
            let l = S.toJSON(this.contents, e, a2);
            if (typeof n == "function" && a2.anchors) for (let { count: f2, res: m } of a2.anchors.values()) n(m, f2);
            return l;
          }
          toString() {
            if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified");
            let e = this.options.indent;
            if (!Number.isInteger(e) || e <= 0) {
              let c = JSON.stringify(e);
              throw new Error(`"indent" option must be a positive integer, not ${c}`);
            }
            this.setSchema();
            let n = [], r = false;
            if (this.version) {
              let c = "%YAML 1.2";
              this.schema.name === "yaml-1.1" && (this.version === "1.0" ? c = "%YAML:1.0" : this.version === "1.1" && (c = "%YAML 1.1")), n.push(c), r = true;
            }
            let s = this.listNonDefaultTags();
            this.tagPrefixes.forEach(({ handle: c, prefix: l }) => {
              s.some((f2) => f2.indexOf(l) === 0) && (n.push(`%TAG ${c} ${l}`), r = true);
            }), (r || this.directivesEndMarker) && n.push("---"), this.commentBefore && ((r || !this.directivesEndMarker) && n.unshift(""), n.unshift(this.commentBefore.replace(/^/gm, "#")));
            let i = { anchors: /* @__PURE__ */ Object.create(null), doc: this, indent: "", indentStep: " ".repeat(e), stringify: zt }, o = false, a2 = null;
            if (this.contents) {
              this.contents instanceof S.Node && (this.contents.spaceBefore && (r || this.directivesEndMarker) && n.push(""), this.contents.commentBefore && n.push(this.contents.commentBefore.replace(/^/gm, "#")), i.forceBlockIndent = !!this.comment, a2 = this.contents.comment);
              let c = a2 ? null : () => o = true, l = zt(this.contents, i, () => a2 = null, c);
              n.push(S.addComment(l, "", a2));
            } else this.contents !== void 0 && n.push(zt(this.contents, i));
            return this.comment && ((!o || a2) && n[n.length - 1] !== "" && n.push(""), n.push(this.comment.replace(/^/gm, "#"))), n.join(`
`) + `
`;
          }
        };
        Y._defineProperty(en, "defaults", pi);
        tn.Document = en;
        tn.defaultOptions = Ca;
        tn.scalarOptions = Ma;
      });
      var di = te((gi) => {
        "use strict";
        var Zn = Rs(), Oe = mi(), Da = Xn(), Ya = le(), $a = Qn();
        qe();
        function Ba(t, e = true, n) {
          n === void 0 && typeof e == "string" && (n = e, e = true);
          let r = Object.assign({}, Oe.Document.defaults[Oe.defaultOptions.version], Oe.defaultOptions);
          return new Da.Schema(r).createNode(t, e, n);
        }
        var We = class extends Oe.Document {
          constructor(e) {
            super(Object.assign({}, Oe.defaultOptions, e));
          }
        };
        function Fa(t, e) {
          let n = [], r;
          for (let s of Zn.parse(t)) {
            let i = new We(e);
            i.parse(s, r), n.push(i), r = i;
          }
          return n;
        }
        function hi(t, e) {
          let n = Zn.parse(t), r = new We(e).parse(n[0]);
          if (n.length > 1) {
            let s = "Source contains multiple documents; please use YAML.parseAllDocuments()";
            r.errors.unshift(new Ya.YAMLSemanticError(n[1], s));
          }
          return r;
        }
        function qa(t, e) {
          let n = hi(t, e);
          if (n.warnings.forEach((r) => $a.warn(r)), n.errors.length > 0) throw n.errors[0];
          return n.toJSON();
        }
        function Ua(t, e) {
          let n = new We(e);
          return n.contents = t, String(n);
        }
        var Ka = { createNode: Ba, defaultOptions: Oe.defaultOptions, Document: We, parse: qa, parseAllDocuments: Fa, parseCST: Zn.parse, parseDocument: hi, scalarOptions: Oe.scalarOptions, stringify: Ua };
        gi.YAML = Ka;
      });
      var Ei = te((Um, yi) => {
        yi.exports = di().YAML;
      });
      var Si = te((J) => {
        "use strict";
        var je = qe(), Qe = le();
        J.findPair = je.findPair;
        J.parseMap = je.resolveMap;
        J.parseSeq = je.resolveSeq;
        J.stringifyNumber = je.stringifyNumber;
        J.stringifyString = je.stringifyString;
        J.toJSON = je.toJSON;
        J.Type = Qe.Type;
        J.YAMLError = Qe.YAMLError;
        J.YAMLReferenceError = Qe.YAMLReferenceError;
        J.YAMLSemanticError = Qe.YAMLSemanticError;
        J.YAMLSyntaxError = Qe.YAMLSyntaxError;
        J.YAMLWarning = Qe.YAMLWarning;
      });
      var Xa = {};
      nr(Xa, { languages: () => _r, options: () => xr, parsers: () => tr, printers: () => Ha });
      var Pi = (t, e, n, r) => {
        if (!(t && e == null)) return e.replaceAll ? e.replaceAll(n, r) : n.global ? e.replace(n, r) : e.split(n).join(r);
      }, Et = Pi;
      var Le = "string", Je = "array", Ge = "cursor", He = "indent", Ae = "align", Xe = "trim", Te = "group", Ce = "fill", he = "if-break", ze = "indent-if-break", Me = "line-suffix", Ze = "line-suffix-boundary", Z = "line", et = "label", ke = "break-parent", St = /* @__PURE__ */ new Set([Ge, He, Ae, Xe, Te, Ce, he, ze, Me, Ze, Z, et, ke]);
      var _i = (t, e, n) => {
        if (!(t && e == null)) return Array.isArray(e) || typeof e == "string" ? e[n < 0 ? e.length + n : n] : e.at(n);
      }, x = _i;
      function xi(t) {
        if (typeof t == "string") return Le;
        if (Array.isArray(t)) return Je;
        if (!t) return;
        let { type: e } = t;
        if (St.has(e)) return e;
      }
      var ve = xi;
      var Ri = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
      function Di(t) {
        let e = t === null ? "null" : typeof t;
        if (e !== "string" && e !== "object") return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
        if (ve(t)) throw new Error("doc is valid.");
        let n = Object.prototype.toString.call(t);
        if (n !== "[object Object]") return `Unexpected doc '${n}'.`;
        let r = Ri([...St].map((s) => `'${s}'`));
        return `Unexpected doc.type '${t.type}'.
Expected it to be ${r}.`;
      }
      var nn = class extends Error {
        name = "InvalidDocError";
        constructor(e) {
          super(Di(e)), this.doc = e;
        }
      }, rn = nn;
      function $i(t, e) {
        if (typeof t == "string") return e(t);
        let n = /* @__PURE__ */ new Map();
        return r(t);
        function r(i) {
          if (n.has(i)) return n.get(i);
          let o = s(i);
          return n.set(i, o), o;
        }
        function s(i) {
          switch (ve(i)) {
            case Je:
              return e(i.map(r));
            case Ce:
              return e({ ...i, parts: i.parts.map(r) });
            case he:
              return e({ ...i, breakContents: r(i.breakContents), flatContents: r(i.flatContents) });
            case Te: {
              let { expandedStates: o, contents: a2 } = i;
              return o ? (o = o.map(r), a2 = o[0]) : a2 = r(a2), e({ ...i, contents: a2, expandedStates: o });
            }
            case Ae:
            case He:
            case ze:
            case et:
            case Me:
              return e({ ...i, contents: r(i.contents) });
            case Le:
            case Ge:
            case Xe:
            case Ze:
            case Z:
            case ke:
              return e(i);
            default:
              throw new rn(i);
          }
        }
      }
      function ir(t, e = tt) {
        return $i(t, (n) => typeof n == "string" ? v(e, n.split(`
`)) : n);
      }
      var sn = () => {
      }, ge = sn, on = sn, or = sn;
      function nt(t, e) {
        return ge(e), { type: Ae, contents: e, n: t };
      }
      function Ie(t, e = {}) {
        return ge(t), on(e.expandedStates, true), { type: Te, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
      }
      function an(t) {
        return nt(Number.NEGATIVE_INFINITY, t);
      }
      function ar(t) {
        return nt({ type: "root" }, t);
      }
      function cr(t) {
        return nt(-1, t);
      }
      function cn(t, e) {
        return Ie(t[0], { ...e, expandedStates: t });
      }
      function wt(t) {
        return or(t), { type: Ce, parts: t };
      }
      function rt(t, e = "", n = {}) {
        return ge(t), e !== "" && ge(e), { type: he, breakContents: t, flatContents: e, groupId: n.groupId };
      }
      function lr(t) {
        return ge(t), { type: Me, contents: t };
      }
      var bt = { type: ke };
      var Bi = { type: Z, hard: true }, Fi = { type: Z, hard: true, literal: true }, ne = { type: Z }, Nt = { type: Z, soft: true }, N = [Bi, bt], tt = [Fi, bt];
      function v(t, e) {
        ge(t), on(e);
        let n = [];
        for (let r = 0; r < e.length; r++) r !== 0 && n.push(t), n.push(e[r]);
        return n;
      }
      function Ot(t) {
        return (e, n, r) => {
          let s = !!(r != null && r.backwards);
          if (n === false) return false;
          let { length: i } = e, o = n;
          for (; o >= 0 && o < i; ) {
            let a2 = e.charAt(o);
            if (t instanceof RegExp) {
              if (!t.test(a2)) return o;
            } else if (!t.includes(a2)) return o;
            s ? o-- : o++;
          }
          return o === -1 || o === i ? o : false;
        };
      }
      var kc = Ot(/\s/u), ln = Ot(" 	"), vc = Ot(",; 	"), Ic = Ot(/[^\n\r]/u);
      function qi(t, e, n) {
        let r = !!(n != null && n.backwards);
        if (e === false) return false;
        let s = t.charAt(e);
        if (r) {
          if (t.charAt(e - 1) === "\r" && s === `
`) return e - 2;
          if (s === `
` || s === "\r" || s === "\u2028" || s === "\u2029") return e - 1;
        } else {
          if (s === "\r" && t.charAt(e + 1) === `
`) return e + 2;
          if (s === `
` || s === "\r" || s === "\u2028" || s === "\u2029") return e + 1;
        }
        return e;
      }
      var fn = qi;
      function Ui(t, e) {
        let n = e - 1;
        n = ln(t, n, { backwards: true }), n = fn(t, n, { backwards: true }), n = ln(t, n, { backwards: true });
        let r = fn(t, n, { backwards: true });
        return n !== r;
      }
      var fr = Ui;
      var un = class extends Error {
        name = "UnexpectedNodeError";
        constructor(e, n, r = "type") {
          super(`Unexpected ${n} node ${r}: ${JSON.stringify(e[r])}.`), this.node = e;
        }
      }, ur = un;
      function pr(t, e) {
        let { node: n } = t;
        if (n.type === "root" && e.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/u.test(e.filepath)) return async (r) => {
          let s = await r(e.originalText, { parser: "json" });
          return s ? [s, N] : void 0;
        };
      }
      pr.getVisitorKeys = () => [];
      var mr = pr;
      var st = null;
      function it(t) {
        if (st !== null && typeof st.property) {
          let e = st;
          return st = it.prototype = null, e;
        }
        return st = it.prototype = t ?? /* @__PURE__ */ Object.create(null), new it();
      }
      var Ki = 10;
      for (let t = 0; t <= Ki; t++) it();
      function pn(t) {
        return it(t);
      }
      function Vi(t, e = "type") {
        pn(t);
        function n(r) {
          let s = r[e], i = t[s];
          if (!Array.isArray(i)) throw Object.assign(new Error(`Missing visitor keys for '${s}'.`), { node: r });
          return i;
        }
        return n;
      }
      var hr = Vi;
      var Wi = Object.fromEntries(Object.entries({ root: ["children"], document: ["head", "body", "children"], documentHead: ["children"], documentBody: ["children"], directive: [], alias: [], blockLiteral: [], blockFolded: ["children"], plain: ["children"], quoteSingle: [], quoteDouble: [], mapping: ["children"], mappingItem: ["key", "value", "children"], mappingKey: ["content", "children"], mappingValue: ["content", "children"], sequence: ["children"], sequenceItem: ["content", "children"], flowMapping: ["children"], flowMappingItem: ["key", "value", "children"], flowSequence: ["children"], flowSequenceItem: ["content", "children"], comment: [], tag: [], anchor: [] }).map(([t, e]) => [t, [...e, "anchor", "tag", "indicatorComment", "leadingComments", "middleComments", "trailingComment", "endComments"]])), gr = Wi;
      var ji = hr(gr), dr = ji;
      function Pe(t) {
        return t.position.start.offset;
      }
      function yr(t) {
        return t.position.end.offset;
      }
      function Er(t) {
        return /^\s*@(?:prettier|format)\s*$/u.test(t);
      }
      function Sr(t) {
        return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/u.test(t);
      }
      function wr(t) {
        return `# @format

${t}`;
      }
      function Qi(t) {
        return Array.isArray(t) && t.length > 0;
      }
      var _e = Qi;
      function H(t, e) {
        return typeof (t == null ? void 0 : t.type) == "string" && (!e || e.includes(t.type));
      }
      function mn(t, e, n) {
        return e("children" in t ? { ...t, children: t.children.map((r) => mn(r, e, t)) } : t, n);
      }
      function xe(t, e, n) {
        Object.defineProperty(t, e, { get: n, enumerable: false });
      }
      function Nr(t, e) {
        let n = 0, r = e.length;
        for (let s = t.position.end.offset - 1; s < r; s++) {
          let i = e[s];
          if (i === `
` && n++, n === 1 && /\S/u.test(i)) return false;
          if (n === 2) return true;
        }
        return false;
      }
      function Lt(t) {
        let { node: e } = t;
        switch (e.type) {
          case "tag":
          case "anchor":
          case "comment":
            return false;
        }
        let n = t.stack.length;
        for (let r = 1; r < n; r++) {
          let s = t.stack[r], i = t.stack[r - 1];
          if (Array.isArray(i) && typeof s == "number" && s !== i.length - 1) return false;
        }
        return true;
      }
      function At(t) {
        return _e(t.children) ? At(x(false, t.children, -1)) : t;
      }
      function br(t) {
        return t.value.trim() === "prettier-ignore";
      }
      function Or(t) {
        let { node: e } = t;
        if (e.type === "documentBody") {
          let n = t.parent.head;
          return R(n) && br(x(false, n.endComments, -1));
        }
        return ee(e) && br(x(false, e.leadingComments, -1));
      }
      function Re(t) {
        return !_e(t.children) && !Ji(t);
      }
      function Ji(t) {
        return ee(t) || ie(t) || hn(t) || K(t) || R(t);
      }
      function ee(t) {
        return _e(t == null ? void 0 : t.leadingComments);
      }
      function ie(t) {
        return _e(t == null ? void 0 : t.middleComments);
      }
      function hn(t) {
        return t == null ? void 0 : t.indicatorComment;
      }
      function K(t) {
        return t == null ? void 0 : t.trailingComment;
      }
      function R(t) {
        return _e(t == null ? void 0 : t.endComments);
      }
      function Lr(t) {
        let e = [], n;
        for (let r of t.split(/( +)/u)) r !== " " ? n === " " ? e.push(r) : e.push((e.pop() || "") + r) : n === void 0 && e.unshift(""), n = r;
        return n === " " && e.push((e.pop() || "") + " "), e[0] === "" && (e.shift(), e.unshift(" " + (e.shift() || ""))), e;
      }
      function Ar(t, e, n) {
        let r = e.split(`
`).map((s, i, o) => i === 0 && i === o.length - 1 ? s : i !== 0 && i !== o.length - 1 ? s.trim() : i === 0 ? s.trimEnd() : s.trimStart());
        return n.proseWrap === "preserve" ? r.map((s) => s.length === 0 ? [] : [s]) : r.map((s) => s.length === 0 ? [] : Lr(s)).reduce((s, i, o) => o !== 0 && r[o - 1].length > 0 && i.length > 0 && !(t === "quoteDouble" && x(false, x(false, s, -1), -1).endsWith("\\")) ? [...s.slice(0, -1), [...x(false, s, -1), ...i]] : [...s, i], []).map((s) => n.proseWrap === "never" ? [s.join(" ")] : s);
      }
      function Tr(t, { parentIndent: e, isLastDescendant: n, options: r }) {
        let s = t.position.start.line === t.position.end.line ? "" : r.originalText.slice(t.position.start.offset, t.position.end.offset).match(/^[^\n]*\n(.*)$/su)[1], i;
        if (t.indent === null) {
          let c = s.match(/^(?<leadingSpace> *)[^\n\r ]/mu);
          i = c ? c.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
        } else i = t.indent - 1 + e;
        let o = s.split(`
`).map((c) => c.slice(i));
        if (r.proseWrap === "preserve" || t.type === "blockLiteral") return a2(o.map((c) => c.length === 0 ? [] : [c]));
        return a2(o.map((c) => c.length === 0 ? [] : Lr(c)).reduce((c, l, f2) => f2 !== 0 && o[f2 - 1].length > 0 && l.length > 0 && !/^\s/u.test(l[0]) && !/^\s|\s$/u.test(x(false, c, -1)) ? [...c.slice(0, -1), [...x(false, c, -1), ...l]] : [...c, l], []).map((c) => c.reduce((l, f2) => l.length > 0 && /\s$/u.test(x(false, l, -1)) ? [...l.slice(0, -1), x(false, l, -1) + " " + f2] : [...l, f2], [])).map((c) => r.proseWrap === "never" ? [c.join(" ")] : c));
        function a2(c) {
          if (t.chomping === "keep") return x(false, c, -1).length === 0 ? c.slice(0, -1) : c;
          let l = 0;
          for (let f2 = c.length - 1; f2 >= 0 && c[f2].length === 0; f2--) l++;
          return l === 0 ? c : l >= 2 && !n ? c.slice(0, -(l - 1)) : c.slice(0, -l);
        }
      }
      function ot(t) {
        if (!t) return true;
        switch (t.type) {
          case "plain":
          case "quoteDouble":
          case "quoteSingle":
          case "alias":
          case "flowMapping":
          case "flowSequence":
            return true;
          default:
            return false;
        }
      }
      var gn = /* @__PURE__ */ new WeakMap();
      function Tt(t, e) {
        let { node: n, root: r } = t, s;
        return gn.has(r) ? s = gn.get(r) : (s = /* @__PURE__ */ new Set(), gn.set(r, s)), !s.has(n.position.end.line) && (s.add(n.position.end.line), Nr(n, e) && !dn(t.parent)) ? Nt : "";
      }
      function dn(t) {
        return R(t) && !H(t, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
      }
      function I(t, e) {
        return nt(" ".repeat(t), e);
      }
      function Gi(t, e, n) {
        let { node: r } = t, s = t.ancestors.filter((l) => l.type === "sequence" || l.type === "mapping").length, i = Lt(t), o = [r.type === "blockFolded" ? ">" : "|"];
        r.indent !== null && o.push(r.indent.toString()), r.chomping !== "clip" && o.push(r.chomping === "keep" ? "+" : "-"), hn(r) && o.push(" ", e("indicatorComment"));
        let a2 = Tr(r, { parentIndent: s, isLastDescendant: i, options: n }), c = [];
        for (let [l, f2] of a2.entries()) l === 0 && c.push(N), c.push(wt(v(ne, f2))), l !== a2.length - 1 ? c.push(f2.length === 0 ? N : ar(tt)) : r.chomping === "keep" && i && c.push(an(f2.length === 0 ? N : tt));
        return r.indent === null ? o.push(cr(I(n.tabWidth, c))) : o.push(an(I(r.indent - 1 + s, c))), o;
      }
      var Cr = Gi;
      function Ct(t, e, n) {
        let { node: r } = t, s = r.type === "flowMapping", i = s ? "{" : "[", o = s ? "}" : "]", a2 = Nt;
        s && r.children.length > 0 && n.bracketSpacing && (a2 = ne);
        let c = x(false, r.children, -1), l = (c == null ? void 0 : c.type) === "flowMappingItem" && Re(c.key) && Re(c.value);
        return [i, I(n.tabWidth, [a2, Hi(t, e, n), n.trailingComma === "none" ? "" : rt(","), R(r) ? [N, v(N, t.map(e, "endComments"))] : ""]), l ? "" : a2, o];
      }
      function Hi(t, e, n) {
        return t.map(({ isLast: r, node: s, next: i }) => [e(), r ? "" : [",", ne, s.position.start.line !== i.position.start.line ? Tt(t, n.originalText) : ""]], "children");
      }
      function Xi(t, e, n) {
        var C;
        let { node: r, parent: s } = t, { key: i, value: o } = r, a2 = Re(i), c = Re(o);
        if (a2 && c) return ": ";
        let l = e("key"), f2 = zi(r) ? " " : "";
        if (c) return r.type === "flowMappingItem" && s.type === "flowMapping" ? l : r.type === "mappingItem" && yn(i.content, n) && !K(i.content) && ((C = s.tag) == null ? void 0 : C.value) !== "tag:yaml.org,2002:set" ? [l, f2, ":"] : ["? ", I(2, l)];
        let m = e("value");
        if (a2) return [": ", I(2, m)];
        if (ee(o) || !ot(i.content)) return ["? ", I(2, l), N, ...t.map(() => [e(), N], "value", "leadingComments"), ": ", I(2, m)];
        if (Zi(i.content) && !ee(i.content) && !ie(i.content) && !K(i.content) && !R(i) && !ee(o.content) && !ie(o.content) && !R(o) && yn(o.content, n)) return [l, f2, ": ", m];
        let d = /* @__PURE__ */ Symbol("mappingKey"), y = Ie([rt("? "), Ie(I(2, l), { id: d })]), h = [N, ": ", I(2, m)], g = [f2, ":"];
        ee(o.content) || R(o) && o.content && !H(o.content, ["mapping", "sequence"]) || s.type === "mapping" && K(i.content) && ot(o.content) || H(o.content, ["mapping", "sequence"]) && o.content.tag === null && o.content.anchor === null ? g.push(N) : o.content ? g.push(ne) : K(o) && g.push(" "), g.push(m);
        let w = I(n.tabWidth, g);
        return yn(i.content, n) && !ee(i.content) && !ie(i.content) && !R(i) ? cn([[l, w]]) : cn([[y, rt(h, w, { groupId: d })]]);
      }
      function yn(t, e) {
        if (!t) return true;
        switch (t.type) {
          case "plain":
          case "quoteSingle":
          case "quoteDouble":
            break;
          case "alias":
            return true;
          default:
            return false;
        }
        if (e.proseWrap === "preserve") return t.position.start.line === t.position.end.line;
        if (/\\$/mu.test(e.originalText.slice(t.position.start.offset, t.position.end.offset))) return false;
        switch (e.proseWrap) {
          case "never":
            return !t.value.includes(`
`);
          case "always":
            return !/[\n ]/u.test(t.value);
          default:
            return false;
        }
      }
      function zi(t) {
        var e;
        return ((e = t.key.content) == null ? void 0 : e.type) === "alias";
      }
      function Zi(t) {
        if (!t) return true;
        switch (t.type) {
          case "plain":
          case "quoteDouble":
          case "quoteSingle":
            return t.position.start.line === t.position.end.line;
          case "alias":
            return true;
          default:
            return false;
        }
      }
      var Mr = Xi;
      function eo(t) {
        return mn(t, to);
      }
      function to(t) {
        switch (t.type) {
          case "document":
            xe(t, "head", () => t.children[0]), xe(t, "body", () => t.children[1]);
            break;
          case "documentBody":
          case "sequenceItem":
          case "flowSequenceItem":
          case "mappingKey":
          case "mappingValue":
            xe(t, "content", () => t.children[0]);
            break;
          case "mappingItem":
          case "flowMappingItem":
            xe(t, "key", () => t.children[0]), xe(t, "value", () => t.children[1]);
            break;
        }
        return t;
      }
      var kr = eo;
      function no(t, e, n) {
        let { node: r } = t, s = [];
        r.type !== "mappingValue" && ee(r) && s.push([v(N, t.map(n, "leadingComments")), N]);
        let { tag: i, anchor: o } = r;
        i && s.push(n("tag")), i && o && s.push(" "), o && s.push(n("anchor"));
        let a2 = "";
        return H(r, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !Lt(t) && (a2 = Tt(t, e.originalText)), (i || o) && (H(r, ["sequence", "mapping"]) && !ie(r) ? s.push(N) : s.push(" ")), ie(r) && s.push([r.middleComments.length === 1 ? "" : N, v(N, t.map(n, "middleComments")), N]), Or(t) ? s.push(ir(e.originalText.slice(r.position.start.offset, r.position.end.offset).trimEnd())) : s.push(Ie(ro(t, e, n))), K(r) && !H(r, ["document", "documentHead"]) && s.push(lr([r.type === "mappingValue" && !r.content ? "" : " ", t.parent.type === "mappingKey" && t.getParentNode(2).type === "mapping" && ot(r) ? "" : bt, n("trailingComment")])), dn(r) && s.push(I(r.type === "sequenceItem" ? 2 : 0, [N, v(N, t.map(({ node: c }) => [fr(e.originalText, Pe(c)) ? N : "", n()], "endComments"))])), s.push(a2), s;
      }
      function ro(t, e, n) {
        let { node: r } = t;
        switch (r.type) {
          case "root": {
            let s = [];
            t.each(({ node: o, next: a2, isFirst: c }) => {
              c || s.push(N), s.push(n()), vr(o, a2) ? (s.push(N, "..."), K(o) && s.push(" ", n("trailingComment"))) : a2 && !K(a2.head) && s.push(N, "---");
            }, "children");
            let i = At(r);
            return (!H(i, ["blockLiteral", "blockFolded"]) || i.chomping !== "keep") && s.push(N), s;
          }
          case "document": {
            let s = [];
            return io(t, e) === "head" && ((r.head.children.length > 0 || r.head.endComments.length > 0) && s.push(n("head")), K(r.head) ? s.push(["---", " ", n(["head", "trailingComment"])]) : s.push("---")), so(r) && s.push(n("body")), v(N, s);
          }
          case "documentHead":
            return v(N, [...t.map(n, "children"), ...t.map(n, "endComments")]);
          case "documentBody": {
            let { children: s, endComments: i } = r, o = "";
            if (s.length > 0 && i.length > 0) {
              let a2 = At(r);
              H(a2, ["blockFolded", "blockLiteral"]) ? a2.chomping !== "keep" && (o = [N, N]) : o = N;
            }
            return [v(N, t.map(n, "children")), o, v(N, t.map(n, "endComments"))];
          }
          case "directive":
            return ["%", v(" ", [r.name, ...r.parameters])];
          case "comment":
            return ["#", r.value];
          case "alias":
            return ["*", r.value];
          case "tag":
            return e.originalText.slice(r.position.start.offset, r.position.end.offset);
          case "anchor":
            return ["&", r.value];
          case "plain":
            return at(r.type, e.originalText.slice(r.position.start.offset, r.position.end.offset), e);
          case "quoteDouble":
          case "quoteSingle": {
            let s = "'", i = '"', o = e.originalText.slice(r.position.start.offset + 1, r.position.end.offset - 1);
            if (r.type === "quoteSingle" && o.includes("\\") || r.type === "quoteDouble" && /\\[^"]/u.test(o)) {
              let c = r.type === "quoteDouble" ? i : s;
              return [c, at(r.type, o, e), c];
            }
            if (o.includes(i)) return [s, at(r.type, r.type === "quoteDouble" ? Et(false, Et(false, o, String.raw`\"`, i), "'", s.repeat(2)) : o, e), s];
            if (o.includes(s)) return [i, at(r.type, r.type === "quoteSingle" ? Et(false, o, "''", s) : o, e), i];
            let a2 = e.singleQuote ? s : i;
            return [a2, at(r.type, o, e), a2];
          }
          case "blockFolded":
          case "blockLiteral":
            return Cr(t, n, e);
          case "mapping":
          case "sequence":
            return v(N, t.map(n, "children"));
          case "sequenceItem":
            return ["- ", I(2, r.content ? n("content") : "")];
          case "mappingKey":
          case "mappingValue":
            return r.content ? n("content") : "";
          case "mappingItem":
          case "flowMappingItem":
            return Mr(t, n, e);
          case "flowMapping":
            return Ct(t, n, e);
          case "flowSequence":
            return Ct(t, n, e);
          case "flowSequenceItem":
            return n("content");
          default:
            throw new ur(r, "YAML");
        }
      }
      function so(t) {
        return t.body.children.length > 0 || R(t.body);
      }
      function vr(t, e) {
        return K(t) || e && (e.head.children.length > 0 || R(e.head));
      }
      function io(t, e) {
        let n = t.node;
        if (t.isFirst && /---(?:\s|$)/u.test(e.originalText.slice(Pe(n), Pe(n) + 4)) || n.head.children.length > 0 || R(n.head) || K(n.head)) return "head";
        let r = t.next;
        return vr(n, r) ? false : r ? "root" : false;
      }
      function at(t, e, n) {
        let r = Ar(t, e, n);
        return v(N, r.map((s) => wt(v(ne, s))));
      }
      function Ir(t, e) {
        if (H(t)) switch (t.type) {
          case "comment":
            if (Er(t.value)) return null;
            break;
          case "quoteDouble":
          case "quoteSingle":
            e.type = "quote";
            break;
        }
      }
      Ir.ignoredProperties = /* @__PURE__ */ new Set(["position"]);
      var oo = { preprocess: kr, embed: mr, print: no, massageAstNode: Ir, insertPragma: wr, getVisitorKeys: dr }, Pr = oo;
      var _r = [{ linguistLanguageId: 407, name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", ".prettierrc", ".stylelintrc", ".lintstagedrc"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "dockercompose", "github-actions-workflow", "home-assistant"] }];
      var Mt = { bracketSpacing: { category: "Common", type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, objectWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap object literals.", choices: [{ value: "preserve", description: "Keep as multi-line, if there is a newline between the opening brace and first property." }, { value: "collapse", description: "Fit to a single line when possible." }] }, singleQuote: { category: "Common", type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
      var ao = { bracketSpacing: Mt.bracketSpacing, singleQuote: Mt.singleQuote, proseWrap: Mt.proseWrap }, xr = ao;
      var tr = {};
      nr(tr, { yaml: () => Ga });
      var kt = `
`, Rr = "\r", Dr = (function() {
        function t(e) {
          this.length = e.length;
          for (var n = [0], r = 0; r < e.length; ) switch (e[r]) {
            case kt:
              r += kt.length, n.push(r);
              break;
            case Rr:
              r += Rr.length, e[r] === kt && (r += kt.length), n.push(r);
              break;
            default:
              r++;
              break;
          }
          this.offsets = n;
        }
        return t.prototype.locationForIndex = function(e) {
          if (e < 0 || e > this.length) return null;
          for (var n = 0, r = this.offsets; r[n + 1] <= e; ) n++;
          var s = e - r[n];
          return { line: n, column: s };
        }, t.prototype.indexForLocation = function(e) {
          var n = e.line, r = e.column;
          return n < 0 || n >= this.offsets.length || r < 0 || r > this.lengthOfLine(n) ? null : this.offsets[n] + r;
        }, t.prototype.lengthOfLine = function(e) {
          var n = this.offsets[e], r = e === this.offsets.length - 1 ? this.length : this.offsets[e + 1];
          return r - n;
        }, t;
      })();
      function $(t, e = null) {
        "children" in t && t.children.forEach((n) => $(n, t)), "anchor" in t && t.anchor && $(t.anchor, t), "tag" in t && t.tag && $(t.tag, t), "leadingComments" in t && t.leadingComments.forEach((n) => $(n, t)), "middleComments" in t && t.middleComments.forEach((n) => $(n, t)), "indicatorComment" in t && t.indicatorComment && $(t.indicatorComment, t), "trailingComment" in t && t.trailingComment && $(t.trailingComment, t), "endComments" in t && t.endComments.forEach((n) => $(n, t)), Object.defineProperty(t, "_parent", { value: e, enumerable: false });
      }
      function de(t) {
        return `${t.line}:${t.column}`;
      }
      function Yr(t) {
        $(t);
        let e = co(t), n = t.children.slice();
        t.comments.sort((r, s) => r.position.start.offset - s.position.end.offset).filter((r) => !r._parent).forEach((r) => {
          for (; n.length > 1 && r.position.start.line > n[0].position.end.line; ) n.shift();
          lo(r, e, n[0]);
        });
      }
      function co(t) {
        let e = Array.from(new Array(t.position.end.line), () => ({}));
        for (let n of t.comments) e[n.position.start.line - 1].comment = n;
        return $r(e, t), e;
      }
      function $r(t, e) {
        if (e.position.start.offset !== e.position.end.offset) {
          if ("leadingComments" in e) {
            let { start: n } = e.position, { leadingAttachableNode: r } = t[n.line - 1];
            (!r || n.column < r.position.start.column) && (t[n.line - 1].leadingAttachableNode = e);
          }
          if ("trailingComment" in e && e.position.end.column > 1 && e.type !== "document" && e.type !== "documentHead") {
            let { end: n } = e.position, { trailingAttachableNode: r } = t[n.line - 1];
            (!r || n.column >= r.position.end.column) && (t[n.line - 1].trailingAttachableNode = e);
          }
          if (e.type !== "root" && e.type !== "document" && e.type !== "documentHead" && e.type !== "documentBody") {
            let { start: n, end: r } = e.position, s = [r.line].concat(n.line === r.line ? [] : n.line);
            for (let i of s) {
              let o = t[i - 1].trailingNode;
              (!o || r.column >= o.position.end.column) && (t[i - 1].trailingNode = e);
            }
          }
          "children" in e && e.children.forEach((n) => {
            $r(t, n);
          });
        }
      }
      function lo(t, e, n) {
        let r = t.position.start.line, { trailingAttachableNode: s } = e[r - 1];
        if (s) {
          if (s.trailingComment) throw new Error(`Unexpected multiple trailing comment at ${de(t.position.start)}`);
          $(t, s), s.trailingComment = t;
          return;
        }
        for (let o = r; o >= n.position.start.line; o--) {
          let { trailingNode: a2 } = e[o - 1], c;
          if (a2) c = a2;
          else if (o !== r && e[o - 1].comment) c = e[o - 1].comment._parent;
          else continue;
          if ((c.type === "sequence" || c.type === "mapping") && (c = c.children[0]), c.type === "mappingItem") {
            let [l, f2] = c.children;
            c = Br(l) ? l : f2;
          }
          for (; ; ) {
            if (fo(c, t)) {
              $(t, c), c.endComments.push(t);
              return;
            }
            if (!c._parent) break;
            c = c._parent;
          }
          break;
        }
        for (let o = r + 1; o <= n.position.end.line; o++) {
          let { leadingAttachableNode: a2 } = e[o - 1];
          if (a2) {
            $(t, a2), a2.leadingComments.push(t);
            return;
          }
        }
        let i = n.children[1];
        $(t, i), i.endComments.push(t);
      }
      function fo(t, e) {
        if (t.position.start.offset < e.position.start.offset && t.position.end.offset > e.position.end.offset) switch (t.type) {
          case "flowMapping":
          case "flowSequence":
            return t.children.length === 0 || e.position.start.line > t.children[t.children.length - 1].position.end.line;
        }
        if (e.position.end.offset < t.position.end.offset) return false;
        switch (t.type) {
          case "sequenceItem":
            return e.position.start.column > t.position.start.column;
          case "mappingKey":
          case "mappingValue":
            return e.position.start.column > t._parent.position.start.column && (t.children.length === 0 || t.children.length === 1 && t.children[0].type !== "blockFolded" && t.children[0].type !== "blockLiteral") && (t.type === "mappingValue" || Br(t));
          default:
            return false;
        }
      }
      function Br(t) {
        return t.position.start !== t.position.end && (t.children.length === 0 || t.position.start.offset !== t.children[0].position.start.offset);
      }
      function b(t, e) {
        return { type: t, position: e };
      }
      function Fr(t, e, n) {
        return { ...b("root", t), children: e, comments: n };
      }
      function ct(t) {
        switch (t.type) {
          case "DOCUMENT":
            for (let e = t.contents.length - 1; e >= 0; e--) t.contents[e].type === "BLANK_LINE" ? t.contents.splice(e, 1) : ct(t.contents[e]);
            for (let e = t.directives.length - 1; e >= 0; e--) t.directives[e].type === "BLANK_LINE" && t.directives.splice(e, 1);
            break;
          case "FLOW_MAP":
          case "FLOW_SEQ":
          case "MAP":
          case "SEQ":
            for (let e = t.items.length - 1; e >= 0; e--) {
              let n = t.items[e];
              "char" in n || (n.type === "BLANK_LINE" ? t.items.splice(e, 1) : ct(n));
            }
            break;
          case "MAP_KEY":
          case "MAP_VALUE":
          case "SEQ_ITEM":
            t.node && ct(t.node);
            break;
          case "ALIAS":
          case "BLANK_LINE":
          case "BLOCK_FOLDED":
          case "BLOCK_LITERAL":
          case "COMMENT":
          case "DIRECTIVE":
          case "PLAIN":
          case "QUOTE_DOUBLE":
          case "QUOTE_SINGLE":
            break;
          default:
            throw new Error(`Unexpected node type ${JSON.stringify(t.type)}`);
        }
      }
      function X() {
        return { leadingComments: [] };
      }
      function oe(t = null) {
        return { trailingComment: t };
      }
      function B() {
        return { ...X(), ...oe() };
      }
      function qr(t, e, n) {
        return { ...b("alias", t), ...B(), ...e, value: n };
      }
      function Ur(t, e) {
        let n = t.cstNode;
        return qr(e.transformRange({ origStart: n.valueRange.origStart - 1, origEnd: n.valueRange.origEnd }), e.transformContent(t), n.rawValue);
      }
      function Kr(t) {
        return { ...t, type: "blockFolded" };
      }
      function Vr(t, e, n, r, s, i) {
        return { ...b("blockValue", t), ...X(), ...e, chomping: n, indent: r, value: s, indicatorComment: i };
      }
      var ae;
      (function(t) {
        t.Tag = "!", t.Anchor = "&", t.Comment = "#";
      })(ae || (ae = {}));
      function Wr(t, e) {
        return { ...b("anchor", t), value: e };
      }
      function De(t, e) {
        return { ...b("comment", t), value: e };
      }
      function jr(t, e, n) {
        return { anchor: e, tag: t, middleComments: n };
      }
      function Qr(t, e) {
        return { ...b("tag", t), value: e };
      }
      function vt(t, e, n = () => false) {
        let r = t.cstNode, s = [], i = null, o = null, a2 = null;
        for (let c of r.props) {
          let l = e.text[c.origStart];
          switch (l) {
            case ae.Tag:
              i = i || c, o = Qr(e.transformRange(c), t.tag);
              break;
            case ae.Anchor:
              i = i || c, a2 = Wr(e.transformRange(c), r.anchor);
              break;
            case ae.Comment: {
              let f2 = De(e.transformRange(c), e.text.slice(c.origStart + 1, c.origEnd));
              e.comments.push(f2), !n(f2) && i && i.origEnd <= c.origStart && c.origEnd <= r.valueRange.origStart && s.push(f2);
              break;
            }
            default:
              throw new Error(`Unexpected leading character ${JSON.stringify(l)}`);
          }
        }
        return jr(o, a2, s);
      }
      var En;
      (function(t) {
        t.CLIP = "clip", t.STRIP = "strip", t.KEEP = "keep";
      })(En || (En = {}));
      function It(t, e) {
        let n = t.cstNode, r = 1, s = n.chomping === "CLIP" ? 0 : 1, o = n.header.origEnd - n.header.origStart - r - s !== 0, a2 = e.transformRange({ origStart: n.header.origStart, origEnd: n.valueRange.origEnd }), c = null, l = vt(t, e, (f2) => {
          if (!(a2.start.offset < f2.position.start.offset && f2.position.end.offset < a2.end.offset)) return false;
          if (c) throw new Error(`Unexpected multiple indicator comments at ${de(f2.position.start)}`);
          return c = f2, true;
        });
        return Vr(a2, l, En[n.chomping], o ? n.blockIndent : null, n.strValue, c);
      }
      function Jr(t, e) {
        return Kr(It(t, e));
      }
      function Gr(t) {
        return { ...t, type: "blockLiteral" };
      }
      function Hr(t, e) {
        return Gr(It(t, e));
      }
      function Xr(t, e) {
        return De(e.transformRange(t.range), t.comment);
      }
      function zr(t, e, n) {
        return { ...b("directive", t), ...B(), name: e, parameters: n };
      }
      function Ye(t, e) {
        for (let n of t.props) {
          let r = e.text[n.origStart];
          switch (r) {
            case ae.Comment:
              e.comments.push(De(e.transformRange(n), e.text.slice(n.origStart + 1, n.origEnd)));
              break;
            default:
              throw new Error(`Unexpected leading character ${JSON.stringify(r)}`);
          }
        }
      }
      function Zr(t, e) {
        return Ye(t, e), zr(e.transformRange(t.range), t.name, t.parameters);
      }
      function es(t, e, n, r) {
        return { ...b("document", t), ...oe(r), children: [e, n] };
      }
      function V(t, e) {
        return { start: t, end: e };
      }
      function Sn(t) {
        return { start: t, end: t };
      }
      function F(t = []) {
        return { endComments: t };
      }
      function ts(t, e, n) {
        return { ...b("documentBody", t), ...F(n), children: e ? [e] : [] };
      }
      function q(t) {
        return t[t.length - 1];
      }
      function Pt(t, e) {
        let n = t.match(e);
        return n ? n.index : -1;
      }
      function ns(t, e, n) {
        let r = t.cstNode, { comments: s, endComments: i, documentTrailingComment: o, documentHeadTrailingComment: a2 } = uo(r, e, n), c = e.transformNode(t.contents), { position: l, documentEndPoint: f2 } = po(r, c, e);
        return e.comments.push(...s, ...i), { documentBody: ts(l, c, i), documentEndPoint: f2, documentTrailingComment: o, documentHeadTrailingComment: a2 };
      }
      function uo(t, e, n) {
        let r = [], s = [], i = [], o = [], a2 = false;
        for (let c = t.contents.length - 1; c >= 0; c--) {
          let l = t.contents[c];
          if (l.type === "COMMENT") {
            let f2 = e.transformNode(l);
            n && n.line === f2.position.start.line ? o.unshift(f2) : a2 ? r.unshift(f2) : f2.position.start.offset >= t.valueRange.origEnd ? i.unshift(f2) : r.unshift(f2);
          } else a2 = true;
        }
        if (i.length > 1) throw new Error(`Unexpected multiple document trailing comments at ${de(i[1].position.start)}`);
        if (o.length > 1) throw new Error(`Unexpected multiple documentHead trailing comments at ${de(o[1].position.start)}`);
        return { comments: r, endComments: s, documentTrailingComment: q(i) || null, documentHeadTrailingComment: q(o) || null };
      }
      function po(t, e, n) {
        let r = Pt(n.text.slice(t.valueRange.origEnd), /^\.\.\./), s = r === -1 ? t.valueRange.origEnd : Math.max(0, t.valueRange.origEnd - 1);
        n.text[s - 1] === "\r" && s--;
        let i = n.transformRange({ origStart: e !== null ? e.position.start.offset : s, origEnd: s }), o = r === -1 ? i.end : n.transformOffset(t.valueRange.origEnd + 3);
        return { position: i, documentEndPoint: o };
      }
      function rs(t, e, n, r) {
        return { ...b("documentHead", t), ...F(n), ...oe(r), children: e };
      }
      function ss(t, e) {
        let n = t.cstNode, { directives: r, comments: s, endComments: i } = mo(n, e), { position: o, endMarkerPoint: a2 } = ho(n, r, e);
        return e.comments.push(...s, ...i), { createDocumentHeadWithTrailingComment: (l) => (l && e.comments.push(l), rs(o, r, i, l)), documentHeadEndMarkerPoint: a2 };
      }
      function mo(t, e) {
        let n = [], r = [], s = [], i = false;
        for (let o = t.directives.length - 1; o >= 0; o--) {
          let a2 = e.transformNode(t.directives[o]);
          a2.type === "comment" ? i ? r.unshift(a2) : s.unshift(a2) : (i = true, n.unshift(a2));
        }
        return { directives: n, comments: r, endComments: s };
      }
      function ho(t, e, n) {
        let r = Pt(n.text.slice(0, t.valueRange.origStart), /---\s*$/);
        r > 0 && !/[\r\n]/.test(n.text[r - 1]) && (r = -1);
        let s = r === -1 ? { origStart: t.valueRange.origStart, origEnd: t.valueRange.origStart } : { origStart: r, origEnd: r + 3 };
        return e.length !== 0 && (s.origStart = e[0].position.start.offset), { position: n.transformRange(s), endMarkerPoint: r === -1 ? null : n.transformOffset(r) };
      }
      function is(t, e) {
        let { createDocumentHeadWithTrailingComment: n, documentHeadEndMarkerPoint: r } = ss(t, e), { documentBody: s, documentEndPoint: i, documentTrailingComment: o, documentHeadTrailingComment: a2 } = ns(t, e, r), c = n(a2);
        return o && e.comments.push(o), es(V(c.position.start, i), c, s, o);
      }
      function _t(t, e, n) {
        return { ...b("flowCollection", t), ...B(), ...F(), ...e, children: n };
      }
      function os(t, e, n) {
        return { ..._t(t, e, n), type: "flowMapping" };
      }
      function xt(t, e, n) {
        return { ...b("flowMappingItem", t), ...X(), children: [e, n] };
      }
      function ce(t, e) {
        let n = [];
        for (let r of t) r && "type" in r && r.type === "COMMENT" ? e.comments.push(e.transformNode(r)) : n.push(r);
        return n;
      }
      function Rt(t) {
        let [e, n] = ["?", ":"].map((r) => {
          let s = t.find((i) => "char" in i && i.char === r);
          return s ? { origStart: s.origOffset, origEnd: s.origOffset + 1 } : null;
        });
        return { additionalKeyRange: e, additionalValueRange: n };
      }
      function Dt(t, e) {
        let n = e;
        return (r) => t.slice(n, n = r);
      }
      function Yt(t) {
        let e = [], n = Dt(t, 1), r = false;
        for (let s = 1; s < t.length - 1; s++) {
          let i = t[s];
          if ("char" in i && i.char === ",") {
            e.push(n(s)), n(s + 1), r = false;
            continue;
          }
          r = true;
        }
        return r && e.push(n(t.length - 1)), e;
      }
      function wn(t, e) {
        return { ...b("mappingKey", t), ...oe(), ...F(), children: e ? [e] : [] };
      }
      function bn(t, e) {
        return { ...b("mappingValue", t), ...B(), ...F(), children: e ? [e] : [] };
      }
      function $e(t, e, n, r, s) {
        let i = e.transformNode(t.key), o = e.transformNode(t.value), a2 = i || r ? wn(e.transformRange({ origStart: r ? r.origStart : i.position.start.offset, origEnd: i ? i.position.end.offset : r.origStart + 1 }), i) : null, c = o || s ? bn(e.transformRange({ origStart: s ? s.origStart : o.position.start.offset, origEnd: o ? o.position.end.offset : s.origStart + 1 }), o) : null;
        return n(V(a2 ? a2.position.start : c.position.start, c ? c.position.end : a2.position.end), a2 || wn(Sn(c.position.start), null), c || bn(Sn(a2.position.end), null));
      }
      function as(t, e) {
        let n = ce(t.cstNode.items, e), r = Yt(n), s = t.items.map((a2, c) => {
          let l = r[c], { additionalKeyRange: f2, additionalValueRange: m } = Rt(l);
          return $e(a2, e, xt, f2, m);
        }), i = n[0], o = q(n);
        return os(e.transformRange({ origStart: i.origOffset, origEnd: o.origOffset + 1 }), e.transformContent(t), s);
      }
      function cs(t, e, n) {
        return { ..._t(t, e, n), type: "flowSequence" };
      }
      function ls(t, e) {
        return { ...b("flowSequenceItem", t), children: [e] };
      }
      function fs(t, e) {
        let n = ce(t.cstNode.items, e), r = Yt(n), s = t.items.map((a2, c) => {
          if (a2.type !== "PAIR") {
            let l = e.transformNode(a2);
            return ls(V(l.position.start, l.position.end), l);
          } else {
            let l = r[c], { additionalKeyRange: f2, additionalValueRange: m } = Rt(l);
            return $e(a2, e, xt, f2, m);
          }
        }), i = n[0], o = q(n);
        return cs(e.transformRange({ origStart: i.origOffset, origEnd: o.origOffset + 1 }), e.transformContent(t), s);
      }
      function us(t, e, n) {
        return { ...b("mapping", t), ...X(), ...e, children: n };
      }
      function ps(t, e, n) {
        return { ...b("mappingItem", t), ...X(), children: [e, n] };
      }
      function ms(t, e) {
        let n = t.cstNode;
        n.items.filter((o) => o.type === "MAP_KEY" || o.type === "MAP_VALUE").forEach((o) => Ye(o, e));
        let r = ce(n.items, e), s = go(r), i = t.items.map((o, a2) => {
          let c = s[a2], [l, f2] = c[0].type === "MAP_VALUE" ? [null, c[0].range] : [c[0].range, c.length === 1 ? null : c[1].range];
          return $e(o, e, ps, l, f2);
        });
        return us(V(i[0].position.start, q(i).position.end), e.transformContent(t), i);
      }
      function go(t) {
        let e = [], n = Dt(t, 0), r = false;
        for (let s = 0; s < t.length; s++) {
          if (t[s].type === "MAP_VALUE") {
            e.push(n(s + 1)), r = false;
            continue;
          }
          r && e.push(n(s)), r = true;
        }
        return r && e.push(n(1 / 0)), e;
      }
      function hs(t, e, n) {
        return { ...b("plain", t), ...B(), ...e, value: n };
      }
      function gs(t, e, n) {
        for (let r = e; r >= 0; r--) if (n.test(t[r])) return r;
        return -1;
      }
      function ds(t, e) {
        let n = t.cstNode;
        return hs(e.transformRange({ origStart: n.valueRange.origStart, origEnd: gs(e.text, n.valueRange.origEnd - 1, /\S/) + 1 }), e.transformContent(t), n.strValue);
      }
      function ys(t) {
        return { ...t, type: "quoteDouble" };
      }
      function Es(t, e, n) {
        return { ...b("quoteValue", t), ...e, ...B(), value: n };
      }
      function $t(t, e) {
        let n = t.cstNode;
        return Es(e.transformRange(n.valueRange), e.transformContent(t), n.strValue);
      }
      function Ss(t, e) {
        return ys($t(t, e));
      }
      function ws(t) {
        return { ...t, type: "quoteSingle" };
      }
      function bs(t, e) {
        return ws($t(t, e));
      }
      function Ns(t, e, n) {
        return { ...b("sequence", t), ...X(), ...F(), ...e, children: n };
      }
      function Os(t, e) {
        return { ...b("sequenceItem", t), ...B(), ...F(), children: e ? [e] : [] };
      }
      function Ls(t, e) {
        let r = ce(t.cstNode.items, e).map((s, i) => {
          Ye(s, e);
          let o = e.transformNode(t.items[i]);
          return Os(V(e.transformOffset(s.valueRange.origStart), o === null ? e.transformOffset(s.valueRange.origStart + 1) : o.position.end), o);
        });
        return Ns(V(r[0].position.start, q(r).position.end), e.transformContent(t), r);
      }
      function As(t, e) {
        if (t === null || t.type === void 0 && t.value === null) return null;
        switch (t.type) {
          case "ALIAS":
            return Ur(t, e);
          case "BLOCK_FOLDED":
            return Jr(t, e);
          case "BLOCK_LITERAL":
            return Hr(t, e);
          case "COMMENT":
            return Xr(t, e);
          case "DIRECTIVE":
            return Zr(t, e);
          case "DOCUMENT":
            return is(t, e);
          case "FLOW_MAP":
            return as(t, e);
          case "FLOW_SEQ":
            return fs(t, e);
          case "MAP":
            return ms(t, e);
          case "PLAIN":
            return ds(t, e);
          case "QUOTE_DOUBLE":
            return Ss(t, e);
          case "QUOTE_SINGLE":
            return bs(t, e);
          case "SEQ":
            return Ls(t, e);
          default:
            throw new Error(`Unexpected node type ${t.type}`);
        }
      }
      function Ts(t, e, n) {
        let r = new SyntaxError(t);
        return r.name = "YAMLSyntaxError", r.source = e, r.position = n, r;
      }
      function Cs(t, e) {
        let n = t.source.range || t.source.valueRange;
        return Ts(t.message, e.text, e.transformRange(n));
      }
      function Ms(t, e, n) {
        return { offset: t, line: e, column: n };
      }
      function ks(t, e) {
        t < 0 ? t = 0 : t > e.text.length && (t = e.text.length);
        let n = e.locator.locationForIndex(t);
        return Ms(t, n.line + 1, n.column + 1);
      }
      function vs(t, e) {
        return V(e.transformOffset(t.origStart), e.transformOffset(t.origEnd));
      }
      function Is2(t) {
        if (!t.setOrigRanges()) {
          let e = (n) => {
            if (yo(n)) return n.origStart = n.start, n.origEnd = n.end, true;
            if (Eo(n)) return n.origOffset = n.offset, true;
          };
          t.forEach((n) => Nn(n, e));
        }
      }
      function Nn(t, e) {
        if (!(!t || typeof t != "object") && e(t) !== true) for (let n of Object.keys(t)) {
          if (n === "context" || n === "error") continue;
          let r = t[n];
          Array.isArray(r) ? r.forEach((s) => Nn(s, e)) : Nn(r, e);
        }
      }
      function yo(t) {
        return typeof t.start == "number";
      }
      function Eo(t) {
        return typeof t.offset == "number";
      }
      function On(t) {
        if ("children" in t) {
          if (t.children.length === 1) {
            let e = t.children[0];
            if (e.type === "plain" && e.tag === null && e.anchor === null && e.value === "") return t.children.splice(0, 1), t;
          }
          t.children.forEach(On);
        }
        return t;
      }
      function Ln(t, e, n, r) {
        let s = e(t);
        return (i) => {
          r(s, i) && n(t, s = i);
        };
      }
      function An(t) {
        if (t === null || !("children" in t)) return;
        let e = t.children;
        if (e.forEach(An), t.type === "document") {
          let [i, o] = t.children;
          i.position.start.offset === i.position.end.offset ? i.position.start = i.position.end = o.position.start : o.position.start.offset === o.position.end.offset && (o.position.start = o.position.end = i.position.end);
        }
        let n = Ln(t.position, So, wo, Oo), r = Ln(t.position, bo, No, Lo);
        "endComments" in t && t.endComments.length !== 0 && (n(t.endComments[0].position.start), r(q(t.endComments).position.end));
        let s = e.filter((i) => i !== null);
        if (s.length !== 0) {
          let i = s[0], o = q(s);
          n(i.position.start), r(o.position.end), "leadingComments" in i && i.leadingComments.length !== 0 && n(i.leadingComments[0].position.start), "tag" in i && i.tag && n(i.tag.position.start), "anchor" in i && i.anchor && n(i.anchor.position.start), "trailingComment" in o && o.trailingComment && r(o.trailingComment.position.end);
        }
      }
      function So(t) {
        return t.start;
      }
      function wo(t, e) {
        t.start = e;
      }
      function bo(t) {
        return t.end;
      }
      function No(t, e) {
        t.end = e;
      }
      function Oo(t, e) {
        return e.offset < t.offset;
      }
      function Lo(t, e) {
        return e.offset > t.offset;
      }
      var wi = sr(Ei(), 1);
      var G = sr(Si(), 1), Vm = G.default.findPair, Wm = G.default.toJSON, jm = G.default.parseMap, Qm = G.default.parseSeq, Jm = G.default.stringifyNumber, Gm = G.default.stringifyString, Hm = G.default.Type, Va = G.default.YAMLError, Xm = G.default.YAMLReferenceError, er = G.default.YAMLSemanticError, Wa = G.default.YAMLSyntaxError, zm = G.default.YAMLWarning;
      var { Document: bi, parseCST: Ni } = wi.default;
      function Oi(t) {
        let e = Ni(t);
        Is2(e);
        let n = e.map((a2) => new bi({ merge: false, keepCstNodes: true }).parse(a2)), r = new Dr(t), s = [], i = { text: t, locator: r, comments: s, transformOffset: (a2) => ks(a2, i), transformRange: (a2) => vs(a2, i), transformNode: (a2) => As(a2, i), transformContent: (a2) => vt(a2, i) };
        for (let a2 of n) for (let c of a2.errors) if (!(c instanceof er && c.message === 'Map keys must be unique; "<<" is repeated')) throw Cs(c, i);
        n.forEach((a2) => ct(a2.cstNode));
        let o = Fr(i.transformRange({ origStart: 0, origEnd: i.text.length }), n.map(i.transformNode), s);
        return Yr(o), An(o), On(o), o;
      }
      function Qa(t, e) {
        let n = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
        return Object.assign(n, e);
      }
      var Li = Qa;
      function Ja(t) {
        try {
          let e = Oi(t);
          return delete e.comments, e;
        } catch (e) {
          throw e != null && e.position ? Li(e.message, { loc: e.position, cause: e }) : e;
        }
      }
      var Ga = { astFormat: "yaml", parse: Ja, hasPragma: Sr, locStart: Pe, locEnd: yr };
      var Ha = { yaml: Pr };
      return Ii(Xa);
    });
  }
});

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/errors.js
var ErrorHandler = class {
  constructor() {
    this.listeners = [];
    this.unexpectedErrorHandler = function(e) {
      setTimeout(() => {
        if (e.stack) {
          if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {
            throw new ErrorNoTelemetry(e.message + "\n\n" + e.stack);
          }
          throw new Error(e.message + "\n\n" + e.stack);
        }
        throw e;
      }, 0);
    };
  }
  emit(e) {
    this.listeners.forEach((listener) => {
      listener(e);
    });
  }
  onUnexpectedError(e) {
    this.unexpectedErrorHandler(e);
    this.emit(e);
  }
  // For external errors, we don't want the listeners to be called
  onUnexpectedExternalError(e) {
    this.unexpectedErrorHandler(e);
  }
};
var errorHandler = new ErrorHandler();
function onUnexpectedError(e) {
  if (!isCancellationError(e)) {
    errorHandler.onUnexpectedError(e);
  }
  return void 0;
}
function transformErrorForSerialization(error) {
  if (error instanceof Error) {
    const { name, message } = error;
    const stack = error.stacktrace || error.stack;
    return {
      $isError: true,
      name,
      message,
      stack,
      noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)
    };
  }
  return error;
}
var canceledName = "Canceled";
function isCancellationError(error) {
  if (error instanceof CancellationError) {
    return true;
  }
  return error instanceof Error && error.name === canceledName && error.message === canceledName;
}
var CancellationError = class extends Error {
  constructor() {
    super(canceledName);
    this.name = this.message;
  }
};
var ErrorNoTelemetry = class _ErrorNoTelemetry extends Error {
  constructor(msg) {
    super(msg);
    this.name = "CodeExpectedError";
  }
  static fromError(err) {
    if (err instanceof _ErrorNoTelemetry) {
      return err;
    }
    const result = new _ErrorNoTelemetry();
    result.message = err.message;
    result.stack = err.stack;
    return result;
  }
  static isErrorNoTelemetry(err) {
    return err.name === "CodeExpectedError";
  }
};
var BugIndicatingError = class _BugIndicatingError extends Error {
  constructor(message) {
    super(message || "An unexpected bug occurred.");
    Object.setPrototypeOf(this, _BugIndicatingError.prototype);
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/functional.js
function createSingleCallFunction(fn, fnDidRunCallback) {
  const _this = this;
  let didCall = false;
  let result;
  return function() {
    if (didCall) {
      return result;
    }
    didCall = true;
    if (fnDidRunCallback) {
      try {
        result = fn.apply(_this, arguments);
      } finally {
        fnDidRunCallback();
      }
    } else {
      result = fn.apply(_this, arguments);
    }
    return result;
  };
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/iterator.js
var Iterable;
(function(Iterable2) {
  function is(thing) {
    return thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
  }
  Iterable2.is = is;
  const _empty2 = Object.freeze([]);
  function empty() {
    return _empty2;
  }
  Iterable2.empty = empty;
  function* single(element) {
    yield element;
  }
  Iterable2.single = single;
  function wrap(iterableOrElement) {
    if (is(iterableOrElement)) {
      return iterableOrElement;
    } else {
      return single(iterableOrElement);
    }
  }
  Iterable2.wrap = wrap;
  function from(iterable) {
    return iterable || _empty2;
  }
  Iterable2.from = from;
  function* reverse(array) {
    for (let i = array.length - 1; i >= 0; i--) {
      yield array[i];
    }
  }
  Iterable2.reverse = reverse;
  function isEmpty2(iterable) {
    return !iterable || iterable[Symbol.iterator]().next().done === true;
  }
  Iterable2.isEmpty = isEmpty2;
  function first(iterable) {
    return iterable[Symbol.iterator]().next().value;
  }
  Iterable2.first = first;
  function some(iterable, predicate) {
    for (const element of iterable) {
      if (predicate(element)) {
        return true;
      }
    }
    return false;
  }
  Iterable2.some = some;
  function find(iterable, predicate) {
    for (const element of iterable) {
      if (predicate(element)) {
        return element;
      }
    }
    return void 0;
  }
  Iterable2.find = find;
  function* filter(iterable, predicate) {
    for (const element of iterable) {
      if (predicate(element)) {
        yield element;
      }
    }
  }
  Iterable2.filter = filter;
  function* map2(iterable, fn) {
    let index = 0;
    for (const element of iterable) {
      yield fn(element, index++);
    }
  }
  Iterable2.map = map2;
  function* concat(...iterables) {
    for (const iterable of iterables) {
      yield* iterable;
    }
  }
  Iterable2.concat = concat;
  function reduce(iterable, reducer, initialValue) {
    let value = initialValue;
    for (const element of iterable) {
      value = reducer(value, element);
    }
    return value;
  }
  Iterable2.reduce = reduce;
  function* slice(arr, from2, to = arr.length) {
    if (from2 < 0) {
      from2 += arr.length;
    }
    if (to < 0) {
      to += arr.length;
    } else if (to > arr.length) {
      to = arr.length;
    }
    for (; from2 < to; from2++) {
      yield arr[from2];
    }
  }
  Iterable2.slice = slice;
  function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
    const consumed = [];
    if (atMost === 0) {
      return [consumed, iterable];
    }
    const iterator = iterable[Symbol.iterator]();
    for (let i = 0; i < atMost; i++) {
      const next = iterator.next();
      if (next.done) {
        return [consumed, Iterable2.empty()];
      }
      consumed.push(next.value);
    }
    return [consumed, { [Symbol.iterator]() {
      return iterator;
    } }];
  }
  Iterable2.consume = consume;
  async function asyncToArray(iterable) {
    const result = [];
    for await (const item of iterable) {
      result.push(item);
    }
    return Promise.resolve(result);
  }
  Iterable2.asyncToArray = asyncToArray;
})(Iterable || (Iterable = {}));

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js
var TRACK_DISPOSABLES = false;
var disposableTracker = null;
function setDisposableTracker(tracker) {
  disposableTracker = tracker;
}
if (TRACK_DISPOSABLES) {
  const __is_disposable_tracked__ = "__is_disposable_tracked__";
  setDisposableTracker(new class {
    trackDisposable(x) {
      const stack = new Error("Potentially leaked disposable").stack;
      setTimeout(() => {
        if (!x[__is_disposable_tracked__]) {
          console.log(stack);
        }
      }, 3e3);
    }
    setParent(child, parent) {
      if (child && child !== Disposable.None) {
        try {
          child[__is_disposable_tracked__] = true;
        } catch (_a4) {
        }
      }
    }
    markAsDisposed(disposable) {
      if (disposable && disposable !== Disposable.None) {
        try {
          disposable[__is_disposable_tracked__] = true;
        } catch (_a4) {
        }
      }
    }
    markAsSingleton(disposable) {
    }
  }());
}
function trackDisposable(x) {
  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);
  return x;
}
function markAsDisposed(disposable) {
  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);
}
function setParentOfDisposable(child, parent) {
  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);
}
function setParentOfDisposables(children, parent) {
  if (!disposableTracker) {
    return;
  }
  for (const child of children) {
    disposableTracker.setParent(child, parent);
  }
}
function dispose(arg) {
  if (Iterable.is(arg)) {
    const errors = [];
    for (const d of arg) {
      if (d) {
        try {
          d.dispose();
        } catch (e) {
          errors.push(e);
        }
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    } else if (errors.length > 1) {
      throw new AggregateError(errors, "Encountered errors while disposing of store");
    }
    return Array.isArray(arg) ? [] : arg;
  } else if (arg) {
    arg.dispose();
    return arg;
  }
}
function combinedDisposable(...disposables) {
  const parent = toDisposable(() => dispose(disposables));
  setParentOfDisposables(disposables, parent);
  return parent;
}
function toDisposable(fn) {
  const self2 = trackDisposable({
    dispose: createSingleCallFunction(() => {
      markAsDisposed(self2);
      fn();
    })
  });
  return self2;
}
var DisposableStore = class _DisposableStore {
  constructor() {
    this._toDispose = /* @__PURE__ */ new Set();
    this._isDisposed = false;
    trackDisposable(this);
  }
  /**
   * Dispose of all registered disposables and mark this object as disposed.
   *
   * Any future disposables added to this object will be disposed of on `add`.
   */
  dispose() {
    if (this._isDisposed) {
      return;
    }
    markAsDisposed(this);
    this._isDisposed = true;
    this.clear();
  }
  /**
   * @return `true` if this object has been disposed of.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of all registered disposables but do not mark this object as disposed.
   */
  clear() {
    if (this._toDispose.size === 0) {
      return;
    }
    try {
      dispose(this._toDispose);
    } finally {
      this._toDispose.clear();
    }
  }
  /**
   * Add a new {@link IDisposable disposable} to the collection.
   */
  add(o) {
    if (!o) {
      return o;
    }
    if (o === this) {
      throw new Error("Cannot register a disposable on itself!");
    }
    setParentOfDisposable(o, this);
    if (this._isDisposed) {
      if (!_DisposableStore.DISABLE_DISPOSED_WARNING) {
        console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack);
      }
    } else {
      this._toDispose.add(o);
    }
    return o;
  }
  /**
   * Deletes the value from the store, but does not dispose it.
   */
  deleteAndLeak(o) {
    if (!o) {
      return;
    }
    if (this._toDispose.has(o)) {
      this._toDispose.delete(o);
      setParentOfDisposable(o, null);
    }
  }
};
DisposableStore.DISABLE_DISPOSED_WARNING = false;
var Disposable = class {
  constructor() {
    this._store = new DisposableStore();
    trackDisposable(this);
    setParentOfDisposable(this._store, this);
  }
  dispose() {
    markAsDisposed(this);
    this._store.dispose();
  }
  /**
   * Adds `o` to the collection of disposables managed by this object.
   */
  _register(o) {
    if (o === this) {
      throw new Error("Cannot register a disposable on itself!");
    }
    return this._store.add(o);
  }
};
Disposable.None = Object.freeze({ dispose() {
} });

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/linkedList.js
var Node = class _Node {
  constructor(element) {
    this.element = element;
    this.next = _Node.Undefined;
    this.prev = _Node.Undefined;
  }
};
Node.Undefined = new Node(void 0);
var LinkedList = class {
  constructor() {
    this._first = Node.Undefined;
    this._last = Node.Undefined;
    this._size = 0;
  }
  get size() {
    return this._size;
  }
  isEmpty() {
    return this._first === Node.Undefined;
  }
  clear() {
    let node = this._first;
    while (node !== Node.Undefined) {
      const next = node.next;
      node.prev = Node.Undefined;
      node.next = Node.Undefined;
      node = next;
    }
    this._first = Node.Undefined;
    this._last = Node.Undefined;
    this._size = 0;
  }
  unshift(element) {
    return this._insert(element, false);
  }
  push(element) {
    return this._insert(element, true);
  }
  _insert(element, atTheEnd) {
    const newNode = new Node(element);
    if (this._first === Node.Undefined) {
      this._first = newNode;
      this._last = newNode;
    } else if (atTheEnd) {
      const oldLast = this._last;
      this._last = newNode;
      newNode.prev = oldLast;
      oldLast.next = newNode;
    } else {
      const oldFirst = this._first;
      this._first = newNode;
      newNode.next = oldFirst;
      oldFirst.prev = newNode;
    }
    this._size += 1;
    let didRemove = false;
    return () => {
      if (!didRemove) {
        didRemove = true;
        this._remove(newNode);
      }
    };
  }
  shift() {
    if (this._first === Node.Undefined) {
      return void 0;
    } else {
      const res = this._first.element;
      this._remove(this._first);
      return res;
    }
  }
  pop() {
    if (this._last === Node.Undefined) {
      return void 0;
    } else {
      const res = this._last.element;
      this._remove(this._last);
      return res;
    }
  }
  _remove(node) {
    if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
      const anchor = node.prev;
      anchor.next = node.next;
      node.next.prev = anchor;
    } else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
      this._first = Node.Undefined;
      this._last = Node.Undefined;
    } else if (node.next === Node.Undefined) {
      this._last = this._last.prev;
      this._last.next = Node.Undefined;
    } else if (node.prev === Node.Undefined) {
      this._first = this._first.next;
      this._first.prev = Node.Undefined;
    }
    this._size -= 1;
  }
  *[Symbol.iterator]() {
    let node = this._first;
    while (node !== Node.Undefined) {
      yield node.element;
      node = node.next;
    }
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/stopwatch.js
var hasPerformanceNow = globalThis.performance && typeof globalThis.performance.now === "function";
var StopWatch = class _StopWatch {
  static create(highResolution) {
    return new _StopWatch(highResolution);
  }
  constructor(highResolution) {
    this._now = hasPerformanceNow && highResolution === false ? Date.now : globalThis.performance.now.bind(globalThis.performance);
    this._startTime = this._now();
    this._stopTime = -1;
  }
  stop() {
    this._stopTime = this._now();
  }
  elapsed() {
    if (this._stopTime !== -1) {
      return this._stopTime - this._startTime;
    }
    return this._now() - this._startTime;
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/event.js
var _enableDisposeWithListenerWarning = false;
var _enableSnapshotPotentialLeakWarning = false;
var Event;
(function(Event2) {
  Event2.None = () => Disposable.None;
  function _addLeakageTraceLogic(options) {
    if (_enableSnapshotPotentialLeakWarning) {
      const { onDidAddListener: origListenerDidAdd } = options;
      const stack = Stacktrace.create();
      let count = 0;
      options.onDidAddListener = () => {
        if (++count === 2) {
          console.warn("snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here");
          stack.print();
        }
        origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();
      };
    }
  }
  function defer(event, disposable) {
    return debounce(event, () => void 0, 0, void 0, true, void 0, disposable);
  }
  Event2.defer = defer;
  function once2(event) {
    return (listener, thisArgs = null, disposables) => {
      let didFire = false;
      let result = void 0;
      result = event((e) => {
        if (didFire) {
          return;
        } else if (result) {
          result.dispose();
        } else {
          didFire = true;
        }
        return listener.call(thisArgs, e);
      }, null, disposables);
      if (didFire) {
        result.dispose();
      }
      return result;
    };
  }
  Event2.once = once2;
  function map2(event, map3, disposable) {
    return snapshot((listener, thisArgs = null, disposables) => event((i) => listener.call(thisArgs, map3(i)), null, disposables), disposable);
  }
  Event2.map = map2;
  function forEach(event, each, disposable) {
    return snapshot((listener, thisArgs = null, disposables) => event((i) => {
      each(i);
      listener.call(thisArgs, i);
    }, null, disposables), disposable);
  }
  Event2.forEach = forEach;
  function filter(event, filter2, disposable) {
    return snapshot((listener, thisArgs = null, disposables) => event((e) => filter2(e) && listener.call(thisArgs, e), null, disposables), disposable);
  }
  Event2.filter = filter;
  function signal(event) {
    return event;
  }
  Event2.signal = signal;
  function any(...events) {
    return (listener, thisArgs = null, disposables) => {
      const disposable = combinedDisposable(...events.map((event) => event((e) => listener.call(thisArgs, e))));
      return addAndReturnDisposable(disposable, disposables);
    };
  }
  Event2.any = any;
  function reduce(event, merge2, initial, disposable) {
    let output = initial;
    return map2(event, (e) => {
      output = merge2(output, e);
      return output;
    }, disposable);
  }
  Event2.reduce = reduce;
  function snapshot(event, disposable) {
    let listener;
    const options = {
      onWillAddFirstListener() {
        listener = event(emitter.fire, emitter);
      },
      onDidRemoveLastListener() {
        listener === null || listener === void 0 ? void 0 : listener.dispose();
      }
    };
    if (!disposable) {
      _addLeakageTraceLogic(options);
    }
    const emitter = new Emitter(options);
    disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);
    return emitter.event;
  }
  function addAndReturnDisposable(d, store) {
    if (store instanceof Array) {
      store.push(d);
    } else if (store) {
      store.add(d);
    }
    return d;
  }
  function debounce(event, merge2, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {
    let subscription;
    let output = void 0;
    let handle = void 0;
    let numDebouncedCalls = 0;
    let doFire;
    const options = {
      leakWarningThreshold,
      onWillAddFirstListener() {
        subscription = event((cur) => {
          numDebouncedCalls++;
          output = merge2(output, cur);
          if (leading && !handle) {
            emitter.fire(output);
            output = void 0;
          }
          doFire = () => {
            const _output = output;
            output = void 0;
            handle = void 0;
            if (!leading || numDebouncedCalls > 1) {
              emitter.fire(_output);
            }
            numDebouncedCalls = 0;
          };
          if (typeof delay === "number") {
            clearTimeout(handle);
            handle = setTimeout(doFire, delay);
          } else {
            if (handle === void 0) {
              handle = 0;
              queueMicrotask(doFire);
            }
          }
        });
      },
      onWillRemoveListener() {
        if (flushOnListenerRemove && numDebouncedCalls > 0) {
          doFire === null || doFire === void 0 ? void 0 : doFire();
        }
      },
      onDidRemoveLastListener() {
        doFire = void 0;
        subscription.dispose();
      }
    };
    if (!disposable) {
      _addLeakageTraceLogic(options);
    }
    const emitter = new Emitter(options);
    disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);
    return emitter.event;
  }
  Event2.debounce = debounce;
  function accumulate(event, delay = 0, disposable) {
    return Event2.debounce(event, (last, e) => {
      if (!last) {
        return [e];
      }
      last.push(e);
      return last;
    }, delay, void 0, true, void 0, disposable);
  }
  Event2.accumulate = accumulate;
  function latch(event, equals4 = (a2, b) => a2 === b, disposable) {
    let firstCall = true;
    let cache;
    return filter(event, (value) => {
      const shouldEmit = firstCall || !equals4(value, cache);
      firstCall = false;
      cache = value;
      return shouldEmit;
    }, disposable);
  }
  Event2.latch = latch;
  function split(event, isT, disposable) {
    return [
      Event2.filter(event, isT, disposable),
      Event2.filter(event, (e) => !isT(e), disposable)
    ];
  }
  Event2.split = split;
  function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {
    let buffer2 = _buffer.slice();
    let listener = event((e) => {
      if (buffer2) {
        buffer2.push(e);
      } else {
        emitter.fire(e);
      }
    });
    if (disposable) {
      disposable.add(listener);
    }
    const flush = () => {
      buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.forEach((e) => emitter.fire(e));
      buffer2 = null;
    };
    const emitter = new Emitter({
      onWillAddFirstListener() {
        if (!listener) {
          listener = event((e) => emitter.fire(e));
          if (disposable) {
            disposable.add(listener);
          }
        }
      },
      onDidAddFirstListener() {
        if (buffer2) {
          if (flushAfterTimeout) {
            setTimeout(flush);
          } else {
            flush();
          }
        }
      },
      onDidRemoveLastListener() {
        if (listener) {
          listener.dispose();
        }
        listener = null;
      }
    });
    if (disposable) {
      disposable.add(emitter);
    }
    return emitter.event;
  }
  Event2.buffer = buffer;
  function chain(event, sythensize) {
    const fn = (listener, thisArgs, disposables) => {
      const cs = sythensize(new ChainableSynthesis());
      return event(function(value) {
        const result = cs.evaluate(value);
        if (result !== HaltChainable) {
          listener.call(thisArgs, result);
        }
      }, void 0, disposables);
    };
    return fn;
  }
  Event2.chain = chain;
  const HaltChainable = /* @__PURE__ */ Symbol("HaltChainable");
  class ChainableSynthesis {
    constructor() {
      this.steps = [];
    }
    map(fn) {
      this.steps.push(fn);
      return this;
    }
    forEach(fn) {
      this.steps.push((v) => {
        fn(v);
        return v;
      });
      return this;
    }
    filter(fn) {
      this.steps.push((v) => fn(v) ? v : HaltChainable);
      return this;
    }
    reduce(merge2, initial) {
      let last = initial;
      this.steps.push((v) => {
        last = merge2(last, v);
        return last;
      });
      return this;
    }
    latch(equals4 = (a2, b) => a2 === b) {
      let firstCall = true;
      let cache;
      this.steps.push((value) => {
        const shouldEmit = firstCall || !equals4(value, cache);
        firstCall = false;
        cache = value;
        return shouldEmit ? value : HaltChainable;
      });
      return this;
    }
    evaluate(value) {
      for (const step of this.steps) {
        value = step(value);
        if (value === HaltChainable) {
          break;
        }
      }
      return value;
    }
  }
  function fromNodeEventEmitter(emitter, eventName, map3 = (id) => id) {
    const fn = (...args) => result.fire(map3(...args));
    const onFirstListenerAdd = () => emitter.on(eventName, fn);
    const onLastListenerRemove = () => emitter.removeListener(eventName, fn);
    const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
    return result.event;
  }
  Event2.fromNodeEventEmitter = fromNodeEventEmitter;
  function fromDOMEventEmitter(emitter, eventName, map3 = (id) => id) {
    const fn = (...args) => result.fire(map3(...args));
    const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);
    const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);
    const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
    return result.event;
  }
  Event2.fromDOMEventEmitter = fromDOMEventEmitter;
  function toPromise(event) {
    return new Promise((resolve3) => once2(event)(resolve3));
  }
  Event2.toPromise = toPromise;
  function fromPromise(promise) {
    const result = new Emitter();
    promise.then((res) => {
      result.fire(res);
    }, () => {
      result.fire(void 0);
    }).finally(() => {
      result.dispose();
    });
    return result.event;
  }
  Event2.fromPromise = fromPromise;
  function runAndSubscribe(event, handler, initial) {
    handler(initial);
    return event((e) => handler(e));
  }
  Event2.runAndSubscribe = runAndSubscribe;
  class EmitterObserver {
    constructor(_observable, store) {
      this._observable = _observable;
      this._counter = 0;
      this._hasChanged = false;
      const options = {
        onWillAddFirstListener: () => {
          _observable.addObserver(this);
        },
        onDidRemoveLastListener: () => {
          _observable.removeObserver(this);
        }
      };
      if (!store) {
        _addLeakageTraceLogic(options);
      }
      this.emitter = new Emitter(options);
      if (store) {
        store.add(this.emitter);
      }
    }
    beginUpdate(_observable) {
      this._counter++;
    }
    handlePossibleChange(_observable) {
    }
    handleChange(_observable, _change) {
      this._hasChanged = true;
    }
    endUpdate(_observable) {
      this._counter--;
      if (this._counter === 0) {
        this._observable.reportChanges();
        if (this._hasChanged) {
          this._hasChanged = false;
          this.emitter.fire(this._observable.get());
        }
      }
    }
  }
  function fromObservable(obs, store) {
    const observer = new EmitterObserver(obs, store);
    return observer.emitter.event;
  }
  Event2.fromObservable = fromObservable;
  function fromObservableLight(observable) {
    return (listener, thisArgs, disposables) => {
      let count = 0;
      let didChange = false;
      const observer = {
        beginUpdate() {
          count++;
        },
        endUpdate() {
          count--;
          if (count === 0) {
            observable.reportChanges();
            if (didChange) {
              didChange = false;
              listener.call(thisArgs);
            }
          }
        },
        handlePossibleChange() {
        },
        handleChange() {
          didChange = true;
        }
      };
      observable.addObserver(observer);
      observable.reportChanges();
      const disposable = {
        dispose() {
          observable.removeObserver(observer);
        }
      };
      if (disposables instanceof DisposableStore) {
        disposables.add(disposable);
      } else if (Array.isArray(disposables)) {
        disposables.push(disposable);
      }
      return disposable;
    };
  }
  Event2.fromObservableLight = fromObservableLight;
})(Event || (Event = {}));
var EventProfiling = class _EventProfiling {
  constructor(name) {
    this.listenerCount = 0;
    this.invocationCount = 0;
    this.elapsedOverall = 0;
    this.durations = [];
    this.name = `${name}_${_EventProfiling._idPool++}`;
    _EventProfiling.all.add(this);
  }
  start(listenerCount) {
    this._stopWatch = new StopWatch();
    this.listenerCount = listenerCount;
  }
  stop() {
    if (this._stopWatch) {
      const elapsed = this._stopWatch.elapsed();
      this.durations.push(elapsed);
      this.elapsedOverall += elapsed;
      this.invocationCount += 1;
      this._stopWatch = void 0;
    }
  }
};
EventProfiling.all = /* @__PURE__ */ new Set();
EventProfiling._idPool = 0;
var _globalLeakWarningThreshold = -1;
var LeakageMonitor = class {
  constructor(threshold, name = Math.random().toString(18).slice(2, 5)) {
    this.threshold = threshold;
    this.name = name;
    this._warnCountdown = 0;
  }
  dispose() {
    var _a4;
    (_a4 = this._stacks) === null || _a4 === void 0 ? void 0 : _a4.clear();
  }
  check(stack, listenerCount) {
    const threshold = this.threshold;
    if (threshold <= 0 || listenerCount < threshold) {
      return void 0;
    }
    if (!this._stacks) {
      this._stacks = /* @__PURE__ */ new Map();
    }
    const count = this._stacks.get(stack.value) || 0;
    this._stacks.set(stack.value, count + 1);
    this._warnCountdown -= 1;
    if (this._warnCountdown <= 0) {
      this._warnCountdown = threshold * 0.5;
      let topStack;
      let topCount = 0;
      for (const [stack2, count2] of this._stacks) {
        if (!topStack || topCount < count2) {
          topStack = stack2;
          topCount = count2;
        }
      }
      console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);
      console.warn(topStack);
    }
    return () => {
      const count2 = this._stacks.get(stack.value) || 0;
      this._stacks.set(stack.value, count2 - 1);
    };
  }
};
var Stacktrace = class _Stacktrace {
  static create() {
    var _a4;
    return new _Stacktrace((_a4 = new Error().stack) !== null && _a4 !== void 0 ? _a4 : "");
  }
  constructor(value) {
    this.value = value;
  }
  print() {
    console.warn(this.value.split("\n").slice(2).join("\n"));
  }
};
var UniqueContainer = class {
  constructor(value) {
    this.value = value;
  }
};
var compactionThreshold = 2;
var forEachListener = (listeners, fn) => {
  if (listeners instanceof UniqueContainer) {
    fn(listeners);
  } else {
    for (let i = 0; i < listeners.length; i++) {
      const l = listeners[i];
      if (l) {
        fn(l);
      }
    }
  }
};
var Emitter = class {
  constructor(options) {
    var _a4, _b2, _c, _d, _e;
    this._size = 0;
    this._options = options;
    this._leakageMon = _globalLeakWarningThreshold > 0 || ((_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.leakWarningThreshold) ? new LeakageMonitor((_c = (_b2 = this._options) === null || _b2 === void 0 ? void 0 : _b2.leakWarningThreshold) !== null && _c !== void 0 ? _c : _globalLeakWarningThreshold) : void 0;
    this._perfMon = ((_d = this._options) === null || _d === void 0 ? void 0 : _d._profName) ? new EventProfiling(this._options._profName) : void 0;
    this._deliveryQueue = (_e = this._options) === null || _e === void 0 ? void 0 : _e.deliveryQueue;
  }
  dispose() {
    var _a4, _b2, _c, _d;
    if (!this._disposed) {
      this._disposed = true;
      if (((_a4 = this._deliveryQueue) === null || _a4 === void 0 ? void 0 : _a4.current) === this) {
        this._deliveryQueue.reset();
      }
      if (this._listeners) {
        if (_enableDisposeWithListenerWarning) {
          const listeners = this._listeners;
          queueMicrotask(() => {
            forEachListener(listeners, (l) => {
              var _a5;
              return (_a5 = l.stack) === null || _a5 === void 0 ? void 0 : _a5.print();
            });
          });
        }
        this._listeners = void 0;
        this._size = 0;
      }
      (_c = (_b2 = this._options) === null || _b2 === void 0 ? void 0 : _b2.onDidRemoveLastListener) === null || _c === void 0 ? void 0 : _c.call(_b2);
      (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();
    }
  }
  /**
   * For the public to allow to subscribe
   * to events from this Emitter
   */
  get event() {
    var _a4;
    (_a4 = this._event) !== null && _a4 !== void 0 ? _a4 : this._event = (callback, thisArgs, disposables) => {
      var _a5, _b2, _c, _d, _e;
      if (this._leakageMon && this._size > this._leakageMon.threshold * 3) {
        console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`);
        return Disposable.None;
      }
      if (this._disposed) {
        return Disposable.None;
      }
      if (thisArgs) {
        callback = callback.bind(thisArgs);
      }
      const contained = new UniqueContainer(callback);
      let removeMonitor;
      let stack;
      if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {
        contained.stack = Stacktrace.create();
        removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);
      }
      if (_enableDisposeWithListenerWarning) {
        contained.stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();
      }
      if (!this._listeners) {
        (_b2 = (_a5 = this._options) === null || _a5 === void 0 ? void 0 : _a5.onWillAddFirstListener) === null || _b2 === void 0 ? void 0 : _b2.call(_a5, this);
        this._listeners = contained;
        (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidAddFirstListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);
      } else if (this._listeners instanceof UniqueContainer) {
        (_e = this._deliveryQueue) !== null && _e !== void 0 ? _e : this._deliveryQueue = new EventDeliveryQueuePrivate();
        this._listeners = [this._listeners, contained];
      } else {
        this._listeners.push(contained);
      }
      this._size++;
      const result = toDisposable(() => {
        removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();
        this._removeListener(contained);
      });
      if (disposables instanceof DisposableStore) {
        disposables.add(result);
      } else if (Array.isArray(disposables)) {
        disposables.push(result);
      }
      return result;
    };
    return this._event;
  }
  _removeListener(listener) {
    var _a4, _b2, _c, _d;
    (_b2 = (_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.onWillRemoveListener) === null || _b2 === void 0 ? void 0 : _b2.call(_a4, this);
    if (!this._listeners) {
      return;
    }
    if (this._size === 1) {
      this._listeners = void 0;
      (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidRemoveLastListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);
      this._size = 0;
      return;
    }
    const listeners = this._listeners;
    const index = listeners.indexOf(listener);
    if (index === -1) {
      console.log("disposed?", this._disposed);
      console.log("size?", this._size);
      console.log("arr?", JSON.stringify(this._listeners));
      throw new Error("Attempted to dispose unknown listener");
    }
    this._size--;
    listeners[index] = void 0;
    const adjustDeliveryQueue = this._deliveryQueue.current === this;
    if (this._size * compactionThreshold <= listeners.length) {
      let n = 0;
      for (let i = 0; i < listeners.length; i++) {
        if (listeners[i]) {
          listeners[n++] = listeners[i];
        } else if (adjustDeliveryQueue) {
          this._deliveryQueue.end--;
          if (n < this._deliveryQueue.i) {
            this._deliveryQueue.i--;
          }
        }
      }
      listeners.length = n;
    }
  }
  _deliver(listener, value) {
    var _a4;
    if (!listener) {
      return;
    }
    const errorHandler2 = ((_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.onListenerError) || onUnexpectedError;
    if (!errorHandler2) {
      listener.value(value);
      return;
    }
    try {
      listener.value(value);
    } catch (e) {
      errorHandler2(e);
    }
  }
  /** Delivers items in the queue. Assumes the queue is ready to go. */
  _deliverQueue(dq) {
    const listeners = dq.current._listeners;
    while (dq.i < dq.end) {
      this._deliver(listeners[dq.i++], dq.value);
    }
    dq.reset();
  }
  /**
   * To be kept private to fire an event to
   * subscribers
   */
  fire(event) {
    var _a4, _b2, _c, _d;
    if ((_a4 = this._deliveryQueue) === null || _a4 === void 0 ? void 0 : _a4.current) {
      this._deliverQueue(this._deliveryQueue);
      (_b2 = this._perfMon) === null || _b2 === void 0 ? void 0 : _b2.stop();
    }
    (_c = this._perfMon) === null || _c === void 0 ? void 0 : _c.start(this._size);
    if (!this._listeners) {
    } else if (this._listeners instanceof UniqueContainer) {
      this._deliver(this._listeners, event);
    } else {
      const dq = this._deliveryQueue;
      dq.enqueue(this, event, this._listeners.length);
      this._deliverQueue(dq);
    }
    (_d = this._perfMon) === null || _d === void 0 ? void 0 : _d.stop();
  }
  hasListeners() {
    return this._size > 0;
  }
};
var EventDeliveryQueuePrivate = class {
  constructor() {
    this.i = -1;
    this.end = 0;
  }
  enqueue(emitter, value, end) {
    this.i = 0;
    this.end = end;
    this.current = emitter;
    this.value = value;
  }
  reset() {
    this.i = this.end;
    this.current = void 0;
    this.value = void 0;
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/types.js
function isString(str) {
  return typeof str === "string";
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/objects.js
function getAllPropertyNames(obj) {
  let res = [];
  while (Object.prototype !== obj) {
    res = res.concat(Object.getOwnPropertyNames(obj));
    obj = Object.getPrototypeOf(obj);
  }
  return res;
}
function getAllMethodNames(obj) {
  const methods = [];
  for (const prop of getAllPropertyNames(obj)) {
    if (typeof obj[prop] === "function") {
      methods.push(prop);
    }
  }
  return methods;
}
function createProxyObject(methodNames, invoke) {
  const createProxyMethod = (method) => {
    return function() {
      const args = Array.prototype.slice.call(arguments, 0);
      return invoke(method, args);
    };
  };
  const result = {};
  for (const methodName of methodNames) {
    result[methodName] = createProxyMethod(methodName);
  }
  return result;
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/nls.js
var isPseudo = typeof document !== "undefined" && document.location && document.location.hash.indexOf("pseudo=true") >= 0;
function _format(message, args) {
  let result;
  if (args.length === 0) {
    result = message;
  } else {
    result = message.replace(/\{(\d+)\}/g, (match, rest) => {
      const index = rest[0];
      const arg = args[index];
      let result2 = match;
      if (typeof arg === "string") {
        result2 = arg;
      } else if (typeof arg === "number" || typeof arg === "boolean" || arg === void 0 || arg === null) {
        result2 = String(arg);
      }
      return result2;
    });
  }
  if (isPseudo) {
    result = "\uFF3B" + result.replace(/[aouei]/g, "$&$&") + "\uFF3D";
  }
  return result;
}
function localize(data, message, ...args) {
  return _format(message, args);
}
function getConfiguredDefaultLocale(_) {
  return void 0;
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/platform.js
var _a;
var LANGUAGE_DEFAULT = "en";
var _isWindows = false;
var _isMacintosh = false;
var _isLinux = false;
var _isLinuxSnap = false;
var _isNative = false;
var _isWeb = false;
var _isElectron = false;
var _isIOS = false;
var _isCI = false;
var _isMobile = false;
var _locale = void 0;
var _language = LANGUAGE_DEFAULT;
var _platformLocale = LANGUAGE_DEFAULT;
var _translationsConfigFile = void 0;
var _userAgent = void 0;
var $globalThis = globalThis;
var nodeProcess = void 0;
if (typeof $globalThis.vscode !== "undefined" && typeof $globalThis.vscode.process !== "undefined") {
  nodeProcess = $globalThis.vscode.process;
} else if (typeof process !== "undefined") {
  nodeProcess = process;
}
var isElectronProcess = typeof ((_a = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _a === void 0 ? void 0 : _a.electron) === "string";
var isElectronRenderer = isElectronProcess && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.type) === "renderer";
if (typeof nodeProcess === "object") {
  _isWindows = nodeProcess.platform === "win32";
  _isMacintosh = nodeProcess.platform === "darwin";
  _isLinux = nodeProcess.platform === "linux";
  _isLinuxSnap = _isLinux && !!nodeProcess.env["SNAP"] && !!nodeProcess.env["SNAP_REVISION"];
  _isElectron = isElectronProcess;
  _isCI = !!nodeProcess.env["CI"] || !!nodeProcess.env["BUILD_ARTIFACTSTAGINGDIRECTORY"];
  _locale = LANGUAGE_DEFAULT;
  _language = LANGUAGE_DEFAULT;
  const rawNlsConfig = nodeProcess.env["VSCODE_NLS_CONFIG"];
  if (rawNlsConfig) {
    try {
      const nlsConfig = JSON.parse(rawNlsConfig);
      const resolved = nlsConfig.availableLanguages["*"];
      _locale = nlsConfig.locale;
      _platformLocale = nlsConfig.osLocale;
      _language = resolved ? resolved : LANGUAGE_DEFAULT;
      _translationsConfigFile = nlsConfig._translationsConfigFile;
    } catch (e) {
    }
  }
  _isNative = true;
} else if (typeof navigator === "object" && !isElectronRenderer) {
  _userAgent = navigator.userAgent;
  _isWindows = _userAgent.indexOf("Windows") >= 0;
  _isMacintosh = _userAgent.indexOf("Macintosh") >= 0;
  _isIOS = (_userAgent.indexOf("Macintosh") >= 0 || _userAgent.indexOf("iPad") >= 0 || _userAgent.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
  _isLinux = _userAgent.indexOf("Linux") >= 0;
  _isMobile = (_userAgent === null || _userAgent === void 0 ? void 0 : _userAgent.indexOf("Mobi")) >= 0;
  _isWeb = true;
  const configuredLocale = getConfiguredDefaultLocale(
    // This call _must_ be done in the file that calls `nls.getConfiguredDefaultLocale`
    // to ensure that the NLS AMD Loader plugin has been loaded and configured.
    // This is because the loader plugin decides what the default locale is based on
    // how it's able to resolve the strings.
    localize({ key: "ensureLoaderPluginIsLoaded", comment: ["{Locked}"] }, "_")
  );
  _locale = configuredLocale || LANGUAGE_DEFAULT;
  _language = _locale;
  _platformLocale = navigator.language;
} else {
  console.error("Unable to resolve platform.");
}
var _platform = 0;
if (_isMacintosh) {
  _platform = 1;
} else if (_isWindows) {
  _platform = 3;
} else if (_isLinux) {
  _platform = 2;
}
var isWindows = _isWindows;
var isMacintosh = _isMacintosh;
var isWebWorker = _isWeb && typeof $globalThis.importScripts === "function";
var webWorkerOrigin = isWebWorker ? $globalThis.origin : void 0;
var userAgent = _userAgent;
var setTimeout0IsFaster = typeof $globalThis.postMessage === "function" && !$globalThis.importScripts;
var setTimeout0 = (() => {
  if (setTimeout0IsFaster) {
    const pending = [];
    $globalThis.addEventListener("message", (e) => {
      if (e.data && e.data.vscodeScheduleAsyncWork) {
        for (let i = 0, len = pending.length; i < len; i++) {
          const candidate = pending[i];
          if (candidate.id === e.data.vscodeScheduleAsyncWork) {
            pending.splice(i, 1);
            candidate.callback();
            return;
          }
        }
      }
    });
    let lastId = 0;
    return (callback) => {
      const myId = ++lastId;
      pending.push({
        id: myId,
        callback
      });
      $globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, "*");
    };
  }
  return (callback) => setTimeout(callback);
})();
var isChrome = !!(userAgent && userAgent.indexOf("Chrome") >= 0);
var isFirefox = !!(userAgent && userAgent.indexOf("Firefox") >= 0);
var isSafari = !!(!isChrome && (userAgent && userAgent.indexOf("Safari") >= 0));
var isEdge = !!(userAgent && userAgent.indexOf("Edg/") >= 0);
var isAndroid = !!(userAgent && userAgent.indexOf("Android") >= 0);

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/cache.js
var LRUCachedFunction = class {
  constructor(fn) {
    this.fn = fn;
    this.lastCache = void 0;
    this.lastArgKey = void 0;
  }
  get(arg) {
    const key = JSON.stringify(arg);
    if (this.lastArgKey !== key) {
      this.lastArgKey = key;
      this.lastCache = this.fn(arg);
    }
    return this.lastCache;
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/lazy.js
var Lazy = class {
  constructor(executor) {
    this.executor = executor;
    this._didRun = false;
  }
  /**
   * Get the wrapped value.
   *
   * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
   * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
   */
  get value() {
    if (!this._didRun) {
      try {
        this._value = this.executor();
      } catch (err) {
        this._error = err;
      } finally {
        this._didRun = true;
      }
    }
    if (this._error) {
      throw this._error;
    }
    return this._value;
  }
  /**
   * Get the wrapped value without forcing evaluation.
   */
  get rawValue() {
    return this._value;
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/strings.js
var _a2;
function escapeRegExpCharacters(value) {
  return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
function splitLines(str) {
  return str.split(/\r\n|\r|\n/);
}
function firstNonWhitespaceIndex(str) {
  for (let i = 0, len = str.length; i < len; i++) {
    const chCode = str.charCodeAt(i);
    if (chCode !== 32 && chCode !== 9) {
      return i;
    }
  }
  return -1;
}
function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
  for (let i = startIndex; i >= 0; i--) {
    const chCode = str.charCodeAt(i);
    if (chCode !== 32 && chCode !== 9) {
      return i;
    }
  }
  return -1;
}
function isUpperAsciiLetter(code) {
  return code >= 65 && code <= 90;
}
function isHighSurrogate(charCode) {
  return 55296 <= charCode && charCode <= 56319;
}
function isLowSurrogate(charCode) {
  return 56320 <= charCode && charCode <= 57343;
}
function computeCodePoint(highSurrogate, lowSurrogate) {
  return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
}
function getNextCodePoint(str, len, offset) {
  const charCode = str.charCodeAt(offset);
  if (isHighSurrogate(charCode) && offset + 1 < len) {
    const nextCharCode = str.charCodeAt(offset + 1);
    if (isLowSurrogate(nextCharCode)) {
      return computeCodePoint(charCode, nextCharCode);
    }
  }
  return charCode;
}
var IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
function isBasicASCII(str) {
  return IS_BASIC_ASCII.test(str);
}
var UTF8_BOM_CHARACTER = String.fromCharCode(
  65279
  /* CharCode.UTF8_BOM */
);
var GraphemeBreakTree = class _GraphemeBreakTree {
  static getInstance() {
    if (!_GraphemeBreakTree._INSTANCE) {
      _GraphemeBreakTree._INSTANCE = new _GraphemeBreakTree();
    }
    return _GraphemeBreakTree._INSTANCE;
  }
  constructor() {
    this._data = getGraphemeBreakRawData();
  }
  getGraphemeBreakType(codePoint) {
    if (codePoint < 32) {
      if (codePoint === 10) {
        return 3;
      }
      if (codePoint === 13) {
        return 2;
      }
      return 4;
    }
    if (codePoint < 127) {
      return 0;
    }
    const data = this._data;
    const nodeCount = data.length / 3;
    let nodeIndex = 1;
    while (nodeIndex <= nodeCount) {
      if (codePoint < data[3 * nodeIndex]) {
        nodeIndex = 2 * nodeIndex;
      } else if (codePoint > data[3 * nodeIndex + 1]) {
        nodeIndex = 2 * nodeIndex + 1;
      } else {
        return data[3 * nodeIndex + 2];
      }
    }
    return 0;
  }
};
GraphemeBreakTree._INSTANCE = null;
function getGraphemeBreakRawData() {
  return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
}
var AmbiguousCharacters = class {
  static getInstance(locales) {
    return _a2.cache.get(Array.from(locales));
  }
  static getLocales() {
    return _a2._locales.value;
  }
  constructor(confusableDictionary) {
    this.confusableDictionary = confusableDictionary;
  }
  isAmbiguous(codePoint) {
    return this.confusableDictionary.has(codePoint);
  }
  /**
   * Returns the non basic ASCII code point that the given code point can be confused,
   * or undefined if such code point does note exist.
   */
  getPrimaryConfusable(codePoint) {
    return this.confusableDictionary.get(codePoint);
  }
  getConfusableCodePoints() {
    return new Set(this.confusableDictionary.keys());
  }
};
_a2 = AmbiguousCharacters;
AmbiguousCharacters.ambiguousCharacterData = new Lazy(() => {
  return JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');
});
AmbiguousCharacters.cache = new LRUCachedFunction((locales) => {
  function arrayToMap(arr) {
    const result = /* @__PURE__ */ new Map();
    for (let i = 0; i < arr.length; i += 2) {
      result.set(arr[i], arr[i + 1]);
    }
    return result;
  }
  function mergeMaps(map1, map22) {
    const result = new Map(map1);
    for (const [key, value] of map22) {
      result.set(key, value);
    }
    return result;
  }
  function intersectMaps(map1, map22) {
    if (!map1) {
      return map22;
    }
    const result = /* @__PURE__ */ new Map();
    for (const [key, value] of map1) {
      if (map22.has(key)) {
        result.set(key, value);
      }
    }
    return result;
  }
  const data = _a2.ambiguousCharacterData.value;
  let filteredLocales = locales.filter((l) => !l.startsWith("_") && l in data);
  if (filteredLocales.length === 0) {
    filteredLocales = ["_default"];
  }
  let languageSpecificMap = void 0;
  for (const locale of filteredLocales) {
    const map3 = arrayToMap(data[locale]);
    languageSpecificMap = intersectMaps(languageSpecificMap, map3);
  }
  const commonMap = arrayToMap(data["_common"]);
  const map2 = mergeMaps(commonMap, languageSpecificMap);
  return new _a2(map2);
});
AmbiguousCharacters._locales = new Lazy(() => Object.keys(_a2.ambiguousCharacterData.value).filter((k) => !k.startsWith("_")));
var InvisibleCharacters = class _InvisibleCharacters {
  static getRawData() {
    return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
  }
  static getData() {
    if (!this._data) {
      this._data = new Set(_InvisibleCharacters.getRawData());
    }
    return this._data;
  }
  static isInvisibleCharacter(codePoint) {
    return _InvisibleCharacters.getData().has(codePoint);
  }
  static get codePoints() {
    return _InvisibleCharacters.getData();
  }
};
InvisibleCharacters._data = void 0;

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js
var INITIALIZE = "$initialize";
var RequestMessage = class {
  constructor(vsWorker, req, method, args) {
    this.vsWorker = vsWorker;
    this.req = req;
    this.method = method;
    this.args = args;
    this.type = 0;
  }
};
var ReplyMessage = class {
  constructor(vsWorker, seq2, res, err) {
    this.vsWorker = vsWorker;
    this.seq = seq2;
    this.res = res;
    this.err = err;
    this.type = 1;
  }
};
var SubscribeEventMessage = class {
  constructor(vsWorker, req, eventName, arg) {
    this.vsWorker = vsWorker;
    this.req = req;
    this.eventName = eventName;
    this.arg = arg;
    this.type = 2;
  }
};
var EventMessage = class {
  constructor(vsWorker, req, event) {
    this.vsWorker = vsWorker;
    this.req = req;
    this.event = event;
    this.type = 3;
  }
};
var UnsubscribeEventMessage = class {
  constructor(vsWorker, req) {
    this.vsWorker = vsWorker;
    this.req = req;
    this.type = 4;
  }
};
var SimpleWorkerProtocol = class {
  constructor(handler) {
    this._workerId = -1;
    this._handler = handler;
    this._lastSentReq = 0;
    this._pendingReplies = /* @__PURE__ */ Object.create(null);
    this._pendingEmitters = /* @__PURE__ */ new Map();
    this._pendingEvents = /* @__PURE__ */ new Map();
  }
  setWorkerId(workerId) {
    this._workerId = workerId;
  }
  sendMessage(method, args) {
    const req = String(++this._lastSentReq);
    return new Promise((resolve3, reject) => {
      this._pendingReplies[req] = {
        resolve: resolve3,
        reject
      };
      this._send(new RequestMessage(this._workerId, req, method, args));
    });
  }
  listen(eventName, arg) {
    let req = null;
    const emitter = new Emitter({
      onWillAddFirstListener: () => {
        req = String(++this._lastSentReq);
        this._pendingEmitters.set(req, emitter);
        this._send(new SubscribeEventMessage(this._workerId, req, eventName, arg));
      },
      onDidRemoveLastListener: () => {
        this._pendingEmitters.delete(req);
        this._send(new UnsubscribeEventMessage(this._workerId, req));
        req = null;
      }
    });
    return emitter.event;
  }
  handleMessage(message) {
    if (!message || !message.vsWorker) {
      return;
    }
    if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
      return;
    }
    this._handleMessage(message);
  }
  _handleMessage(msg) {
    switch (msg.type) {
      case 1:
        return this._handleReplyMessage(msg);
      case 0:
        return this._handleRequestMessage(msg);
      case 2:
        return this._handleSubscribeEventMessage(msg);
      case 3:
        return this._handleEventMessage(msg);
      case 4:
        return this._handleUnsubscribeEventMessage(msg);
    }
  }
  _handleReplyMessage(replyMessage) {
    if (!this._pendingReplies[replyMessage.seq]) {
      console.warn("Got reply to unknown seq");
      return;
    }
    const reply = this._pendingReplies[replyMessage.seq];
    delete this._pendingReplies[replyMessage.seq];
    if (replyMessage.err) {
      let err = replyMessage.err;
      if (replyMessage.err.$isError) {
        err = new Error();
        err.name = replyMessage.err.name;
        err.message = replyMessage.err.message;
        err.stack = replyMessage.err.stack;
      }
      reply.reject(err);
      return;
    }
    reply.resolve(replyMessage.res);
  }
  _handleRequestMessage(requestMessage) {
    const req = requestMessage.req;
    const result = this._handler.handleMessage(requestMessage.method, requestMessage.args);
    result.then((r) => {
      this._send(new ReplyMessage(this._workerId, req, r, void 0));
    }, (e) => {
      if (e.detail instanceof Error) {
        e.detail = transformErrorForSerialization(e.detail);
      }
      this._send(new ReplyMessage(this._workerId, req, void 0, transformErrorForSerialization(e)));
    });
  }
  _handleSubscribeEventMessage(msg) {
    const req = msg.req;
    const disposable = this._handler.handleEvent(msg.eventName, msg.arg)((event) => {
      this._send(new EventMessage(this._workerId, req, event));
    });
    this._pendingEvents.set(req, disposable);
  }
  _handleEventMessage(msg) {
    if (!this._pendingEmitters.has(msg.req)) {
      console.warn("Got event for unknown req");
      return;
    }
    this._pendingEmitters.get(msg.req).fire(msg.event);
  }
  _handleUnsubscribeEventMessage(msg) {
    if (!this._pendingEvents.has(msg.req)) {
      console.warn("Got unsubscribe for unknown req");
      return;
    }
    this._pendingEvents.get(msg.req).dispose();
    this._pendingEvents.delete(msg.req);
  }
  _send(msg) {
    const transfer = [];
    if (msg.type === 0) {
      for (let i = 0; i < msg.args.length; i++) {
        if (msg.args[i] instanceof ArrayBuffer) {
          transfer.push(msg.args[i]);
        }
      }
    } else if (msg.type === 1) {
      if (msg.res instanceof ArrayBuffer) {
        transfer.push(msg.res);
      }
    }
    this._handler.sendMessage(msg, transfer);
  }
};
function propertyIsEvent(name) {
  return name[0] === "o" && name[1] === "n" && isUpperAsciiLetter(name.charCodeAt(2));
}
function propertyIsDynamicEvent(name) {
  return /^onDynamic/.test(name) && isUpperAsciiLetter(name.charCodeAt(9));
}
function createProxyObject2(methodNames, invoke, proxyListen) {
  const createProxyMethod = (method) => {
    return function() {
      const args = Array.prototype.slice.call(arguments, 0);
      return invoke(method, args);
    };
  };
  const createProxyDynamicEvent = (eventName) => {
    return function(arg) {
      return proxyListen(eventName, arg);
    };
  };
  const result = {};
  for (const methodName of methodNames) {
    if (propertyIsDynamicEvent(methodName)) {
      result[methodName] = createProxyDynamicEvent(methodName);
      continue;
    }
    if (propertyIsEvent(methodName)) {
      result[methodName] = proxyListen(methodName, void 0);
      continue;
    }
    result[methodName] = createProxyMethod(methodName);
  }
  return result;
}
var SimpleWorkerServer = class {
  constructor(postMessage, requestHandlerFactory) {
    this._requestHandlerFactory = requestHandlerFactory;
    this._requestHandler = null;
    this._protocol = new SimpleWorkerProtocol({
      sendMessage: (msg, transfer) => {
        postMessage(msg, transfer);
      },
      handleMessage: (method, args) => this._handleMessage(method, args),
      handleEvent: (eventName, arg) => this._handleEvent(eventName, arg)
    });
  }
  onmessage(msg) {
    this._protocol.handleMessage(msg);
  }
  _handleMessage(method, args) {
    if (method === INITIALIZE) {
      return this.initialize(args[0], args[1], args[2], args[3]);
    }
    if (!this._requestHandler || typeof this._requestHandler[method] !== "function") {
      return Promise.reject(new Error("Missing requestHandler or method: " + method));
    }
    try {
      return Promise.resolve(this._requestHandler[method].apply(this._requestHandler, args));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  _handleEvent(eventName, arg) {
    if (!this._requestHandler) {
      throw new Error(`Missing requestHandler`);
    }
    if (propertyIsDynamicEvent(eventName)) {
      const event = this._requestHandler[eventName].call(this._requestHandler, arg);
      if (typeof event !== "function") {
        throw new Error(`Missing dynamic event ${eventName} on request handler.`);
      }
      return event;
    }
    if (propertyIsEvent(eventName)) {
      const event = this._requestHandler[eventName];
      if (typeof event !== "function") {
        throw new Error(`Missing event ${eventName} on request handler.`);
      }
      return event;
    }
    throw new Error(`Malformed event name ${eventName}`);
  }
  initialize(workerId, loaderConfig, moduleId, hostMethods) {
    this._protocol.setWorkerId(workerId);
    const proxyMethodRequest = (method, args) => {
      return this._protocol.sendMessage(method, args);
    };
    const proxyListen = (eventName, arg) => {
      return this._protocol.listen(eventName, arg);
    };
    const hostProxy = createProxyObject2(hostMethods, proxyMethodRequest, proxyListen);
    if (this._requestHandlerFactory) {
      this._requestHandler = this._requestHandlerFactory(hostProxy);
      return Promise.resolve(getAllMethodNames(this._requestHandler));
    }
    if (loaderConfig) {
      if (typeof loaderConfig.baseUrl !== "undefined") {
        delete loaderConfig["baseUrl"];
      }
      if (typeof loaderConfig.paths !== "undefined") {
        if (typeof loaderConfig.paths.vs !== "undefined") {
          delete loaderConfig.paths["vs"];
        }
      }
      if (typeof loaderConfig.trustedTypesPolicy !== "undefined") {
        delete loaderConfig["trustedTypesPolicy"];
      }
      loaderConfig.catchError = true;
      globalThis.require.config(loaderConfig);
    }
    return new Promise((resolve3, reject) => {
      const req = globalThis.require;
      req([moduleId], (module) => {
        this._requestHandler = module.create(hostProxy);
        if (!this._requestHandler) {
          reject(new Error(`No RequestHandler!`));
          return;
        }
        resolve3(getAllMethodNames(this._requestHandler));
      }, reject);
    });
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js
var DiffChange = class {
  /**
   * Constructs a new DiffChange with the given sequence information
   * and content.
   */
  constructor(originalStart, originalLength, modifiedStart, modifiedLength) {
    this.originalStart = originalStart;
    this.originalLength = originalLength;
    this.modifiedStart = modifiedStart;
    this.modifiedLength = modifiedLength;
  }
  /**
   * The end point (exclusive) of the change in the original sequence.
   */
  getOriginalEnd() {
    return this.originalStart + this.originalLength;
  }
  /**
   * The end point (exclusive) of the change in the modified sequence.
   */
  getModifiedEnd() {
    return this.modifiedStart + this.modifiedLength;
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/hash.js
function numberHash(val, initialHashVal) {
  return (initialHashVal << 5) - initialHashVal + val | 0;
}
function stringHash(s, hashVal) {
  hashVal = numberHash(149417, hashVal);
  for (let i = 0, length = s.length; i < length; i++) {
    hashVal = numberHash(s.charCodeAt(i), hashVal);
  }
  return hashVal;
}
function leftRotate(value, bits, totalBits = 32) {
  const delta = totalBits - bits;
  const mask = ~((1 << delta) - 1);
  return (value << bits | (mask & value) >>> delta) >>> 0;
}
function fill(dest, index = 0, count = dest.byteLength, value = 0) {
  for (let i = 0; i < count; i++) {
    dest[index + i] = value;
  }
}
function leftPad(value, length, char = "0") {
  while (value.length < length) {
    value = char + value;
  }
  return value;
}
function toHexString(bufferOrValue, bitsize = 32) {
  if (bufferOrValue instanceof ArrayBuffer) {
    return Array.from(new Uint8Array(bufferOrValue)).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);
}
var StringSHA1 = class _StringSHA1 {
  constructor() {
    this._h0 = 1732584193;
    this._h1 = 4023233417;
    this._h2 = 2562383102;
    this._h3 = 271733878;
    this._h4 = 3285377520;
    this._buff = new Uint8Array(
      64 + 3
      /* to fit any utf-8 */
    );
    this._buffDV = new DataView(this._buff.buffer);
    this._buffLen = 0;
    this._totalLen = 0;
    this._leftoverHighSurrogate = 0;
    this._finished = false;
  }
  update(str) {
    const strLen = str.length;
    if (strLen === 0) {
      return;
    }
    const buff = this._buff;
    let buffLen = this._buffLen;
    let leftoverHighSurrogate = this._leftoverHighSurrogate;
    let charCode;
    let offset;
    if (leftoverHighSurrogate !== 0) {
      charCode = leftoverHighSurrogate;
      offset = -1;
      leftoverHighSurrogate = 0;
    } else {
      charCode = str.charCodeAt(0);
      offset = 0;
    }
    while (true) {
      let codePoint = charCode;
      if (isHighSurrogate(charCode)) {
        if (offset + 1 < strLen) {
          const nextCharCode = str.charCodeAt(offset + 1);
          if (isLowSurrogate(nextCharCode)) {
            offset++;
            codePoint = computeCodePoint(charCode, nextCharCode);
          } else {
            codePoint = 65533;
          }
        } else {
          leftoverHighSurrogate = charCode;
          break;
        }
      } else if (isLowSurrogate(charCode)) {
        codePoint = 65533;
      }
      buffLen = this._push(buff, buffLen, codePoint);
      offset++;
      if (offset < strLen) {
        charCode = str.charCodeAt(offset);
      } else {
        break;
      }
    }
    this._buffLen = buffLen;
    this._leftoverHighSurrogate = leftoverHighSurrogate;
  }
  _push(buff, buffLen, codePoint) {
    if (codePoint < 128) {
      buff[buffLen++] = codePoint;
    } else if (codePoint < 2048) {
      buff[buffLen++] = 192 | (codePoint & 1984) >>> 6;
      buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
    } else if (codePoint < 65536) {
      buff[buffLen++] = 224 | (codePoint & 61440) >>> 12;
      buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
      buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
    } else {
      buff[buffLen++] = 240 | (codePoint & 1835008) >>> 18;
      buff[buffLen++] = 128 | (codePoint & 258048) >>> 12;
      buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
      buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
    }
    if (buffLen >= 64) {
      this._step();
      buffLen -= 64;
      this._totalLen += 64;
      buff[0] = buff[64 + 0];
      buff[1] = buff[64 + 1];
      buff[2] = buff[64 + 2];
    }
    return buffLen;
  }
  digest() {
    if (!this._finished) {
      this._finished = true;
      if (this._leftoverHighSurrogate) {
        this._leftoverHighSurrogate = 0;
        this._buffLen = this._push(
          this._buff,
          this._buffLen,
          65533
          /* SHA1Constant.UNICODE_REPLACEMENT */
        );
      }
      this._totalLen += this._buffLen;
      this._wrapUp();
    }
    return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
  }
  _wrapUp() {
    this._buff[this._buffLen++] = 128;
    fill(this._buff, this._buffLen);
    if (this._buffLen > 56) {
      this._step();
      fill(this._buff);
    }
    const ml = 8 * this._totalLen;
    this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
    this._buffDV.setUint32(60, ml % 4294967296, false);
    this._step();
  }
  _step() {
    const bigBlock32 = _StringSHA1._bigBlock32;
    const data = this._buffDV;
    for (let j = 0; j < 64; j += 4) {
      bigBlock32.setUint32(j, data.getUint32(j, false), false);
    }
    for (let j = 64; j < 320; j += 4) {
      bigBlock32.setUint32(j, leftRotate(bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false), 1), false);
    }
    let a2 = this._h0;
    let b = this._h1;
    let c = this._h2;
    let d = this._h3;
    let e = this._h4;
    let f2, k;
    let temp;
    for (let j = 0; j < 80; j++) {
      if (j < 20) {
        f2 = b & c | ~b & d;
        k = 1518500249;
      } else if (j < 40) {
        f2 = b ^ c ^ d;
        k = 1859775393;
      } else if (j < 60) {
        f2 = b & c | b & d | c & d;
        k = 2400959708;
      } else {
        f2 = b ^ c ^ d;
        k = 3395469782;
      }
      temp = leftRotate(a2, 5) + f2 + e + k + bigBlock32.getUint32(j * 4, false) & 4294967295;
      e = d;
      d = c;
      c = leftRotate(b, 30);
      b = a2;
      a2 = temp;
    }
    this._h0 = this._h0 + a2 & 4294967295;
    this._h1 = this._h1 + b & 4294967295;
    this._h2 = this._h2 + c & 4294967295;
    this._h3 = this._h3 + d & 4294967295;
    this._h4 = this._h4 + e & 4294967295;
  }
};
StringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320));

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js
var StringDiffSequence = class {
  constructor(source) {
    this.source = source;
  }
  getElements() {
    const source = this.source;
    const characters = new Int32Array(source.length);
    for (let i = 0, len = source.length; i < len; i++) {
      characters[i] = source.charCodeAt(i);
    }
    return characters;
  }
};
function stringDiff(original, modified, pretty) {
  return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;
}
var Debug = class {
  static Assert(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }
};
var MyArray = class {
  /**
   * Copies a range of elements from an Array starting at the specified source index and pastes
   * them to another Array starting at the specified destination index. The length and the indexes
   * are specified as 64-bit integers.
   * sourceArray:
   *		The Array that contains the data to copy.
   * sourceIndex:
   *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
   * destinationArray:
   *		The Array that receives the data.
   * destinationIndex:
   *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
   * length:
   *		A 64-bit integer that represents the number of elements to copy.
   */
  static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
    }
  }
  static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
    }
  }
};
var DiffChangeHelper = class {
  /**
   * Constructs a new DiffChangeHelper for the given DiffSequences.
   */
  constructor() {
    this.m_changes = [];
    this.m_originalStart = 1073741824;
    this.m_modifiedStart = 1073741824;
    this.m_originalCount = 0;
    this.m_modifiedCount = 0;
  }
  /**
   * Marks the beginning of the next change in the set of differences.
   */
  MarkNextChange() {
    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
      this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
    }
    this.m_originalCount = 0;
    this.m_modifiedCount = 0;
    this.m_originalStart = 1073741824;
    this.m_modifiedStart = 1073741824;
  }
  /**
   * Adds the original element at the given position to the elements
   * affected by the current change. The modified index gives context
   * to the change position with respect to the original sequence.
   * @param originalIndex The index of the original element to add.
   * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
   */
  AddOriginalElement(originalIndex, modifiedIndex) {
    this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
    this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
    this.m_originalCount++;
  }
  /**
   * Adds the modified element at the given position to the elements
   * affected by the current change. The original index gives context
   * to the change position with respect to the modified sequence.
   * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
   * @param modifiedIndex The index of the modified element to add.
   */
  AddModifiedElement(originalIndex, modifiedIndex) {
    this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
    this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
    this.m_modifiedCount++;
  }
  /**
   * Retrieves all of the changes marked by the class.
   */
  getChanges() {
    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
      this.MarkNextChange();
    }
    return this.m_changes;
  }
  /**
   * Retrieves all of the changes marked by the class in the reverse order
   */
  getReverseChanges() {
    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
      this.MarkNextChange();
    }
    this.m_changes.reverse();
    return this.m_changes;
  }
};
var LcsDiff = class _LcsDiff {
  /**
   * Constructs the DiffFinder
   */
  constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {
    this.ContinueProcessingPredicate = continueProcessingPredicate;
    this._originalSequence = originalSequence;
    this._modifiedSequence = modifiedSequence;
    const [originalStringElements, originalElementsOrHash, originalHasStrings] = _LcsDiff._getElements(originalSequence);
    const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = _LcsDiff._getElements(modifiedSequence);
    this._hasStrings = originalHasStrings && modifiedHasStrings;
    this._originalStringElements = originalStringElements;
    this._originalElementsOrHash = originalElementsOrHash;
    this._modifiedStringElements = modifiedStringElements;
    this._modifiedElementsOrHash = modifiedElementsOrHash;
    this.m_forwardHistory = [];
    this.m_reverseHistory = [];
  }
  static _isStringArray(arr) {
    return arr.length > 0 && typeof arr[0] === "string";
  }
  static _getElements(sequence) {
    const elements = sequence.getElements();
    if (_LcsDiff._isStringArray(elements)) {
      const hashes = new Int32Array(elements.length);
      for (let i = 0, len = elements.length; i < len; i++) {
        hashes[i] = stringHash(elements[i], 0);
      }
      return [elements, hashes, true];
    }
    if (elements instanceof Int32Array) {
      return [[], elements, false];
    }
    return [[], new Int32Array(elements), false];
  }
  ElementsAreEqual(originalIndex, newIndex) {
    if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {
      return false;
    }
    return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;
  }
  ElementsAreStrictEqual(originalIndex, newIndex) {
    if (!this.ElementsAreEqual(originalIndex, newIndex)) {
      return false;
    }
    const originalElement = _LcsDiff._getStrictElement(this._originalSequence, originalIndex);
    const modifiedElement = _LcsDiff._getStrictElement(this._modifiedSequence, newIndex);
    return originalElement === modifiedElement;
  }
  static _getStrictElement(sequence, index) {
    if (typeof sequence.getStrictElement === "function") {
      return sequence.getStrictElement(index);
    }
    return null;
  }
  OriginalElementsAreEqual(index1, index2) {
    if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {
      return false;
    }
    return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;
  }
  ModifiedElementsAreEqual(index1, index2) {
    if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {
      return false;
    }
    return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;
  }
  ComputeDiff(pretty) {
    return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
  }
  /**
   * Computes the differences between the original and modified input
   * sequences on the bounded range.
   * @returns An array of the differences between the two input sequences.
   */
  _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
    const quitEarlyArr = [false];
    let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
    if (pretty) {
      changes = this.PrettifyChanges(changes);
    }
    return {
      quitEarly: quitEarlyArr[0],
      changes
    };
  }
  /**
   * Private helper method which computes the differences on the bounded range
   * recursively.
   * @returns An array of the differences between the two input sequences.
   */
  ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
    quitEarlyArr[0] = false;
    while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
      originalStart++;
      modifiedStart++;
    }
    while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
      originalEnd--;
      modifiedEnd--;
    }
    if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
      let changes;
      if (modifiedStart <= modifiedEnd) {
        Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
        changes = [
          new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
        ];
      } else if (originalStart <= originalEnd) {
        Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
        changes = [
          new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
        ];
      } else {
        Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
        Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
        changes = [];
      }
      return changes;
    }
    const midOriginalArr = [0];
    const midModifiedArr = [0];
    const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
    const midOriginal = midOriginalArr[0];
    const midModified = midModifiedArr[0];
    if (result !== null) {
      return result;
    } else if (!quitEarlyArr[0]) {
      const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
      let rightChanges = [];
      if (!quitEarlyArr[0]) {
        rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
      } else {
        rightChanges = [
          new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
        ];
      }
      return this.ConcatenateChanges(leftChanges, rightChanges);
    }
    return [
      new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
    ];
  }
  WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
    let forwardChanges = null;
    let reverseChanges = null;
    let changeHelper = new DiffChangeHelper();
    let diagonalMin = diagonalForwardStart;
    let diagonalMax = diagonalForwardEnd;
    let diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;
    let lastOriginalIndex = -1073741824;
    let historyIndex = this.m_forwardHistory.length - 1;
    do {
      const diagonal = diagonalRelative + diagonalForwardBase;
      if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
        originalIndex = forwardPoints[diagonal + 1];
        modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
        if (originalIndex < lastOriginalIndex) {
          changeHelper.MarkNextChange();
        }
        lastOriginalIndex = originalIndex;
        changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
        diagonalRelative = diagonal + 1 - diagonalForwardBase;
      } else {
        originalIndex = forwardPoints[diagonal - 1] + 1;
        modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
        if (originalIndex < lastOriginalIndex) {
          changeHelper.MarkNextChange();
        }
        lastOriginalIndex = originalIndex - 1;
        changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
        diagonalRelative = diagonal - 1 - diagonalForwardBase;
      }
      if (historyIndex >= 0) {
        forwardPoints = this.m_forwardHistory[historyIndex];
        diagonalForwardBase = forwardPoints[0];
        diagonalMin = 1;
        diagonalMax = forwardPoints.length - 1;
      }
    } while (--historyIndex >= -1);
    forwardChanges = changeHelper.getReverseChanges();
    if (quitEarlyArr[0]) {
      let originalStartPoint = midOriginalArr[0] + 1;
      let modifiedStartPoint = midModifiedArr[0] + 1;
      if (forwardChanges !== null && forwardChanges.length > 0) {
        const lastForwardChange = forwardChanges[forwardChanges.length - 1];
        originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
        modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
      }
      reverseChanges = [
        new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
      ];
    } else {
      changeHelper = new DiffChangeHelper();
      diagonalMin = diagonalReverseStart;
      diagonalMax = diagonalReverseEnd;
      diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;
      lastOriginalIndex = 1073741824;
      historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
      do {
        const diagonal = diagonalRelative + diagonalReverseBase;
        if (diagonal === diagonalMin || diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
          originalIndex = reversePoints[diagonal + 1] - 1;
          modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
          if (originalIndex > lastOriginalIndex) {
            changeHelper.MarkNextChange();
          }
          lastOriginalIndex = originalIndex + 1;
          changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
          diagonalRelative = diagonal + 1 - diagonalReverseBase;
        } else {
          originalIndex = reversePoints[diagonal - 1];
          modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
          if (originalIndex > lastOriginalIndex) {
            changeHelper.MarkNextChange();
          }
          lastOriginalIndex = originalIndex;
          changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
          diagonalRelative = diagonal - 1 - diagonalReverseBase;
        }
        if (historyIndex >= 0) {
          reversePoints = this.m_reverseHistory[historyIndex];
          diagonalReverseBase = reversePoints[0];
          diagonalMin = 1;
          diagonalMax = reversePoints.length - 1;
        }
      } while (--historyIndex >= -1);
      reverseChanges = changeHelper.getChanges();
    }
    return this.ConcatenateChanges(forwardChanges, reverseChanges);
  }
  /**
   * Given the range to compute the diff on, this method finds the point:
   * (midOriginal, midModified)
   * that exists in the middle of the LCS of the two sequences and
   * is the point at which the LCS problem may be broken down recursively.
   * This method will try to keep the LCS trace in memory. If the LCS recursion
   * point is calculated and the full trace is available in memory, then this method
   * will return the change list.
   * @param originalStart The start bound of the original sequence range
   * @param originalEnd The end bound of the original sequence range
   * @param modifiedStart The start bound of the modified sequence range
   * @param modifiedEnd The end bound of the modified sequence range
   * @param midOriginal The middle point of the original sequence range
   * @param midModified The middle point of the modified sequence range
   * @returns The diff changes, if available, otherwise null
   */
  ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
    let originalIndex = 0, modifiedIndex = 0;
    let diagonalForwardStart = 0, diagonalForwardEnd = 0;
    let diagonalReverseStart = 0, diagonalReverseEnd = 0;
    originalStart--;
    modifiedStart--;
    midOriginalArr[0] = 0;
    midModifiedArr[0] = 0;
    this.m_forwardHistory = [];
    this.m_reverseHistory = [];
    const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);
    const numDiagonals = maxDifferences + 1;
    const forwardPoints = new Int32Array(numDiagonals);
    const reversePoints = new Int32Array(numDiagonals);
    const diagonalForwardBase = modifiedEnd - modifiedStart;
    const diagonalReverseBase = originalEnd - originalStart;
    const diagonalForwardOffset = originalStart - modifiedStart;
    const diagonalReverseOffset = originalEnd - modifiedEnd;
    const delta = diagonalReverseBase - diagonalForwardBase;
    const deltaIsEven = delta % 2 === 0;
    forwardPoints[diagonalForwardBase] = originalStart;
    reversePoints[diagonalReverseBase] = originalEnd;
    quitEarlyArr[0] = false;
    for (let numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {
      let furthestOriginalIndex = 0;
      let furthestModifiedIndex = 0;
      diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
      diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
      for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
        if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
          originalIndex = forwardPoints[diagonal + 1];
        } else {
          originalIndex = forwardPoints[diagonal - 1] + 1;
        }
        modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
        const tempOriginalIndex = originalIndex;
        while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
          originalIndex++;
          modifiedIndex++;
        }
        forwardPoints[diagonal] = originalIndex;
        if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
          furthestOriginalIndex = originalIndex;
          furthestModifiedIndex = modifiedIndex;
        }
        if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {
          if (originalIndex >= reversePoints[diagonal]) {
            midOriginalArr[0] = originalIndex;
            midModifiedArr[0] = modifiedIndex;
            if (tempOriginalIndex <= reversePoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
            } else {
              return null;
            }
          }
        }
      }
      const matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
      if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {
        quitEarlyArr[0] = true;
        midOriginalArr[0] = furthestOriginalIndex;
        midModifiedArr[0] = furthestModifiedIndex;
        if (matchLengthOfLongest > 0 && 1447 > 0 && numDifferences <= 1447 + 1) {
          return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
        } else {
          originalStart++;
          modifiedStart++;
          return [
            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
          ];
        }
      }
      diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
      diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
      for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
        if (diagonal === diagonalReverseStart || diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
          originalIndex = reversePoints[diagonal + 1] - 1;
        } else {
          originalIndex = reversePoints[diagonal - 1];
        }
        modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
        const tempOriginalIndex = originalIndex;
        while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
          originalIndex--;
          modifiedIndex--;
        }
        reversePoints[diagonal] = originalIndex;
        if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
          if (originalIndex <= forwardPoints[diagonal]) {
            midOriginalArr[0] = originalIndex;
            midModifiedArr[0] = modifiedIndex;
            if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
            } else {
              return null;
            }
          }
        }
      }
      if (numDifferences <= 1447) {
        let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);
        temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
        MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
        this.m_forwardHistory.push(temp);
        temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);
        temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
        MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
        this.m_reverseHistory.push(temp);
      }
    }
    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
  }
  /**
   * Shifts the given changes to provide a more intuitive diff.
   * While the first element in a diff matches the first element after the diff,
   * we shift the diff down.
   *
   * @param changes The list of changes to shift
   * @returns The shifted changes
   */
  PrettifyChanges(changes) {
    for (let i = 0; i < changes.length; i++) {
      const change = changes[i];
      const originalStop = i < changes.length - 1 ? changes[i + 1].originalStart : this._originalElementsOrHash.length;
      const modifiedStop = i < changes.length - 1 ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;
      const checkOriginal = change.originalLength > 0;
      const checkModified = change.modifiedLength > 0;
      while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {
        const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);
        const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);
        if (endStrictEqual && !startStrictEqual) {
          break;
        }
        change.originalStart++;
        change.modifiedStart++;
      }
      const mergedChangeArr = [null];
      if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {
        changes[i] = mergedChangeArr[0];
        changes.splice(i + 1, 1);
        i--;
        continue;
      }
    }
    for (let i = changes.length - 1; i >= 0; i--) {
      const change = changes[i];
      let originalStop = 0;
      let modifiedStop = 0;
      if (i > 0) {
        const prevChange = changes[i - 1];
        originalStop = prevChange.originalStart + prevChange.originalLength;
        modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;
      }
      const checkOriginal = change.originalLength > 0;
      const checkModified = change.modifiedLength > 0;
      let bestDelta = 0;
      let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);
      for (let delta = 1; ; delta++) {
        const originalStart = change.originalStart - delta;
        const modifiedStart = change.modifiedStart - delta;
        if (originalStart < originalStop || modifiedStart < modifiedStop) {
          break;
        }
        if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
          break;
        }
        if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
          break;
        }
        const touchingPreviousChange = originalStart === originalStop && modifiedStart === modifiedStop;
        const score2 = (touchingPreviousChange ? 5 : 0) + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);
        if (score2 > bestScore) {
          bestScore = score2;
          bestDelta = delta;
        }
      }
      change.originalStart -= bestDelta;
      change.modifiedStart -= bestDelta;
      const mergedChangeArr = [null];
      if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {
        changes[i - 1] = mergedChangeArr[0];
        changes.splice(i, 1);
        i++;
        continue;
      }
    }
    if (this._hasStrings) {
      for (let i = 1, len = changes.length; i < len; i++) {
        const aChange = changes[i - 1];
        const bChange = changes[i];
        const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;
        const aOriginalStart = aChange.originalStart;
        const bOriginalEnd = bChange.originalStart + bChange.originalLength;
        const abOriginalLength = bOriginalEnd - aOriginalStart;
        const aModifiedStart = aChange.modifiedStart;
        const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;
        const abModifiedLength = bModifiedEnd - aModifiedStart;
        if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {
          const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);
          if (t) {
            const [originalMatchStart, modifiedMatchStart] = t;
            if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {
              aChange.originalLength = originalMatchStart - aChange.originalStart;
              aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;
              bChange.originalStart = originalMatchStart + matchedLength;
              bChange.modifiedStart = modifiedMatchStart + matchedLength;
              bChange.originalLength = bOriginalEnd - bChange.originalStart;
              bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;
            }
          }
        }
      }
    }
    return changes;
  }
  _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {
    if (originalLength < desiredLength || modifiedLength < desiredLength) {
      return null;
    }
    const originalMax = originalStart + originalLength - desiredLength + 1;
    const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;
    let bestScore = 0;
    let bestOriginalStart = 0;
    let bestModifiedStart = 0;
    for (let i = originalStart; i < originalMax; i++) {
      for (let j = modifiedStart; j < modifiedMax; j++) {
        const score2 = this._contiguousSequenceScore(i, j, desiredLength);
        if (score2 > 0 && score2 > bestScore) {
          bestScore = score2;
          bestOriginalStart = i;
          bestModifiedStart = j;
        }
      }
    }
    if (bestScore > 0) {
      return [bestOriginalStart, bestModifiedStart];
    }
    return null;
  }
  _contiguousSequenceScore(originalStart, modifiedStart, length) {
    let score2 = 0;
    for (let l = 0; l < length; l++) {
      if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {
        return 0;
      }
      score2 += this._originalStringElements[originalStart + l].length;
    }
    return score2;
  }
  _OriginalIsBoundary(index) {
    if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {
      return true;
    }
    return this._hasStrings && /^\s*$/.test(this._originalStringElements[index]);
  }
  _OriginalRegionIsBoundary(originalStart, originalLength) {
    if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {
      return true;
    }
    if (originalLength > 0) {
      const originalEnd = originalStart + originalLength;
      if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {
        return true;
      }
    }
    return false;
  }
  _ModifiedIsBoundary(index) {
    if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {
      return true;
    }
    return this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index]);
  }
  _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {
    if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {
      return true;
    }
    if (modifiedLength > 0) {
      const modifiedEnd = modifiedStart + modifiedLength;
      if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {
        return true;
      }
    }
    return false;
  }
  _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {
    const originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;
    const modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;
    return originalScore + modifiedScore;
  }
  /**
   * Concatenates the two input DiffChange lists and returns the resulting
   * list.
   * @param The left changes
   * @param The right changes
   * @returns The concatenated list
   */
  ConcatenateChanges(left, right) {
    const mergedChangeArr = [];
    if (left.length === 0 || right.length === 0) {
      return right.length > 0 ? right : left;
    } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
      const result = new Array(left.length + right.length - 1);
      MyArray.Copy(left, 0, result, 0, left.length - 1);
      result[left.length - 1] = mergedChangeArr[0];
      MyArray.Copy(right, 1, result, left.length, right.length - 1);
      return result;
    } else {
      const result = new Array(left.length + right.length);
      MyArray.Copy(left, 0, result, 0, left.length);
      MyArray.Copy(right, 0, result, left.length, right.length);
      return result;
    }
  }
  /**
   * Returns true if the two changes overlap and can be merged into a single
   * change
   * @param left The left change
   * @param right The right change
   * @param mergedChange The merged change if the two overlap, null otherwise
   * @returns True if the two changes overlap
   */
  ChangesOverlap(left, right, mergedChangeArr) {
    Debug.Assert(left.originalStart <= right.originalStart, "Left change is not less than or equal to right change");
    Debug.Assert(left.modifiedStart <= right.modifiedStart, "Left change is not less than or equal to right change");
    if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
      const originalStart = left.originalStart;
      let originalLength = left.originalLength;
      const modifiedStart = left.modifiedStart;
      let modifiedLength = left.modifiedLength;
      if (left.originalStart + left.originalLength >= right.originalStart) {
        originalLength = right.originalStart + right.originalLength - left.originalStart;
      }
      if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
        modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
      }
      mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
      return true;
    } else {
      mergedChangeArr[0] = null;
      return false;
    }
  }
  /**
   * Helper method used to clip a diagonal index to the range of valid
   * diagonals. This also decides whether or not the diagonal index,
   * if it exceeds the boundary, should be clipped to the boundary or clipped
   * one inside the boundary depending on the Even/Odd status of the boundary
   * and numDifferences.
   * @param diagonal The index of the diagonal to clip.
   * @param numDifferences The current number of differences being iterated upon.
   * @param diagonalBaseIndex The base reference diagonal.
   * @param numDiagonals The total number of diagonals.
   * @returns The clipped diagonal index.
   */
  ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
    if (diagonal >= 0 && diagonal < numDiagonals) {
      return diagonal;
    }
    const diagonalsBelow = diagonalBaseIndex;
    const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
    const diffEven = numDifferences % 2 === 0;
    if (diagonal < 0) {
      const lowerBoundEven = diagonalsBelow % 2 === 0;
      return diffEven === lowerBoundEven ? 0 : 1;
    } else {
      const upperBoundEven = diagonalsAbove % 2 === 0;
      return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;
    }
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/process.js
var safeProcess;
var vscodeGlobal = globalThis.vscode;
if (typeof vscodeGlobal !== "undefined" && typeof vscodeGlobal.process !== "undefined") {
  const sandboxProcess = vscodeGlobal.process;
  safeProcess = {
    get platform() {
      return sandboxProcess.platform;
    },
    get arch() {
      return sandboxProcess.arch;
    },
    get env() {
      return sandboxProcess.env;
    },
    cwd() {
      return sandboxProcess.cwd();
    }
  };
} else if (typeof process !== "undefined") {
  safeProcess = {
    get platform() {
      return process.platform;
    },
    get arch() {
      return process.arch;
    },
    get env() {
      return process.env;
    },
    cwd() {
      return process.env["VSCODE_CWD"] || process.cwd();
    }
  };
} else {
  safeProcess = {
    // Supported
    get platform() {
      return isWindows ? "win32" : isMacintosh ? "darwin" : "linux";
    },
    get arch() {
      return void 0;
    },
    // Unsupported
    get env() {
      return {};
    },
    cwd() {
      return "/";
    }
  };
}
var cwd = safeProcess.cwd;
var env = safeProcess.env;
var platform = safeProcess.platform;

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/path.js
var CHAR_UPPERCASE_A = 65;
var CHAR_LOWERCASE_A = 97;
var CHAR_UPPERCASE_Z = 90;
var CHAR_LOWERCASE_Z = 122;
var CHAR_DOT = 46;
var CHAR_FORWARD_SLASH = 47;
var CHAR_BACKWARD_SLASH = 92;
var CHAR_COLON = 58;
var CHAR_QUESTION_MARK = 63;
var ErrorInvalidArgType = class extends Error {
  constructor(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && expected.indexOf("not ") === 0) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    const type = name.indexOf(".") !== -1 ? "property" : "argument";
    let msg = `The "${name}" ${type} ${determiner} of type ${expected}`;
    msg += `. Received type ${typeof actual}`;
    super(msg);
    this.code = "ERR_INVALID_ARG_TYPE";
  }
};
function validateObject(pathObject, name) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new ErrorInvalidArgType(name, "Object", pathObject);
  }
}
function validateString(value, name) {
  if (typeof value !== "string") {
    throw new ErrorInvalidArgType(name, "string", value);
  }
}
var platformIsWin32 = platform === "win32";
function isPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
}
function isPosixPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH;
}
function isWindowsDeviceRoot(code) {
  return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;
}
function normalizeString(path5, allowAboveRoot, separator, isPathSeparator2) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = 0;
  for (let i = 0; i <= path5.length; ++i) {
    if (i < path5.length) {
      code = path5.charCodeAt(i);
    } else if (isPathSeparator2(code)) {
      break;
    } else {
      code = CHAR_FORWARD_SLASH;
    }
    if (isPathSeparator2(code)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length !== 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? `${separator}..` : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `${separator}${path5.slice(lastSlash + 1, i)}`;
        } else {
          res = path5.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === CHAR_DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format2(sep2, pathObject) {
  validateObject(pathObject, "pathObject");
  const dir = pathObject.dir || pathObject.root;
  const base = pathObject.base || `${pathObject.name || ""}${pathObject.ext || ""}`;
  if (!dir) {
    return base;
  }
  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep2}${base}`;
}
var win32 = {
  // path.resolve([from ...], to)
  resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for (let i = pathSegments.length - 1; i >= -1; i--) {
      let path5;
      if (i >= 0) {
        path5 = pathSegments[i];
        validateString(path5, "path");
        if (path5.length === 0) {
          continue;
        }
      } else if (resolvedDevice.length === 0) {
        path5 = cwd();
      } else {
        path5 = env[`=${resolvedDevice}`] || cwd();
        if (path5 === void 0 || path5.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path5.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
          path5 = `${resolvedDevice}\\`;
        }
      }
      const len = path5.length;
      let rootEnd = 0;
      let device = "";
      let isAbsolute2 = false;
      const code = path5.charCodeAt(0);
      if (len === 1) {
        if (isPathSeparator(code)) {
          rootEnd = 1;
          isAbsolute2 = true;
        }
      } else if (isPathSeparator(code)) {
        isAbsolute2 = true;
        if (isPathSeparator(path5.charCodeAt(1))) {
          let j = 2;
          let last = j;
          while (j < len && !isPathSeparator(path5.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            const firstPart = path5.slice(last, j);
            last = j;
            while (j < len && isPathSeparator(path5.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              last = j;
              while (j < len && !isPathSeparator(path5.charCodeAt(j))) {
                j++;
              }
              if (j === len || j !== last) {
                device = `\\\\${firstPart}\\${path5.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code) && path5.charCodeAt(1) === CHAR_COLON) {
        device = path5.slice(0, 2);
        rootEnd = 2;
        if (len > 2 && isPathSeparator(path5.charCodeAt(2))) {
          isAbsolute2 = true;
          rootEnd = 3;
        }
      }
      if (device.length > 0) {
        if (resolvedDevice.length > 0) {
          if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
          }
        } else {
          resolvedDevice = device;
        }
      }
      if (resolvedAbsolute) {
        if (resolvedDevice.length > 0) {
          break;
        }
      } else {
        resolvedTail = `${path5.slice(rootEnd)}\\${resolvedTail}`;
        resolvedAbsolute = isAbsolute2;
        if (isAbsolute2 && resolvedDevice.length > 0) {
          break;
        }
      }
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || ".";
  },
  normalize(path5) {
    validateString(path5, "path");
    const len = path5.length;
    if (len === 0) {
      return ".";
    }
    let rootEnd = 0;
    let device;
    let isAbsolute2 = false;
    const code = path5.charCodeAt(0);
    if (len === 1) {
      return isPosixPathSeparator(code) ? "\\" : path5;
    }
    if (isPathSeparator(code)) {
      isAbsolute2 = true;
      if (isPathSeparator(path5.charCodeAt(1))) {
        let j = 2;
        let last = j;
        while (j < len && !isPathSeparator(path5.charCodeAt(j))) {
          j++;
        }
        if (j < len && j !== last) {
          const firstPart = path5.slice(last, j);
          last = j;
          while (j < len && isPathSeparator(path5.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && !isPathSeparator(path5.charCodeAt(j))) {
              j++;
            }
            if (j === len) {
              return `\\\\${firstPart}\\${path5.slice(last)}\\`;
            }
            if (j !== last) {
              device = `\\\\${firstPart}\\${path5.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot(code) && path5.charCodeAt(1) === CHAR_COLON) {
      device = path5.slice(0, 2);
      rootEnd = 2;
      if (len > 2 && isPathSeparator(path5.charCodeAt(2))) {
        isAbsolute2 = true;
        rootEnd = 3;
      }
    }
    let tail = rootEnd < len ? normalizeString(path5.slice(rootEnd), !isAbsolute2, "\\", isPathSeparator) : "";
    if (tail.length === 0 && !isAbsolute2) {
      tail = ".";
    }
    if (tail.length > 0 && isPathSeparator(path5.charCodeAt(len - 1))) {
      tail += "\\";
    }
    if (device === void 0) {
      return isAbsolute2 ? `\\${tail}` : tail;
    }
    return isAbsolute2 ? `${device}\\${tail}` : `${device}${tail}`;
  },
  isAbsolute(path5) {
    validateString(path5, "path");
    const len = path5.length;
    if (len === 0) {
      return false;
    }
    const code = path5.charCodeAt(0);
    return isPathSeparator(code) || // Possible device root
    len > 2 && isWindowsDeviceRoot(code) && path5.charCodeAt(1) === CHAR_COLON && isPathSeparator(path5.charCodeAt(2));
  },
  join(...paths) {
    if (paths.length === 0) {
      return ".";
    }
    let joined;
    let firstPart;
    for (let i = 0; i < paths.length; ++i) {
      const arg = paths[i];
      validateString(arg, "path");
      if (arg.length > 0) {
        if (joined === void 0) {
          joined = firstPart = arg;
        } else {
          joined += `\\${arg}`;
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    let needsReplace = true;
    let slashCount = 0;
    if (typeof firstPart === "string" && isPathSeparator(firstPart.charCodeAt(0))) {
      ++slashCount;
      const firstLen = firstPart.length;
      if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator(firstPart.charCodeAt(2))) {
            ++slashCount;
          } else {
            needsReplace = false;
          }
        }
      }
    }
    if (needsReplace) {
      while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {
        slashCount++;
      }
      if (slashCount >= 2) {
        joined = `\\${joined.slice(slashCount)}`;
      }
    }
    return win32.normalize(joined);
  },
  // It will solve the relative path from `from` to `to`, for instance:
  //  from = 'C:\\orandea\\test\\aaa'
  //  to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  relative(from, to) {
    validateString(from, "from");
    validateString(to, "to");
    if (from === to) {
      return "";
    }
    const fromOrig = win32.resolve(from);
    const toOrig = win32.resolve(to);
    if (fromOrig === toOrig) {
      return "";
    }
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) {
      return "";
    }
    let fromStart = 0;
    while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
      fromStart++;
    }
    let fromEnd = from.length;
    while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
      fromEnd--;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
      toStart++;
    }
    let toEnd = to.length;
    while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
      toEnd--;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for (; i < length; i++) {
      const fromCode = from.charCodeAt(fromStart + i);
      if (fromCode !== to.charCodeAt(toStart + i)) {
        break;
      } else if (fromCode === CHAR_BACKWARD_SLASH) {
        lastCommonSep = i;
      }
    }
    if (i !== length) {
      if (lastCommonSep === -1) {
        return toOrig;
      }
    } else {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
          return toOrig.slice(toStart + i + 1);
        }
        if (i === 2) {
          return toOrig.slice(toStart + i);
        }
      }
      if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
          lastCommonSep = i;
        } else if (i === 2) {
          lastCommonSep = 3;
        }
      }
      if (lastCommonSep === -1) {
        lastCommonSep = 0;
      }
    }
    let out = "";
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
        out += out.length === 0 ? ".." : "\\..";
      }
    }
    toStart += lastCommonSep;
    if (out.length > 0) {
      return `${out}${toOrig.slice(toStart, toEnd)}`;
    }
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
      ++toStart;
    }
    return toOrig.slice(toStart, toEnd);
  },
  toNamespacedPath(path5) {
    if (typeof path5 !== "string" || path5.length === 0) {
      return path5;
    }
    const resolvedPath = win32.resolve(path5);
    if (resolvedPath.length <= 2) {
      return path5;
    }
    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
        const code = resolvedPath.charCodeAt(2);
        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
      return `\\\\?\\${resolvedPath}`;
    }
    return path5;
  },
  dirname(path5) {
    validateString(path5, "path");
    const len = path5.length;
    if (len === 0) {
      return ".";
    }
    let rootEnd = -1;
    let offset = 0;
    const code = path5.charCodeAt(0);
    if (len === 1) {
      return isPathSeparator(code) ? path5 : ".";
    }
    if (isPathSeparator(code)) {
      rootEnd = offset = 1;
      if (isPathSeparator(path5.charCodeAt(1))) {
        let j = 2;
        let last = j;
        while (j < len && !isPathSeparator(path5.charCodeAt(j))) {
          j++;
        }
        if (j < len && j !== last) {
          last = j;
          while (j < len && isPathSeparator(path5.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && !isPathSeparator(path5.charCodeAt(j))) {
              j++;
            }
            if (j === len) {
              return path5;
            }
            if (j !== last) {
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code) && path5.charCodeAt(1) === CHAR_COLON) {
      rootEnd = len > 2 && isPathSeparator(path5.charCodeAt(2)) ? 3 : 2;
      offset = rootEnd;
    }
    let end = -1;
    let matchedSlash = true;
    for (let i = len - 1; i >= offset; --i) {
      if (isPathSeparator(path5.charCodeAt(i))) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1) {
      if (rootEnd === -1) {
        return ".";
      }
      end = rootEnd;
    }
    return path5.slice(0, end);
  },
  basename(path5, ext) {
    if (ext !== void 0) {
      validateString(ext, "ext");
    }
    validateString(path5, "path");
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path5.length >= 2 && isWindowsDeviceRoot(path5.charCodeAt(0)) && path5.charCodeAt(1) === CHAR_COLON) {
      start = 2;
    }
    if (ext !== void 0 && ext.length > 0 && ext.length <= path5.length) {
      if (ext === path5) {
        return "";
      }
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path5.length - 1; i >= start; --i) {
        const code = path5.charCodeAt(i);
        if (isPathSeparator(code)) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end) {
        end = firstNonSlashEnd;
      } else if (end === -1) {
        end = path5.length;
      }
      return path5.slice(start, end);
    }
    for (i = path5.length - 1; i >= start; --i) {
      if (isPathSeparator(path5.charCodeAt(i))) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1) {
      return "";
    }
    return path5.slice(start, end);
  },
  extname(path5) {
    validateString(path5, "path");
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path5.length >= 2 && path5.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path5.charCodeAt(0))) {
      start = startPart = 2;
    }
    for (let i = path5.length - 1; i >= start; --i) {
      const code = path5.charCodeAt(i);
      if (isPathSeparator(code)) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path5.slice(startDot, end);
  },
  format: _format2.bind(null, "\\"),
  parse(path5) {
    validateString(path5, "path");
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path5.length === 0) {
      return ret;
    }
    const len = path5.length;
    let rootEnd = 0;
    let code = path5.charCodeAt(0);
    if (len === 1) {
      if (isPathSeparator(code)) {
        ret.root = ret.dir = path5;
        return ret;
      }
      ret.base = ret.name = path5;
      return ret;
    }
    if (isPathSeparator(code)) {
      rootEnd = 1;
      if (isPathSeparator(path5.charCodeAt(1))) {
        let j = 2;
        let last = j;
        while (j < len && !isPathSeparator(path5.charCodeAt(j))) {
          j++;
        }
        if (j < len && j !== last) {
          last = j;
          while (j < len && isPathSeparator(path5.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && !isPathSeparator(path5.charCodeAt(j))) {
              j++;
            }
            if (j === len) {
              rootEnd = j;
            } else if (j !== last) {
              rootEnd = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code) && path5.charCodeAt(1) === CHAR_COLON) {
      if (len <= 2) {
        ret.root = ret.dir = path5;
        return ret;
      }
      rootEnd = 2;
      if (isPathSeparator(path5.charCodeAt(2))) {
        if (len === 3) {
          ret.root = ret.dir = path5;
          return ret;
        }
        rootEnd = 3;
      }
    }
    if (rootEnd > 0) {
      ret.root = path5.slice(0, rootEnd);
    }
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path5.length - 1;
    let preDotState = 0;
    for (; i >= rootEnd; --i) {
      code = path5.charCodeAt(i);
      if (isPathSeparator(code)) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (end !== -1) {
      if (startDot === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        ret.base = ret.name = path5.slice(startPart, end);
      } else {
        ret.name = path5.slice(startPart, startDot);
        ret.base = path5.slice(startPart, end);
        ret.ext = path5.slice(startDot, end);
      }
    }
    if (startPart > 0 && startPart !== rootEnd) {
      ret.dir = path5.slice(0, startPart - 1);
    } else {
      ret.dir = ret.root;
    }
    return ret;
  },
  sep: "\\",
  delimiter: ";",
  win32: null,
  posix: null
};
var posixCwd = (() => {
  if (platformIsWin32) {
    const regexp = /\\/g;
    return () => {
      const cwd2 = cwd().replace(regexp, "/");
      return cwd2.slice(cwd2.indexOf("/"));
    };
  }
  return () => cwd();
})();
var posix = {
  // path.resolve([from ...], to)
  resolve(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      const path5 = i >= 0 ? pathSegments[i] : posixCwd();
      validateString(path5, "path");
      if (path5.length === 0) {
        continue;
      }
      resolvedPath = `${path5}/${resolvedPath}`;
      resolvedAbsolute = path5.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
      return `/${resolvedPath}`;
    }
    return resolvedPath.length > 0 ? resolvedPath : ".";
  },
  normalize(path5) {
    validateString(path5, "path");
    if (path5.length === 0) {
      return ".";
    }
    const isAbsolute2 = path5.charCodeAt(0) === CHAR_FORWARD_SLASH;
    const trailingSeparator = path5.charCodeAt(path5.length - 1) === CHAR_FORWARD_SLASH;
    path5 = normalizeString(path5, !isAbsolute2, "/", isPosixPathSeparator);
    if (path5.length === 0) {
      if (isAbsolute2) {
        return "/";
      }
      return trailingSeparator ? "./" : ".";
    }
    if (trailingSeparator) {
      path5 += "/";
    }
    return isAbsolute2 ? `/${path5}` : path5;
  },
  isAbsolute(path5) {
    validateString(path5, "path");
    return path5.length > 0 && path5.charCodeAt(0) === CHAR_FORWARD_SLASH;
  },
  join(...paths) {
    if (paths.length === 0) {
      return ".";
    }
    let joined;
    for (let i = 0; i < paths.length; ++i) {
      const arg = paths[i];
      validateString(arg, "path");
      if (arg.length > 0) {
        if (joined === void 0) {
          joined = arg;
        } else {
          joined += `/${arg}`;
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    return posix.normalize(joined);
  },
  relative(from, to) {
    validateString(from, "from");
    validateString(to, "to");
    if (from === to) {
      return "";
    }
    from = posix.resolve(from);
    to = posix.resolve(to);
    if (from === to) {
      return "";
    }
    const fromStart = 1;
    const fromEnd = from.length;
    const fromLen = fromEnd - fromStart;
    const toStart = 1;
    const toLen = to.length - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for (; i < length; i++) {
      const fromCode = from.charCodeAt(fromStart + i);
      if (fromCode !== to.charCodeAt(toStart + i)) {
        break;
      } else if (fromCode === CHAR_FORWARD_SLASH) {
        lastCommonSep = i;
      }
    }
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
          return to.slice(toStart + i + 1);
        }
        if (i === 0) {
          return to.slice(toStart + i);
        }
      } else if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
          lastCommonSep = i;
        } else if (i === 0) {
          lastCommonSep = 0;
        }
      }
    }
    let out = "";
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        out += out.length === 0 ? ".." : "/..";
      }
    }
    return `${out}${to.slice(toStart + lastCommonSep)}`;
  },
  toNamespacedPath(path5) {
    return path5;
  },
  dirname(path5) {
    validateString(path5, "path");
    if (path5.length === 0) {
      return ".";
    }
    const hasRoot = path5.charCodeAt(0) === CHAR_FORWARD_SLASH;
    let end = -1;
    let matchedSlash = true;
    for (let i = path5.length - 1; i >= 1; --i) {
      if (path5.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1) {
      return hasRoot ? "/" : ".";
    }
    if (hasRoot && end === 1) {
      return "//";
    }
    return path5.slice(0, end);
  },
  basename(path5, ext) {
    if (ext !== void 0) {
      validateString(ext, "ext");
    }
    validateString(path5, "path");
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path5.length) {
      if (ext === path5) {
        return "";
      }
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path5.length - 1; i >= 0; --i) {
        const code = path5.charCodeAt(i);
        if (code === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end) {
        end = firstNonSlashEnd;
      } else if (end === -1) {
        end = path5.length;
      }
      return path5.slice(start, end);
    }
    for (i = path5.length - 1; i >= 0; --i) {
      if (path5.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1) {
      return "";
    }
    return path5.slice(start, end);
  },
  extname(path5) {
    validateString(path5, "path");
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i = path5.length - 1; i >= 0; --i) {
      const code = path5.charCodeAt(i);
      if (code === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path5.slice(startDot, end);
  },
  format: _format2.bind(null, "/"),
  parse(path5) {
    validateString(path5, "path");
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path5.length === 0) {
      return ret;
    }
    const isAbsolute2 = path5.charCodeAt(0) === CHAR_FORWARD_SLASH;
    let start;
    if (isAbsolute2) {
      ret.root = "/";
      start = 1;
    } else {
      start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path5.length - 1;
    let preDotState = 0;
    for (; i >= start; --i) {
      const code = path5.charCodeAt(i);
      if (code === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (end !== -1) {
      const start2 = startPart === 0 && isAbsolute2 ? 1 : startPart;
      if (startDot === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        ret.base = ret.name = path5.slice(start2, end);
      } else {
        ret.name = path5.slice(start2, startDot);
        ret.base = path5.slice(start2, end);
        ret.ext = path5.slice(startDot, end);
      }
    }
    if (startPart > 0) {
      ret.dir = path5.slice(0, startPart - 1);
    } else if (isAbsolute2) {
      ret.dir = "/";
    }
    return ret;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
posix.win32 = win32.win32 = win32;
posix.posix = win32.posix = posix;
var normalize = platformIsWin32 ? win32.normalize : posix.normalize;
var resolve = platformIsWin32 ? win32.resolve : posix.resolve;
var relative = platformIsWin32 ? win32.relative : posix.relative;
var dirname = platformIsWin32 ? win32.dirname : posix.dirname;
var basename = platformIsWin32 ? win32.basename : posix.basename;
var extname = platformIsWin32 ? win32.extname : posix.extname;
var sep = platformIsWin32 ? win32.sep : posix.sep;

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/uri.js
var _schemePattern = /^\w[\w\d+.-]*$/;
var _singleSlashStart = /^\//;
var _doubleSlashStart = /^\/\//;
function _validateUri(ret, _strict) {
  if (!ret.scheme && _strict) {
    throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
  }
  if (ret.scheme && !_schemePattern.test(ret.scheme)) {
    throw new Error("[UriError]: Scheme contains illegal characters.");
  }
  if (ret.path) {
    if (ret.authority) {
      if (!_singleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      }
    } else {
      if (_doubleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
  }
}
function _schemeFix(scheme, _strict) {
  if (!scheme && !_strict) {
    return "file";
  }
  return scheme;
}
function _referenceResolution(scheme, path5) {
  switch (scheme) {
    case "https":
    case "http":
    case "file":
      if (!path5) {
        path5 = _slash;
      } else if (path5[0] !== _slash) {
        path5 = _slash + path5;
      }
      break;
  }
  return path5;
}
var _empty = "";
var _slash = "/";
var _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
var URI = class _URI {
  static isUri(thing) {
    if (thing instanceof _URI) {
      return true;
    }
    if (!thing) {
      return false;
    }
    return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "string" && typeof thing.with === "function" && typeof thing.toString === "function";
  }
  /**
   * @internal
   */
  constructor(schemeOrData, authority, path5, query, fragment, _strict = false) {
    if (typeof schemeOrData === "object") {
      this.scheme = schemeOrData.scheme || _empty;
      this.authority = schemeOrData.authority || _empty;
      this.path = schemeOrData.path || _empty;
      this.query = schemeOrData.query || _empty;
      this.fragment = schemeOrData.fragment || _empty;
    } else {
      this.scheme = _schemeFix(schemeOrData, _strict);
      this.authority = authority || _empty;
      this.path = _referenceResolution(this.scheme, path5 || _empty);
      this.query = query || _empty;
      this.fragment = fragment || _empty;
      _validateUri(this, _strict);
    }
  }
  // ---- filesystem path -----------------------
  /**
   * Returns a string representing the corresponding file system path of this URI.
   * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
   * platform specific path separator.
   *
   * * Will *not* validate the path for invalid characters and semantics.
   * * Will *not* look at the scheme of this URI.
   * * The result shall *not* be used for display purposes but for accessing a file on disk.
   *
   *
   * The *difference* to `URI#path` is the use of the platform specific separator and the handling
   * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
   *
   * ```ts
      const u = URI.parse('file://server/c$/folder/file.txt')
      u.authority === 'server'
      u.path === '/shares/c$/file.txt'
      u.fsPath === '\\server\c$\folder\file.txt'
  ```
   *
   * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
   * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
   * with URIs that represent files on disk (`file` scheme).
   */
  get fsPath() {
    return uriToFsPath(this, false);
  }
  // ---- modify to new -------------------------
  with(change) {
    if (!change) {
      return this;
    }
    let { scheme, authority, path: path5, query, fragment } = change;
    if (scheme === void 0) {
      scheme = this.scheme;
    } else if (scheme === null) {
      scheme = _empty;
    }
    if (authority === void 0) {
      authority = this.authority;
    } else if (authority === null) {
      authority = _empty;
    }
    if (path5 === void 0) {
      path5 = this.path;
    } else if (path5 === null) {
      path5 = _empty;
    }
    if (query === void 0) {
      query = this.query;
    } else if (query === null) {
      query = _empty;
    }
    if (fragment === void 0) {
      fragment = this.fragment;
    } else if (fragment === null) {
      fragment = _empty;
    }
    if (scheme === this.scheme && authority === this.authority && path5 === this.path && query === this.query && fragment === this.fragment) {
      return this;
    }
    return new Uri(scheme, authority, path5, query, fragment);
  }
  // ---- parse & validate ------------------------
  /**
   * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
   * `file:///usr/home`, or `scheme:with/path`.
   *
   * @param value A string which represents an URI (see `URI#toString`).
   */
  static parse(value, _strict = false) {
    const match = _regexp.exec(value);
    if (!match) {
      return new Uri(_empty, _empty, _empty, _empty, _empty);
    }
    return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
  }
  /**
   * Creates a new URI from a file system path, e.g. `c:\my\files`,
   * `/usr/home`, or `\\server\share\some\path`.
   *
   * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
   * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
   * `URI.parse('file://' + path)` because the path might contain characters that are
   * interpreted (# and ?). See the following sample:
   * ```ts
  const good = URI.file('/coding/c#/project1');
  good.scheme === 'file';
  good.path === '/coding/c#/project1';
  good.fragment === '';
  const bad = URI.parse('file://' + '/coding/c#/project1');
  bad.scheme === 'file';
  bad.path === '/coding/c'; // path is now broken
  bad.fragment === '/project1';
  ```
   *
   * @param path A file system path (see `URI#fsPath`)
   */
  static file(path5) {
    let authority = _empty;
    if (isWindows) {
      path5 = path5.replace(/\\/g, _slash);
    }
    if (path5[0] === _slash && path5[1] === _slash) {
      const idx = path5.indexOf(_slash, 2);
      if (idx === -1) {
        authority = path5.substring(2);
        path5 = _slash;
      } else {
        authority = path5.substring(2, idx);
        path5 = path5.substring(idx) || _slash;
      }
    }
    return new Uri("file", authority, path5, _empty, _empty);
  }
  /**
   * Creates new URI from uri components.
   *
   * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs
   * validation and should be used for untrusted uri components retrieved from storage,
   * user input, command arguments etc
   */
  static from(components, strict) {
    const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment, strict);
    return result;
  }
  /**
   * Join a URI path with path fragments and normalizes the resulting path.
   *
   * @param uri The input URI.
   * @param pathFragment The path fragment to add to the URI path.
   * @returns The resulting URI.
   */
  static joinPath(uri, ...pathFragment) {
    if (!uri.path) {
      throw new Error(`[UriError]: cannot call joinPath on URI without path`);
    }
    let newPath;
    if (isWindows && uri.scheme === "file") {
      newPath = _URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
    } else {
      newPath = posix.join(uri.path, ...pathFragment);
    }
    return uri.with({ path: newPath });
  }
  // ---- printing/externalize ---------------------------
  /**
   * Creates a string representation for this URI. It's guaranteed that calling
   * `URI.parse` with the result of this function creates an URI which is equal
   * to this URI.
   *
   * * The result shall *not* be used for display purposes but for externalization or transport.
   * * The result will be encoded using the percentage encoding and encoding happens mostly
   * ignore the scheme-specific encoding rules.
   *
   * @param skipEncoding Do not encode the result, default is `false`
   */
  toString(skipEncoding = false) {
    return _asFormatted(this, skipEncoding);
  }
  toJSON() {
    return this;
  }
  static revive(data) {
    var _a4, _b2;
    if (!data) {
      return data;
    } else if (data instanceof _URI) {
      return data;
    } else {
      const result = new Uri(data);
      result._formatted = (_a4 = data.external) !== null && _a4 !== void 0 ? _a4 : null;
      result._fsPath = data._sep === _pathSepMarker ? (_b2 = data.fsPath) !== null && _b2 !== void 0 ? _b2 : null : null;
      return result;
    }
  }
};
var _pathSepMarker = isWindows ? 1 : void 0;
var Uri = class extends URI {
  constructor() {
    super(...arguments);
    this._formatted = null;
    this._fsPath = null;
  }
  get fsPath() {
    if (!this._fsPath) {
      this._fsPath = uriToFsPath(this, false);
    }
    return this._fsPath;
  }
  toString(skipEncoding = false) {
    if (!skipEncoding) {
      if (!this._formatted) {
        this._formatted = _asFormatted(this, false);
      }
      return this._formatted;
    } else {
      return _asFormatted(this, true);
    }
  }
  toJSON() {
    const res = {
      $mid: 1
      /* MarshalledId.Uri */
    };
    if (this._fsPath) {
      res.fsPath = this._fsPath;
      res._sep = _pathSepMarker;
    }
    if (this._formatted) {
      res.external = this._formatted;
    }
    if (this.path) {
      res.path = this.path;
    }
    if (this.scheme) {
      res.scheme = this.scheme;
    }
    if (this.authority) {
      res.authority = this.authority;
    }
    if (this.query) {
      res.query = this.query;
    }
    if (this.fragment) {
      res.fragment = this.fragment;
    }
    return res;
  }
};
var encodeTable = {
  [
    58
    /* CharCode.Colon */
  ]: "%3A",
  // gen-delims
  [
    47
    /* CharCode.Slash */
  ]: "%2F",
  [
    63
    /* CharCode.QuestionMark */
  ]: "%3F",
  [
    35
    /* CharCode.Hash */
  ]: "%23",
  [
    91
    /* CharCode.OpenSquareBracket */
  ]: "%5B",
  [
    93
    /* CharCode.CloseSquareBracket */
  ]: "%5D",
  [
    64
    /* CharCode.AtSign */
  ]: "%40",
  [
    33
    /* CharCode.ExclamationMark */
  ]: "%21",
  // sub-delims
  [
    36
    /* CharCode.DollarSign */
  ]: "%24",
  [
    38
    /* CharCode.Ampersand */
  ]: "%26",
  [
    39
    /* CharCode.SingleQuote */
  ]: "%27",
  [
    40
    /* CharCode.OpenParen */
  ]: "%28",
  [
    41
    /* CharCode.CloseParen */
  ]: "%29",
  [
    42
    /* CharCode.Asterisk */
  ]: "%2A",
  [
    43
    /* CharCode.Plus */
  ]: "%2B",
  [
    44
    /* CharCode.Comma */
  ]: "%2C",
  [
    59
    /* CharCode.Semicolon */
  ]: "%3B",
  [
    61
    /* CharCode.Equals */
  ]: "%3D",
  [
    32
    /* CharCode.Space */
  ]: "%20"
};
function encodeURIComponentFast(uriComponent, isPath, isAuthority) {
  let res = void 0;
  let nativeEncodePos = -1;
  for (let pos = 0; pos < uriComponent.length; pos++) {
    const code = uriComponent.charCodeAt(pos);
    if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || isPath && code === 47 || isAuthority && code === 91 || isAuthority && code === 93 || isAuthority && code === 58) {
      if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
        nativeEncodePos = -1;
      }
      if (res !== void 0) {
        res += uriComponent.charAt(pos);
      }
    } else {
      if (res === void 0) {
        res = uriComponent.substr(0, pos);
      }
      const escaped = encodeTable[code];
      if (escaped !== void 0) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        res += escaped;
      } else if (nativeEncodePos === -1) {
        nativeEncodePos = pos;
      }
    }
  }
  if (nativeEncodePos !== -1) {
    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
  }
  return res !== void 0 ? res : uriComponent;
}
function encodeURIComponentMinimal(path5) {
  let res = void 0;
  for (let pos = 0; pos < path5.length; pos++) {
    const code = path5.charCodeAt(pos);
    if (code === 35 || code === 63) {
      if (res === void 0) {
        res = path5.substr(0, pos);
      }
      res += encodeTable[code];
    } else {
      if (res !== void 0) {
        res += path5[pos];
      }
    }
  }
  return res !== void 0 ? res : path5;
}
function uriToFsPath(uri, keepDriveLetterCasing) {
  let value;
  if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
    value = `//${uri.authority}${uri.path}`;
  } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
    if (!keepDriveLetterCasing) {
      value = uri.path[1].toLowerCase() + uri.path.substr(2);
    } else {
      value = uri.path.substr(1);
    }
  } else {
    value = uri.path;
  }
  if (isWindows) {
    value = value.replace(/\//g, "\\");
  }
  return value;
}
function _asFormatted(uri, skipEncoding) {
  const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
  let res = "";
  let { scheme, authority, path: path5, query, fragment } = uri;
  if (scheme) {
    res += scheme;
    res += ":";
  }
  if (authority || scheme === "file") {
    res += _slash;
    res += _slash;
  }
  if (authority) {
    let idx = authority.indexOf("@");
    if (idx !== -1) {
      const userinfo = authority.substr(0, idx);
      authority = authority.substr(idx + 1);
      idx = userinfo.lastIndexOf(":");
      if (idx === -1) {
        res += encoder(userinfo, false, false);
      } else {
        res += encoder(userinfo.substr(0, idx), false, false);
        res += ":";
        res += encoder(userinfo.substr(idx + 1), false, true);
      }
      res += "@";
    }
    authority = authority.toLowerCase();
    idx = authority.lastIndexOf(":");
    if (idx === -1) {
      res += encoder(authority, false, true);
    } else {
      res += encoder(authority.substr(0, idx), false, true);
      res += authority.substr(idx);
    }
  }
  if (path5) {
    if (path5.length >= 3 && path5.charCodeAt(0) === 47 && path5.charCodeAt(2) === 58) {
      const code = path5.charCodeAt(1);
      if (code >= 65 && code <= 90) {
        path5 = `/${String.fromCharCode(code + 32)}:${path5.substr(3)}`;
      }
    } else if (path5.length >= 2 && path5.charCodeAt(1) === 58) {
      const code = path5.charCodeAt(0);
      if (code >= 65 && code <= 90) {
        path5 = `${String.fromCharCode(code + 32)}:${path5.substr(2)}`;
      }
    }
    res += encoder(path5, true, false);
  }
  if (query) {
    res += "?";
    res += encoder(query, false, false);
  }
  if (fragment) {
    res += "#";
    res += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;
  }
  return res;
}
function decodeURIComponentGraceful(str) {
  try {
    return decodeURIComponent(str);
  } catch (_a4) {
    if (str.length > 3) {
      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
    } else {
      return str;
    }
  }
}
var _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function percentDecode(str) {
  if (!str.match(_rEncodedAsHex)) {
    return str;
  }
  return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js
var Position = class _Position {
  constructor(lineNumber, column) {
    this.lineNumber = lineNumber;
    this.column = column;
  }
  /**
   * Create a new position from this position.
   *
   * @param newLineNumber new line number
   * @param newColumn new column
   */
  with(newLineNumber = this.lineNumber, newColumn = this.column) {
    if (newLineNumber === this.lineNumber && newColumn === this.column) {
      return this;
    } else {
      return new _Position(newLineNumber, newColumn);
    }
  }
  /**
   * Derive a new position from this position.
   *
   * @param deltaLineNumber line number delta
   * @param deltaColumn column delta
   */
  delta(deltaLineNumber = 0, deltaColumn = 0) {
    return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
  }
  /**
   * Test if this position equals other position
   */
  equals(other) {
    return _Position.equals(this, other);
  }
  /**
   * Test if position `a` equals position `b`
   */
  static equals(a2, b) {
    if (!a2 && !b) {
      return true;
    }
    return !!a2 && !!b && a2.lineNumber === b.lineNumber && a2.column === b.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be false.
   */
  isBefore(other) {
    return _Position.isBefore(this, other);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be false.
   */
  static isBefore(a2, b) {
    if (a2.lineNumber < b.lineNumber) {
      return true;
    }
    if (b.lineNumber < a2.lineNumber) {
      return false;
    }
    return a2.column < b.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be true.
   */
  isBeforeOrEqual(other) {
    return _Position.isBeforeOrEqual(this, other);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be true.
   */
  static isBeforeOrEqual(a2, b) {
    if (a2.lineNumber < b.lineNumber) {
      return true;
    }
    if (b.lineNumber < a2.lineNumber) {
      return false;
    }
    return a2.column <= b.column;
  }
  /**
   * A function that compares positions, useful for sorting
   */
  static compare(a2, b) {
    const aLineNumber = a2.lineNumber | 0;
    const bLineNumber = b.lineNumber | 0;
    if (aLineNumber === bLineNumber) {
      const aColumn = a2.column | 0;
      const bColumn = b.column | 0;
      return aColumn - bColumn;
    }
    return aLineNumber - bLineNumber;
  }
  /**
   * Clone this position.
   */
  clone() {
    return new _Position(this.lineNumber, this.column);
  }
  /**
   * Convert to a human-readable representation.
   */
  toString() {
    return "(" + this.lineNumber + "," + this.column + ")";
  }
  // ---
  /**
   * Create a `Position` from an `IPosition`.
   */
  static lift(pos) {
    return new _Position(pos.lineNumber, pos.column);
  }
  /**
   * Test if `obj` is an `IPosition`.
   */
  static isIPosition(obj) {
    return obj && typeof obj.lineNumber === "number" && typeof obj.column === "number";
  }
  toJSON() {
    return {
      lineNumber: this.lineNumber,
      column: this.column
    };
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js
var Range = class _Range {
  constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
    if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {
      this.startLineNumber = endLineNumber;
      this.startColumn = endColumn;
      this.endLineNumber = startLineNumber;
      this.endColumn = startColumn;
    } else {
      this.startLineNumber = startLineNumber;
      this.startColumn = startColumn;
      this.endLineNumber = endLineNumber;
      this.endColumn = endColumn;
    }
  }
  /**
   * Test if this range is empty.
   */
  isEmpty() {
    return _Range.isEmpty(this);
  }
  /**
   * Test if `range` is empty.
   */
  static isEmpty(range) {
    return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;
  }
  /**
   * Test if position is in this range. If the position is at the edges, will return true.
   */
  containsPosition(position) {
    return _Range.containsPosition(this, position);
  }
  /**
   * Test if `position` is in `range`. If the position is at the edges, will return true.
   */
  static containsPosition(range, position) {
    if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
      return false;
    }
    if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
      return false;
    }
    if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
      return false;
    }
    return true;
  }
  /**
   * Test if `position` is in `range`. If the position is at the edges, will return false.
   * @internal
   */
  static strictContainsPosition(range, position) {
    if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
      return false;
    }
    if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {
      return false;
    }
    if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {
      return false;
    }
    return true;
  }
  /**
   * Test if range is in this range. If the range is equal to this range, will return true.
   */
  containsRange(range) {
    return _Range.containsRange(this, range);
  }
  /**
   * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
   */
  static containsRange(range, otherRange) {
    if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
      return false;
    }
    if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
      return false;
    }
    if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
      return false;
    }
    if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
      return false;
    }
    return true;
  }
  /**
   * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
   */
  strictContainsRange(range) {
    return _Range.strictContainsRange(this, range);
  }
  /**
   * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
   */
  static strictContainsRange(range, otherRange) {
    if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
      return false;
    }
    if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
      return false;
    }
    if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {
      return false;
    }
    if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {
      return false;
    }
    return true;
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  plusRange(range) {
    return _Range.plusRange(this, range);
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  static plusRange(a2, b) {
    let startLineNumber;
    let startColumn;
    let endLineNumber;
    let endColumn;
    if (b.startLineNumber < a2.startLineNumber) {
      startLineNumber = b.startLineNumber;
      startColumn = b.startColumn;
    } else if (b.startLineNumber === a2.startLineNumber) {
      startLineNumber = b.startLineNumber;
      startColumn = Math.min(b.startColumn, a2.startColumn);
    } else {
      startLineNumber = a2.startLineNumber;
      startColumn = a2.startColumn;
    }
    if (b.endLineNumber > a2.endLineNumber) {
      endLineNumber = b.endLineNumber;
      endColumn = b.endColumn;
    } else if (b.endLineNumber === a2.endLineNumber) {
      endLineNumber = b.endLineNumber;
      endColumn = Math.max(b.endColumn, a2.endColumn);
    } else {
      endLineNumber = a2.endLineNumber;
      endColumn = a2.endColumn;
    }
    return new _Range(startLineNumber, startColumn, endLineNumber, endColumn);
  }
  /**
   * A intersection of the two ranges.
   */
  intersectRanges(range) {
    return _Range.intersectRanges(this, range);
  }
  /**
   * A intersection of the two ranges.
   */
  static intersectRanges(a2, b) {
    let resultStartLineNumber = a2.startLineNumber;
    let resultStartColumn = a2.startColumn;
    let resultEndLineNumber = a2.endLineNumber;
    let resultEndColumn = a2.endColumn;
    const otherStartLineNumber = b.startLineNumber;
    const otherStartColumn = b.startColumn;
    const otherEndLineNumber = b.endLineNumber;
    const otherEndColumn = b.endColumn;
    if (resultStartLineNumber < otherStartLineNumber) {
      resultStartLineNumber = otherStartLineNumber;
      resultStartColumn = otherStartColumn;
    } else if (resultStartLineNumber === otherStartLineNumber) {
      resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
    }
    if (resultEndLineNumber > otherEndLineNumber) {
      resultEndLineNumber = otherEndLineNumber;
      resultEndColumn = otherEndColumn;
    } else if (resultEndLineNumber === otherEndLineNumber) {
      resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
    }
    if (resultStartLineNumber > resultEndLineNumber) {
      return null;
    }
    if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
      return null;
    }
    return new _Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
  }
  /**
   * Test if this range equals other.
   */
  equalsRange(other) {
    return _Range.equalsRange(this, other);
  }
  /**
   * Test if range `a` equals `b`.
   */
  static equalsRange(a2, b) {
    if (!a2 && !b) {
      return true;
    }
    return !!a2 && !!b && a2.startLineNumber === b.startLineNumber && a2.startColumn === b.startColumn && a2.endLineNumber === b.endLineNumber && a2.endColumn === b.endColumn;
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  getEndPosition() {
    return _Range.getEndPosition(this);
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  static getEndPosition(range) {
    return new Position(range.endLineNumber, range.endColumn);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  getStartPosition() {
    return _Range.getStartPosition(this);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  static getStartPosition(range) {
    return new Position(range.startLineNumber, range.startColumn);
  }
  /**
   * Transform to a user presentable string representation.
   */
  toString() {
    return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
  }
  /**
   * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
   */
  setEndPosition(endLineNumber, endColumn) {
    return new _Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
  }
  /**
   * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
   */
  setStartPosition(startLineNumber, startColumn) {
    return new _Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  collapseToStart() {
    return _Range.collapseToStart(this);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  static collapseToStart(range) {
    return new _Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
  }
  /**
   * Create a new empty range using this range's end position.
   */
  collapseToEnd() {
    return _Range.collapseToEnd(this);
  }
  /**
   * Create a new empty range using this range's end position.
   */
  static collapseToEnd(range) {
    return new _Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);
  }
  /**
   * Moves the range by the given amount of lines.
   */
  delta(lineCount) {
    return new _Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);
  }
  // ---
  static fromPositions(start, end = start) {
    return new _Range(start.lineNumber, start.column, end.lineNumber, end.column);
  }
  static lift(range) {
    if (!range) {
      return null;
    }
    return new _Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
  }
  /**
   * Test if `obj` is an `IRange`.
   */
  static isIRange(obj) {
    return obj && typeof obj.startLineNumber === "number" && typeof obj.startColumn === "number" && typeof obj.endLineNumber === "number" && typeof obj.endColumn === "number";
  }
  /**
   * Test if the two ranges are touching in any way.
   */
  static areIntersectingOrTouching(a2, b) {
    if (a2.endLineNumber < b.startLineNumber || a2.endLineNumber === b.startLineNumber && a2.endColumn < b.startColumn) {
      return false;
    }
    if (b.endLineNumber < a2.startLineNumber || b.endLineNumber === a2.startLineNumber && b.endColumn < a2.startColumn) {
      return false;
    }
    return true;
  }
  /**
   * Test if the two ranges are intersecting. If the ranges are touching it returns true.
   */
  static areIntersecting(a2, b) {
    if (a2.endLineNumber < b.startLineNumber || a2.endLineNumber === b.startLineNumber && a2.endColumn <= b.startColumn) {
      return false;
    }
    if (b.endLineNumber < a2.startLineNumber || b.endLineNumber === a2.startLineNumber && b.endColumn <= a2.startColumn) {
      return false;
    }
    return true;
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the startPosition and then on the endPosition
   */
  static compareRangesUsingStarts(a2, b) {
    if (a2 && b) {
      const aStartLineNumber = a2.startLineNumber | 0;
      const bStartLineNumber = b.startLineNumber | 0;
      if (aStartLineNumber === bStartLineNumber) {
        const aStartColumn = a2.startColumn | 0;
        const bStartColumn = b.startColumn | 0;
        if (aStartColumn === bStartColumn) {
          const aEndLineNumber = a2.endLineNumber | 0;
          const bEndLineNumber = b.endLineNumber | 0;
          if (aEndLineNumber === bEndLineNumber) {
            const aEndColumn = a2.endColumn | 0;
            const bEndColumn = b.endColumn | 0;
            return aEndColumn - bEndColumn;
          }
          return aEndLineNumber - bEndLineNumber;
        }
        return aStartColumn - bStartColumn;
      }
      return aStartLineNumber - bStartLineNumber;
    }
    const aExists = a2 ? 1 : 0;
    const bExists = b ? 1 : 0;
    return aExists - bExists;
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the endPosition and then on the startPosition
   */
  static compareRangesUsingEnds(a2, b) {
    if (a2.endLineNumber === b.endLineNumber) {
      if (a2.endColumn === b.endColumn) {
        if (a2.startLineNumber === b.startLineNumber) {
          return a2.startColumn - b.startColumn;
        }
        return a2.startLineNumber - b.startLineNumber;
      }
      return a2.endColumn - b.endColumn;
    }
    return a2.endLineNumber - b.endLineNumber;
  }
  /**
   * Test if the range spans multiple lines.
   */
  static spansMultipleLines(range) {
    return range.endLineNumber > range.startLineNumber;
  }
  toJSON() {
    return this;
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/arrays.js
function equals(one, other, itemEquals = (a2, b) => a2 === b) {
  if (one === other) {
    return true;
  }
  if (!one || !other) {
    return false;
  }
  if (one.length !== other.length) {
    return false;
  }
  for (let i = 0, len = one.length; i < len; i++) {
    if (!itemEquals(one[i], other[i])) {
      return false;
    }
  }
  return true;
}
function* groupAdjacentBy(items, shouldBeGrouped) {
  let currentGroup;
  let last;
  for (const item of items) {
    if (last !== void 0 && shouldBeGrouped(last, item)) {
      currentGroup.push(item);
    } else {
      if (currentGroup) {
        yield currentGroup;
      }
      currentGroup = [item];
    }
    last = item;
  }
  if (currentGroup) {
    yield currentGroup;
  }
}
function forEachAdjacent(arr, f2) {
  for (let i = 0; i <= arr.length; i++) {
    f2(i === 0 ? void 0 : arr[i - 1], i === arr.length ? void 0 : arr[i]);
  }
}
function forEachWithNeighbors(arr, f2) {
  for (let i = 0; i < arr.length; i++) {
    f2(i === 0 ? void 0 : arr[i - 1], arr[i], i + 1 === arr.length ? void 0 : arr[i + 1]);
  }
}
function pushMany(arr, items) {
  for (const item of items) {
    arr.push(item);
  }
}
var CompareResult;
(function(CompareResult2) {
  function isLessThan(result) {
    return result < 0;
  }
  CompareResult2.isLessThan = isLessThan;
  function isLessThanOrEqual(result) {
    return result <= 0;
  }
  CompareResult2.isLessThanOrEqual = isLessThanOrEqual;
  function isGreaterThan(result) {
    return result > 0;
  }
  CompareResult2.isGreaterThan = isGreaterThan;
  function isNeitherLessOrGreaterThan(result) {
    return result === 0;
  }
  CompareResult2.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;
  CompareResult2.greaterThan = 1;
  CompareResult2.lessThan = -1;
  CompareResult2.neitherLessOrGreaterThan = 0;
})(CompareResult || (CompareResult = {}));
function compareBy(selector, comparator) {
  return (a2, b) => comparator(selector(a2), selector(b));
}
var numberComparator = (a2, b) => a2 - b;
function reverseOrder(comparator) {
  return (a2, b) => -comparator(a2, b);
}
var CallbackIterable = class _CallbackIterable {
  constructor(iterate) {
    this.iterate = iterate;
  }
  toArray() {
    const result = [];
    this.iterate((item) => {
      result.push(item);
      return true;
    });
    return result;
  }
  filter(predicate) {
    return new _CallbackIterable((cb) => this.iterate((item) => predicate(item) ? cb(item) : true));
  }
  map(mapFn) {
    return new _CallbackIterable((cb) => this.iterate((item) => cb(mapFn(item))));
  }
  findLast(predicate) {
    let result;
    this.iterate((item) => {
      if (predicate(item)) {
        result = item;
      }
      return true;
    });
    return result;
  }
  findLastMaxBy(comparator) {
    let result;
    let first = true;
    this.iterate((item) => {
      if (first || CompareResult.isGreaterThan(comparator(item, result))) {
        first = false;
        result = item;
      }
      return true;
    });
    return result;
  }
};
CallbackIterable.empty = new CallbackIterable((_callback) => {
});

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/uint.js
function toUint8(v) {
  if (v < 0) {
    return 0;
  }
  if (v > 255) {
    return 255;
  }
  return v | 0;
}
function toUint32(v) {
  if (v < 0) {
    return 0;
  }
  if (v > 4294967295) {
    return 4294967295;
  }
  return v | 0;
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js
var PrefixSumComputer = class {
  constructor(values) {
    this.values = values;
    this.prefixSum = new Uint32Array(values.length);
    this.prefixSumValidIndex = new Int32Array(1);
    this.prefixSumValidIndex[0] = -1;
  }
  insertValues(insertIndex, insertValues) {
    insertIndex = toUint32(insertIndex);
    const oldValues = this.values;
    const oldPrefixSum = this.prefixSum;
    const insertValuesLen = insertValues.length;
    if (insertValuesLen === 0) {
      return false;
    }
    this.values = new Uint32Array(oldValues.length + insertValuesLen);
    this.values.set(oldValues.subarray(0, insertIndex), 0);
    this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
    this.values.set(insertValues, insertIndex);
    if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
      this.prefixSumValidIndex[0] = insertIndex - 1;
    }
    this.prefixSum = new Uint32Array(this.values.length);
    if (this.prefixSumValidIndex[0] >= 0) {
      this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
    }
    return true;
  }
  setValue(index, value) {
    index = toUint32(index);
    value = toUint32(value);
    if (this.values[index] === value) {
      return false;
    }
    this.values[index] = value;
    if (index - 1 < this.prefixSumValidIndex[0]) {
      this.prefixSumValidIndex[0] = index - 1;
    }
    return true;
  }
  removeValues(startIndex, count) {
    startIndex = toUint32(startIndex);
    count = toUint32(count);
    const oldValues = this.values;
    const oldPrefixSum = this.prefixSum;
    if (startIndex >= oldValues.length) {
      return false;
    }
    const maxCount = oldValues.length - startIndex;
    if (count >= maxCount) {
      count = maxCount;
    }
    if (count === 0) {
      return false;
    }
    this.values = new Uint32Array(oldValues.length - count);
    this.values.set(oldValues.subarray(0, startIndex), 0);
    this.values.set(oldValues.subarray(startIndex + count), startIndex);
    this.prefixSum = new Uint32Array(this.values.length);
    if (startIndex - 1 < this.prefixSumValidIndex[0]) {
      this.prefixSumValidIndex[0] = startIndex - 1;
    }
    if (this.prefixSumValidIndex[0] >= 0) {
      this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
    }
    return true;
  }
  getTotalSum() {
    if (this.values.length === 0) {
      return 0;
    }
    return this._getPrefixSum(this.values.length - 1);
  }
  /**
   * Returns the sum of the first `index + 1` many items.
   * @returns `SUM(0 <= j <= index, values[j])`.
   */
  getPrefixSum(index) {
    if (index < 0) {
      return 0;
    }
    index = toUint32(index);
    return this._getPrefixSum(index);
  }
  _getPrefixSum(index) {
    if (index <= this.prefixSumValidIndex[0]) {
      return this.prefixSum[index];
    }
    let startIndex = this.prefixSumValidIndex[0] + 1;
    if (startIndex === 0) {
      this.prefixSum[0] = this.values[0];
      startIndex++;
    }
    if (index >= this.values.length) {
      index = this.values.length - 1;
    }
    for (let i = startIndex; i <= index; i++) {
      this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
    }
    this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
    return this.prefixSum[index];
  }
  getIndexOf(sum) {
    sum = Math.floor(sum);
    this.getTotalSum();
    let low = 0;
    let high = this.values.length - 1;
    let mid = 0;
    let midStop = 0;
    let midStart = 0;
    while (low <= high) {
      mid = low + (high - low) / 2 | 0;
      midStop = this.prefixSum[mid];
      midStart = midStop - this.values[mid];
      if (sum < midStart) {
        high = mid - 1;
      } else if (sum >= midStop) {
        low = mid + 1;
      } else {
        break;
      }
    }
    return new PrefixSumIndexOfResult(mid, sum - midStart);
  }
};
var PrefixSumIndexOfResult = class {
  constructor(index, remainder) {
    this.index = index;
    this.remainder = remainder;
    this._prefixSumIndexOfResultBrand = void 0;
    this.index = index;
    this.remainder = remainder;
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js
var MirrorTextModel = class {
  constructor(uri, lines, eol, versionId) {
    this._uri = uri;
    this._lines = lines;
    this._eol = eol;
    this._versionId = versionId;
    this._lineStarts = null;
    this._cachedTextValue = null;
  }
  dispose() {
    this._lines.length = 0;
  }
  get version() {
    return this._versionId;
  }
  getText() {
    if (this._cachedTextValue === null) {
      this._cachedTextValue = this._lines.join(this._eol);
    }
    return this._cachedTextValue;
  }
  onEvents(e) {
    if (e.eol && e.eol !== this._eol) {
      this._eol = e.eol;
      this._lineStarts = null;
    }
    const changes = e.changes;
    for (const change of changes) {
      this._acceptDeleteRange(change.range);
      this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);
    }
    this._versionId = e.versionId;
    this._cachedTextValue = null;
  }
  _ensureLineStarts() {
    if (!this._lineStarts) {
      const eolLength = this._eol.length;
      const linesLength = this._lines.length;
      const lineStartValues = new Uint32Array(linesLength);
      for (let i = 0; i < linesLength; i++) {
        lineStartValues[i] = this._lines[i].length + eolLength;
      }
      this._lineStarts = new PrefixSumComputer(lineStartValues);
    }
  }
  /**
   * All changes to a line's text go through this method
   */
  _setLineText(lineIndex, newValue) {
    this._lines[lineIndex] = newValue;
    if (this._lineStarts) {
      this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
    }
  }
  _acceptDeleteRange(range) {
    if (range.startLineNumber === range.endLineNumber) {
      if (range.startColumn === range.endColumn) {
        return;
      }
      this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
      return;
    }
    this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
    this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
    if (this._lineStarts) {
      this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
    }
  }
  _acceptInsertText(position, insertText) {
    if (insertText.length === 0) {
      return;
    }
    const insertLines = splitLines(insertText);
    if (insertLines.length === 1) {
      this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0] + this._lines[position.lineNumber - 1].substring(position.column - 1));
      return;
    }
    insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
    this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0]);
    const newLengths = new Uint32Array(insertLines.length - 1);
    for (let i = 1; i < insertLines.length; i++) {
      this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
      newLengths[i - 1] = insertLines[i].length + this._eol.length;
    }
    if (this._lineStarts) {
      this._lineStarts.insertValues(position.lineNumber, newLengths);
    }
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js
var USUAL_WORD_SEPARATORS = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
function createWordRegExp(allowInWords = "") {
  let source = "(-?\\d*\\.\\d\\w*)|([^";
  for (const sep2 of USUAL_WORD_SEPARATORS) {
    if (allowInWords.indexOf(sep2) >= 0) {
      continue;
    }
    source += "\\" + sep2;
  }
  source += "\\s]+)";
  return new RegExp(source, "g");
}
var DEFAULT_WORD_REGEXP = createWordRegExp();
function ensureValidWordDefinition(wordDefinition) {
  let result = DEFAULT_WORD_REGEXP;
  if (wordDefinition && wordDefinition instanceof RegExp) {
    if (!wordDefinition.global) {
      let flags = "g";
      if (wordDefinition.ignoreCase) {
        flags += "i";
      }
      if (wordDefinition.multiline) {
        flags += "m";
      }
      if (wordDefinition.unicode) {
        flags += "u";
      }
      result = new RegExp(wordDefinition.source, flags);
    } else {
      result = wordDefinition;
    }
  }
  result.lastIndex = 0;
  return result;
}
var _defaultConfig = new LinkedList();
_defaultConfig.unshift({
  maxLen: 1e3,
  windowSize: 15,
  timeBudget: 150
});
function getWordAtText(column, wordDefinition, text, textOffset, config) {
  wordDefinition = ensureValidWordDefinition(wordDefinition);
  if (!config) {
    config = Iterable.first(_defaultConfig);
  }
  if (text.length > config.maxLen) {
    let start = column - config.maxLen / 2;
    if (start < 0) {
      start = 0;
    } else {
      textOffset += start;
    }
    text = text.substring(start, column + config.maxLen / 2);
    return getWordAtText(column, wordDefinition, text, textOffset, config);
  }
  const t1 = Date.now();
  const pos = column - 1 - textOffset;
  let prevRegexIndex = -1;
  let match = null;
  for (let i = 1; ; i++) {
    if (Date.now() - t1 >= config.timeBudget) {
      break;
    }
    const regexIndex = pos - config.windowSize * i;
    wordDefinition.lastIndex = Math.max(0, regexIndex);
    const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);
    if (!thisMatch && match) {
      break;
    }
    match = thisMatch;
    if (regexIndex <= 0) {
      break;
    }
    prevRegexIndex = regexIndex;
  }
  if (match) {
    const result = {
      word: match[0],
      startColumn: textOffset + 1 + match.index,
      endColumn: textOffset + 1 + match.index + match[0].length
    };
    wordDefinition.lastIndex = 0;
    return result;
  }
  return null;
}
function _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {
  let match;
  while (match = wordDefinition.exec(text)) {
    const matchIndex = match.index || 0;
    if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
      return match;
    } else if (stopPos > 0 && matchIndex > stopPos) {
      return null;
    }
  }
  return null;
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js
var CharacterClassifier = class _CharacterClassifier {
  constructor(_defaultValue) {
    const defaultValue = toUint8(_defaultValue);
    this._defaultValue = defaultValue;
    this._asciiMap = _CharacterClassifier._createAsciiMap(defaultValue);
    this._map = /* @__PURE__ */ new Map();
  }
  static _createAsciiMap(defaultValue) {
    const asciiMap = new Uint8Array(256);
    asciiMap.fill(defaultValue);
    return asciiMap;
  }
  set(charCode, _value) {
    const value = toUint8(_value);
    if (charCode >= 0 && charCode < 256) {
      this._asciiMap[charCode] = value;
    } else {
      this._map.set(charCode, value);
    }
  }
  get(charCode) {
    if (charCode >= 0 && charCode < 256) {
      return this._asciiMap[charCode];
    } else {
      return this._map.get(charCode) || this._defaultValue;
    }
  }
  clear() {
    this._asciiMap.fill(this._defaultValue);
    this._map.clear();
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js
var Uint8Matrix = class {
  constructor(rows, cols, defaultValue) {
    const data = new Uint8Array(rows * cols);
    for (let i = 0, len = rows * cols; i < len; i++) {
      data[i] = defaultValue;
    }
    this._data = data;
    this.rows = rows;
    this.cols = cols;
  }
  get(row, col) {
    return this._data[row * this.cols + col];
  }
  set(row, col, value) {
    this._data[row * this.cols + col] = value;
  }
};
var StateMachine = class {
  constructor(edges) {
    let maxCharCode = 0;
    let maxState = 0;
    for (let i = 0, len = edges.length; i < len; i++) {
      const [from, chCode, to] = edges[i];
      if (chCode > maxCharCode) {
        maxCharCode = chCode;
      }
      if (from > maxState) {
        maxState = from;
      }
      if (to > maxState) {
        maxState = to;
      }
    }
    maxCharCode++;
    maxState++;
    const states = new Uint8Matrix(
      maxState,
      maxCharCode,
      0
      /* State.Invalid */
    );
    for (let i = 0, len = edges.length; i < len; i++) {
      const [from, chCode, to] = edges[i];
      states.set(from, chCode, to);
    }
    this._states = states;
    this._maxCharCode = maxCharCode;
  }
  nextState(currentState, chCode) {
    if (chCode < 0 || chCode >= this._maxCharCode) {
      return 0;
    }
    return this._states.get(currentState, chCode);
  }
};
var _stateMachine = null;
function getStateMachine() {
  if (_stateMachine === null) {
    _stateMachine = new StateMachine([
      [
        1,
        104,
        2
        /* State.H */
      ],
      [
        1,
        72,
        2
        /* State.H */
      ],
      [
        1,
        102,
        6
        /* State.F */
      ],
      [
        1,
        70,
        6
        /* State.F */
      ],
      [
        2,
        116,
        3
        /* State.HT */
      ],
      [
        2,
        84,
        3
        /* State.HT */
      ],
      [
        3,
        116,
        4
        /* State.HTT */
      ],
      [
        3,
        84,
        4
        /* State.HTT */
      ],
      [
        4,
        112,
        5
        /* State.HTTP */
      ],
      [
        4,
        80,
        5
        /* State.HTTP */
      ],
      [
        5,
        115,
        9
        /* State.BeforeColon */
      ],
      [
        5,
        83,
        9
        /* State.BeforeColon */
      ],
      [
        5,
        58,
        10
        /* State.AfterColon */
      ],
      [
        6,
        105,
        7
        /* State.FI */
      ],
      [
        6,
        73,
        7
        /* State.FI */
      ],
      [
        7,
        108,
        8
        /* State.FIL */
      ],
      [
        7,
        76,
        8
        /* State.FIL */
      ],
      [
        8,
        101,
        9
        /* State.BeforeColon */
      ],
      [
        8,
        69,
        9
        /* State.BeforeColon */
      ],
      [
        9,
        58,
        10
        /* State.AfterColon */
      ],
      [
        10,
        47,
        11
        /* State.AlmostThere */
      ],
      [
        11,
        47,
        12
        /* State.End */
      ]
    ]);
  }
  return _stateMachine;
}
var _classifier = null;
function getClassifier() {
  if (_classifier === null) {
    _classifier = new CharacterClassifier(
      0
      /* CharacterClass.None */
    );
    const FORCE_TERMINATION_CHARACTERS = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026`;
    for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
      _classifier.set(
        FORCE_TERMINATION_CHARACTERS.charCodeAt(i),
        1
        /* CharacterClass.ForceTermination */
      );
    }
    const CANNOT_END_WITH_CHARACTERS = ".,;:";
    for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
      _classifier.set(
        CANNOT_END_WITH_CHARACTERS.charCodeAt(i),
        2
        /* CharacterClass.CannotEndIn */
      );
    }
  }
  return _classifier;
}
var LinkComputer = class _LinkComputer {
  static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
    let lastIncludedCharIndex = linkEndIndex - 1;
    do {
      const chCode = line.charCodeAt(lastIncludedCharIndex);
      const chClass = classifier.get(chCode);
      if (chClass !== 2) {
        break;
      }
      lastIncludedCharIndex--;
    } while (lastIncludedCharIndex > linkBeginIndex);
    if (linkBeginIndex > 0) {
      const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
      const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
      if (charCodeBeforeLink === 40 && lastCharCodeInLink === 41 || charCodeBeforeLink === 91 && lastCharCodeInLink === 93 || charCodeBeforeLink === 123 && lastCharCodeInLink === 125) {
        lastIncludedCharIndex--;
      }
    }
    return {
      range: {
        startLineNumber: lineNumber,
        startColumn: linkBeginIndex + 1,
        endLineNumber: lineNumber,
        endColumn: lastIncludedCharIndex + 2
      },
      url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
    };
  }
  static computeLinks(model, stateMachine = getStateMachine()) {
    const classifier = getClassifier();
    const result = [];
    for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
      const line = model.getLineContent(i);
      const len = line.length;
      let j = 0;
      let linkBeginIndex = 0;
      let linkBeginChCode = 0;
      let state = 1;
      let hasOpenParens = false;
      let hasOpenSquareBracket = false;
      let inSquareBrackets = false;
      let hasOpenCurlyBracket = false;
      while (j < len) {
        let resetStateMachine = false;
        const chCode = line.charCodeAt(j);
        if (state === 13) {
          let chClass;
          switch (chCode) {
            case 40:
              hasOpenParens = true;
              chClass = 0;
              break;
            case 41:
              chClass = hasOpenParens ? 0 : 1;
              break;
            case 91:
              inSquareBrackets = true;
              hasOpenSquareBracket = true;
              chClass = 0;
              break;
            case 93:
              inSquareBrackets = false;
              chClass = hasOpenSquareBracket ? 0 : 1;
              break;
            case 123:
              hasOpenCurlyBracket = true;
              chClass = 0;
              break;
            case 125:
              chClass = hasOpenCurlyBracket ? 0 : 1;
              break;
            // The following three rules make it that ' or " or ` are allowed inside links
            // only if the link is wrapped by some other quote character
            case 39:
            case 34:
            case 96:
              if (linkBeginChCode === chCode) {
                chClass = 1;
              } else if (linkBeginChCode === 39 || linkBeginChCode === 34 || linkBeginChCode === 96) {
                chClass = 0;
              } else {
                chClass = 1;
              }
              break;
            case 42:
              chClass = linkBeginChCode === 42 ? 1 : 0;
              break;
            case 124:
              chClass = linkBeginChCode === 124 ? 1 : 0;
              break;
            case 32:
              chClass = inSquareBrackets ? 0 : 1;
              break;
            default:
              chClass = classifier.get(chCode);
          }
          if (chClass === 1) {
            result.push(_LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));
            resetStateMachine = true;
          }
        } else if (state === 12) {
          let chClass;
          if (chCode === 91) {
            hasOpenSquareBracket = true;
            chClass = 0;
          } else {
            chClass = classifier.get(chCode);
          }
          if (chClass === 1) {
            resetStateMachine = true;
          } else {
            state = 13;
          }
        } else {
          state = stateMachine.nextState(state, chCode);
          if (state === 0) {
            resetStateMachine = true;
          }
        }
        if (resetStateMachine) {
          state = 1;
          hasOpenParens = false;
          hasOpenSquareBracket = false;
          hasOpenCurlyBracket = false;
          linkBeginIndex = j + 1;
          linkBeginChCode = chCode;
        }
        j++;
      }
      if (state === 13) {
        result.push(_LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));
      }
    }
    return result;
  }
};
function computeLinks(model) {
  if (!model || typeof model.getLineCount !== "function" || typeof model.getLineContent !== "function") {
    return [];
  }
  return LinkComputer.computeLinks(model);
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js
var BasicInplaceReplace = class {
  constructor() {
    this._defaultValueSet = [
      ["true", "false"],
      ["True", "False"],
      ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
      ["public", "protected", "private"]
    ];
  }
  navigateValueSet(range1, text1, range2, text2, up) {
    if (range1 && text1) {
      const result = this.doNavigateValueSet(text1, up);
      if (result) {
        return {
          range: range1,
          value: result
        };
      }
    }
    if (range2 && text2) {
      const result = this.doNavigateValueSet(text2, up);
      if (result) {
        return {
          range: range2,
          value: result
        };
      }
    }
    return null;
  }
  doNavigateValueSet(text, up) {
    const numberResult = this.numberReplace(text, up);
    if (numberResult !== null) {
      return numberResult;
    }
    return this.textReplace(text, up);
  }
  numberReplace(value, up) {
    const precision = Math.pow(10, value.length - (value.lastIndexOf(".") + 1));
    let n1 = Number(value);
    const n2 = parseFloat(value);
    if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
      if (n1 === 0 && !up) {
        return null;
      } else {
        n1 = Math.floor(n1 * precision);
        n1 += up ? precision : -precision;
        return String(n1 / precision);
      }
    }
    return null;
  }
  textReplace(value, up) {
    return this.valueSetsReplace(this._defaultValueSet, value, up);
  }
  valueSetsReplace(valueSets, value, up) {
    let result = null;
    for (let i = 0, len = valueSets.length; result === null && i < len; i++) {
      result = this.valueSetReplace(valueSets[i], value, up);
    }
    return result;
  }
  valueSetReplace(valueSet, value, up) {
    let idx = valueSet.indexOf(value);
    if (idx >= 0) {
      idx += up ? 1 : -1;
      if (idx < 0) {
        idx = valueSet.length - 1;
      } else {
        idx %= valueSet.length;
      }
      return valueSet[idx];
    }
    return null;
  }
};
BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/cancellation.js
var shortcutEvent = Object.freeze(function(callback, context) {
  const handle = setTimeout(callback.bind(context), 0);
  return { dispose() {
    clearTimeout(handle);
  } };
});
var CancellationToken;
(function(CancellationToken2) {
  function isCancellationToken(thing) {
    if (thing === CancellationToken2.None || thing === CancellationToken2.Cancelled) {
      return true;
    }
    if (thing instanceof MutableToken) {
      return true;
    }
    if (!thing || typeof thing !== "object") {
      return false;
    }
    return typeof thing.isCancellationRequested === "boolean" && typeof thing.onCancellationRequested === "function";
  }
  CancellationToken2.isCancellationToken = isCancellationToken;
  CancellationToken2.None = Object.freeze({
    isCancellationRequested: false,
    onCancellationRequested: Event.None
  });
  CancellationToken2.Cancelled = Object.freeze({
    isCancellationRequested: true,
    onCancellationRequested: shortcutEvent
  });
})(CancellationToken || (CancellationToken = {}));
var MutableToken = class {
  constructor() {
    this._isCancelled = false;
    this._emitter = null;
  }
  cancel() {
    if (!this._isCancelled) {
      this._isCancelled = true;
      if (this._emitter) {
        this._emitter.fire(void 0);
        this.dispose();
      }
    }
  }
  get isCancellationRequested() {
    return this._isCancelled;
  }
  get onCancellationRequested() {
    if (this._isCancelled) {
      return shortcutEvent;
    }
    if (!this._emitter) {
      this._emitter = new Emitter();
    }
    return this._emitter.event;
  }
  dispose() {
    if (this._emitter) {
      this._emitter.dispose();
      this._emitter = null;
    }
  }
};
var CancellationTokenSource = class {
  constructor(parent) {
    this._token = void 0;
    this._parentListener = void 0;
    this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
  }
  get token() {
    if (!this._token) {
      this._token = new MutableToken();
    }
    return this._token;
  }
  cancel() {
    if (!this._token) {
      this._token = CancellationToken.Cancelled;
    } else if (this._token instanceof MutableToken) {
      this._token.cancel();
    }
  }
  dispose(cancel = false) {
    var _a4;
    if (cancel) {
      this.cancel();
    }
    (_a4 = this._parentListener) === null || _a4 === void 0 ? void 0 : _a4.dispose();
    if (!this._token) {
      this._token = CancellationToken.None;
    } else if (this._token instanceof MutableToken) {
      this._token.dispose();
    }
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/keyCodes.js
var KeyCodeStrMap = class {
  constructor() {
    this._keyCodeToStr = [];
    this._strToKeyCode = /* @__PURE__ */ Object.create(null);
  }
  define(keyCode, str) {
    this._keyCodeToStr[keyCode] = str;
    this._strToKeyCode[str.toLowerCase()] = keyCode;
  }
  keyCodeToStr(keyCode) {
    return this._keyCodeToStr[keyCode];
  }
  strToKeyCode(str) {
    return this._strToKeyCode[str.toLowerCase()] || 0;
  }
};
var uiMap = new KeyCodeStrMap();
var userSettingsUSMap = new KeyCodeStrMap();
var userSettingsGeneralMap = new KeyCodeStrMap();
var EVENT_KEY_CODE_MAP = new Array(230);
var NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE = {};
var scanCodeIntToStr = [];
var scanCodeStrToInt = /* @__PURE__ */ Object.create(null);
var scanCodeLowerCaseStrToInt = /* @__PURE__ */ Object.create(null);
var IMMUTABLE_CODE_TO_KEY_CODE = [];
var IMMUTABLE_KEY_CODE_TO_CODE = [];
for (let i = 0; i <= 193; i++) {
  IMMUTABLE_CODE_TO_KEY_CODE[i] = -1;
}
for (let i = 0; i <= 132; i++) {
  IMMUTABLE_KEY_CODE_TO_CODE[i] = -1;
}
(function() {
  const empty = "";
  const mappings = [
    // immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel
    [1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", empty, empty],
    [1, 1, "Hyper", 0, empty, 0, empty, empty, empty],
    [1, 2, "Super", 0, empty, 0, empty, empty, empty],
    [1, 3, "Fn", 0, empty, 0, empty, empty, empty],
    [1, 4, "FnLock", 0, empty, 0, empty, empty, empty],
    [1, 5, "Suspend", 0, empty, 0, empty, empty, empty],
    [1, 6, "Resume", 0, empty, 0, empty, empty, empty],
    [1, 7, "Turbo", 0, empty, 0, empty, empty, empty],
    [1, 8, "Sleep", 0, empty, 0, "VK_SLEEP", empty, empty],
    [1, 9, "WakeUp", 0, empty, 0, empty, empty, empty],
    [0, 10, "KeyA", 31, "A", 65, "VK_A", empty, empty],
    [0, 11, "KeyB", 32, "B", 66, "VK_B", empty, empty],
    [0, 12, "KeyC", 33, "C", 67, "VK_C", empty, empty],
    [0, 13, "KeyD", 34, "D", 68, "VK_D", empty, empty],
    [0, 14, "KeyE", 35, "E", 69, "VK_E", empty, empty],
    [0, 15, "KeyF", 36, "F", 70, "VK_F", empty, empty],
    [0, 16, "KeyG", 37, "G", 71, "VK_G", empty, empty],
    [0, 17, "KeyH", 38, "H", 72, "VK_H", empty, empty],
    [0, 18, "KeyI", 39, "I", 73, "VK_I", empty, empty],
    [0, 19, "KeyJ", 40, "J", 74, "VK_J", empty, empty],
    [0, 20, "KeyK", 41, "K", 75, "VK_K", empty, empty],
    [0, 21, "KeyL", 42, "L", 76, "VK_L", empty, empty],
    [0, 22, "KeyM", 43, "M", 77, "VK_M", empty, empty],
    [0, 23, "KeyN", 44, "N", 78, "VK_N", empty, empty],
    [0, 24, "KeyO", 45, "O", 79, "VK_O", empty, empty],
    [0, 25, "KeyP", 46, "P", 80, "VK_P", empty, empty],
    [0, 26, "KeyQ", 47, "Q", 81, "VK_Q", empty, empty],
    [0, 27, "KeyR", 48, "R", 82, "VK_R", empty, empty],
    [0, 28, "KeyS", 49, "S", 83, "VK_S", empty, empty],
    [0, 29, "KeyT", 50, "T", 84, "VK_T", empty, empty],
    [0, 30, "KeyU", 51, "U", 85, "VK_U", empty, empty],
    [0, 31, "KeyV", 52, "V", 86, "VK_V", empty, empty],
    [0, 32, "KeyW", 53, "W", 87, "VK_W", empty, empty],
    [0, 33, "KeyX", 54, "X", 88, "VK_X", empty, empty],
    [0, 34, "KeyY", 55, "Y", 89, "VK_Y", empty, empty],
    [0, 35, "KeyZ", 56, "Z", 90, "VK_Z", empty, empty],
    [0, 36, "Digit1", 22, "1", 49, "VK_1", empty, empty],
    [0, 37, "Digit2", 23, "2", 50, "VK_2", empty, empty],
    [0, 38, "Digit3", 24, "3", 51, "VK_3", empty, empty],
    [0, 39, "Digit4", 25, "4", 52, "VK_4", empty, empty],
    [0, 40, "Digit5", 26, "5", 53, "VK_5", empty, empty],
    [0, 41, "Digit6", 27, "6", 54, "VK_6", empty, empty],
    [0, 42, "Digit7", 28, "7", 55, "VK_7", empty, empty],
    [0, 43, "Digit8", 29, "8", 56, "VK_8", empty, empty],
    [0, 44, "Digit9", 30, "9", 57, "VK_9", empty, empty],
    [0, 45, "Digit0", 21, "0", 48, "VK_0", empty, empty],
    [1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", empty, empty],
    [1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", empty, empty],
    [1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", empty, empty],
    [1, 49, "Tab", 2, "Tab", 9, "VK_TAB", empty, empty],
    [1, 50, "Space", 10, "Space", 32, "VK_SPACE", empty, empty],
    [0, 51, "Minus", 88, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
    [0, 52, "Equal", 86, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
    [0, 53, "BracketLeft", 92, "[", 219, "VK_OEM_4", "[", "OEM_4"],
    [0, 54, "BracketRight", 94, "]", 221, "VK_OEM_6", "]", "OEM_6"],
    [0, 55, "Backslash", 93, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
    [0, 56, "IntlHash", 0, empty, 0, empty, empty, empty],
    // has been dropped from the w3c spec
    [0, 57, "Semicolon", 85, ";", 186, "VK_OEM_1", ";", "OEM_1"],
    [0, 58, "Quote", 95, "'", 222, "VK_OEM_7", "'", "OEM_7"],
    [0, 59, "Backquote", 91, "`", 192, "VK_OEM_3", "`", "OEM_3"],
    [0, 60, "Comma", 87, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
    [0, 61, "Period", 89, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
    [0, 62, "Slash", 90, "/", 191, "VK_OEM_2", "/", "OEM_2"],
    [1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", empty, empty],
    [1, 64, "F1", 59, "F1", 112, "VK_F1", empty, empty],
    [1, 65, "F2", 60, "F2", 113, "VK_F2", empty, empty],
    [1, 66, "F3", 61, "F3", 114, "VK_F3", empty, empty],
    [1, 67, "F4", 62, "F4", 115, "VK_F4", empty, empty],
    [1, 68, "F5", 63, "F5", 116, "VK_F5", empty, empty],
    [1, 69, "F6", 64, "F6", 117, "VK_F6", empty, empty],
    [1, 70, "F7", 65, "F7", 118, "VK_F7", empty, empty],
    [1, 71, "F8", 66, "F8", 119, "VK_F8", empty, empty],
    [1, 72, "F9", 67, "F9", 120, "VK_F9", empty, empty],
    [1, 73, "F10", 68, "F10", 121, "VK_F10", empty, empty],
    [1, 74, "F11", 69, "F11", 122, "VK_F11", empty, empty],
    [1, 75, "F12", 70, "F12", 123, "VK_F12", empty, empty],
    [1, 76, "PrintScreen", 0, empty, 0, empty, empty, empty],
    [1, 77, "ScrollLock", 84, "ScrollLock", 145, "VK_SCROLL", empty, empty],
    [1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", empty, empty],
    [1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", empty, empty],
    [1, 80, "Home", 14, "Home", 36, "VK_HOME", empty, empty],
    [1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", empty, empty],
    [1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", empty, empty],
    [1, 83, "End", 13, "End", 35, "VK_END", empty, empty],
    [1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", empty, empty],
    [1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", empty],
    [1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", empty],
    [1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", empty],
    [1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", empty],
    [1, 89, "NumLock", 83, "NumLock", 144, "VK_NUMLOCK", empty, empty],
    [1, 90, "NumpadDivide", 113, "NumPad_Divide", 111, "VK_DIVIDE", empty, empty],
    [1, 91, "NumpadMultiply", 108, "NumPad_Multiply", 106, "VK_MULTIPLY", empty, empty],
    [1, 92, "NumpadSubtract", 111, "NumPad_Subtract", 109, "VK_SUBTRACT", empty, empty],
    [1, 93, "NumpadAdd", 109, "NumPad_Add", 107, "VK_ADD", empty, empty],
    [1, 94, "NumpadEnter", 3, empty, 0, empty, empty, empty],
    [1, 95, "Numpad1", 99, "NumPad1", 97, "VK_NUMPAD1", empty, empty],
    [1, 96, "Numpad2", 100, "NumPad2", 98, "VK_NUMPAD2", empty, empty],
    [1, 97, "Numpad3", 101, "NumPad3", 99, "VK_NUMPAD3", empty, empty],
    [1, 98, "Numpad4", 102, "NumPad4", 100, "VK_NUMPAD4", empty, empty],
    [1, 99, "Numpad5", 103, "NumPad5", 101, "VK_NUMPAD5", empty, empty],
    [1, 100, "Numpad6", 104, "NumPad6", 102, "VK_NUMPAD6", empty, empty],
    [1, 101, "Numpad7", 105, "NumPad7", 103, "VK_NUMPAD7", empty, empty],
    [1, 102, "Numpad8", 106, "NumPad8", 104, "VK_NUMPAD8", empty, empty],
    [1, 103, "Numpad9", 107, "NumPad9", 105, "VK_NUMPAD9", empty, empty],
    [1, 104, "Numpad0", 98, "NumPad0", 96, "VK_NUMPAD0", empty, empty],
    [1, 105, "NumpadDecimal", 112, "NumPad_Decimal", 110, "VK_DECIMAL", empty, empty],
    [0, 106, "IntlBackslash", 97, "OEM_102", 226, "VK_OEM_102", empty, empty],
    [1, 107, "ContextMenu", 58, "ContextMenu", 93, empty, empty, empty],
    [1, 108, "Power", 0, empty, 0, empty, empty, empty],
    [1, 109, "NumpadEqual", 0, empty, 0, empty, empty, empty],
    [1, 110, "F13", 71, "F13", 124, "VK_F13", empty, empty],
    [1, 111, "F14", 72, "F14", 125, "VK_F14", empty, empty],
    [1, 112, "F15", 73, "F15", 126, "VK_F15", empty, empty],
    [1, 113, "F16", 74, "F16", 127, "VK_F16", empty, empty],
    [1, 114, "F17", 75, "F17", 128, "VK_F17", empty, empty],
    [1, 115, "F18", 76, "F18", 129, "VK_F18", empty, empty],
    [1, 116, "F19", 77, "F19", 130, "VK_F19", empty, empty],
    [1, 117, "F20", 78, "F20", 131, "VK_F20", empty, empty],
    [1, 118, "F21", 79, "F21", 132, "VK_F21", empty, empty],
    [1, 119, "F22", 80, "F22", 133, "VK_F22", empty, empty],
    [1, 120, "F23", 81, "F23", 134, "VK_F23", empty, empty],
    [1, 121, "F24", 82, "F24", 135, "VK_F24", empty, empty],
    [1, 122, "Open", 0, empty, 0, empty, empty, empty],
    [1, 123, "Help", 0, empty, 0, empty, empty, empty],
    [1, 124, "Select", 0, empty, 0, empty, empty, empty],
    [1, 125, "Again", 0, empty, 0, empty, empty, empty],
    [1, 126, "Undo", 0, empty, 0, empty, empty, empty],
    [1, 127, "Cut", 0, empty, 0, empty, empty, empty],
    [1, 128, "Copy", 0, empty, 0, empty, empty, empty],
    [1, 129, "Paste", 0, empty, 0, empty, empty, empty],
    [1, 130, "Find", 0, empty, 0, empty, empty, empty],
    [1, 131, "AudioVolumeMute", 117, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", empty, empty],
    [1, 132, "AudioVolumeUp", 118, "AudioVolumeUp", 175, "VK_VOLUME_UP", empty, empty],
    [1, 133, "AudioVolumeDown", 119, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", empty, empty],
    [1, 134, "NumpadComma", 110, "NumPad_Separator", 108, "VK_SEPARATOR", empty, empty],
    [0, 135, "IntlRo", 115, "ABNT_C1", 193, "VK_ABNT_C1", empty, empty],
    [1, 136, "KanaMode", 0, empty, 0, empty, empty, empty],
    [0, 137, "IntlYen", 0, empty, 0, empty, empty, empty],
    [1, 138, "Convert", 0, empty, 0, empty, empty, empty],
    [1, 139, "NonConvert", 0, empty, 0, empty, empty, empty],
    [1, 140, "Lang1", 0, empty, 0, empty, empty, empty],
    [1, 141, "Lang2", 0, empty, 0, empty, empty, empty],
    [1, 142, "Lang3", 0, empty, 0, empty, empty, empty],
    [1, 143, "Lang4", 0, empty, 0, empty, empty, empty],
    [1, 144, "Lang5", 0, empty, 0, empty, empty, empty],
    [1, 145, "Abort", 0, empty, 0, empty, empty, empty],
    [1, 146, "Props", 0, empty, 0, empty, empty, empty],
    [1, 147, "NumpadParenLeft", 0, empty, 0, empty, empty, empty],
    [1, 148, "NumpadParenRight", 0, empty, 0, empty, empty, empty],
    [1, 149, "NumpadBackspace", 0, empty, 0, empty, empty, empty],
    [1, 150, "NumpadMemoryStore", 0, empty, 0, empty, empty, empty],
    [1, 151, "NumpadMemoryRecall", 0, empty, 0, empty, empty, empty],
    [1, 152, "NumpadMemoryClear", 0, empty, 0, empty, empty, empty],
    [1, 153, "NumpadMemoryAdd", 0, empty, 0, empty, empty, empty],
    [1, 154, "NumpadMemorySubtract", 0, empty, 0, empty, empty, empty],
    [1, 155, "NumpadClear", 131, "Clear", 12, "VK_CLEAR", empty, empty],
    [1, 156, "NumpadClearEntry", 0, empty, 0, empty, empty, empty],
    [1, 0, empty, 5, "Ctrl", 17, "VK_CONTROL", empty, empty],
    [1, 0, empty, 4, "Shift", 16, "VK_SHIFT", empty, empty],
    [1, 0, empty, 6, "Alt", 18, "VK_MENU", empty, empty],
    [1, 0, empty, 57, "Meta", 91, "VK_COMMAND", empty, empty],
    [1, 157, "ControlLeft", 5, empty, 0, "VK_LCONTROL", empty, empty],
    [1, 158, "ShiftLeft", 4, empty, 0, "VK_LSHIFT", empty, empty],
    [1, 159, "AltLeft", 6, empty, 0, "VK_LMENU", empty, empty],
    [1, 160, "MetaLeft", 57, empty, 0, "VK_LWIN", empty, empty],
    [1, 161, "ControlRight", 5, empty, 0, "VK_RCONTROL", empty, empty],
    [1, 162, "ShiftRight", 4, empty, 0, "VK_RSHIFT", empty, empty],
    [1, 163, "AltRight", 6, empty, 0, "VK_RMENU", empty, empty],
    [1, 164, "MetaRight", 57, empty, 0, "VK_RWIN", empty, empty],
    [1, 165, "BrightnessUp", 0, empty, 0, empty, empty, empty],
    [1, 166, "BrightnessDown", 0, empty, 0, empty, empty, empty],
    [1, 167, "MediaPlay", 0, empty, 0, empty, empty, empty],
    [1, 168, "MediaRecord", 0, empty, 0, empty, empty, empty],
    [1, 169, "MediaFastForward", 0, empty, 0, empty, empty, empty],
    [1, 170, "MediaRewind", 0, empty, 0, empty, empty, empty],
    [1, 171, "MediaTrackNext", 124, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", empty, empty],
    [1, 172, "MediaTrackPrevious", 125, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", empty, empty],
    [1, 173, "MediaStop", 126, "MediaStop", 178, "VK_MEDIA_STOP", empty, empty],
    [1, 174, "Eject", 0, empty, 0, empty, empty, empty],
    [1, 175, "MediaPlayPause", 127, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", empty, empty],
    [1, 176, "MediaSelect", 128, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", empty, empty],
    [1, 177, "LaunchMail", 129, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", empty, empty],
    [1, 178, "LaunchApp2", 130, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", empty, empty],
    [1, 179, "LaunchApp1", 0, empty, 0, "VK_MEDIA_LAUNCH_APP1", empty, empty],
    [1, 180, "SelectTask", 0, empty, 0, empty, empty, empty],
    [1, 181, "LaunchScreenSaver", 0, empty, 0, empty, empty, empty],
    [1, 182, "BrowserSearch", 120, "BrowserSearch", 170, "VK_BROWSER_SEARCH", empty, empty],
    [1, 183, "BrowserHome", 121, "BrowserHome", 172, "VK_BROWSER_HOME", empty, empty],
    [1, 184, "BrowserBack", 122, "BrowserBack", 166, "VK_BROWSER_BACK", empty, empty],
    [1, 185, "BrowserForward", 123, "BrowserForward", 167, "VK_BROWSER_FORWARD", empty, empty],
    [1, 186, "BrowserStop", 0, empty, 0, "VK_BROWSER_STOP", empty, empty],
    [1, 187, "BrowserRefresh", 0, empty, 0, "VK_BROWSER_REFRESH", empty, empty],
    [1, 188, "BrowserFavorites", 0, empty, 0, "VK_BROWSER_FAVORITES", empty, empty],
    [1, 189, "ZoomToggle", 0, empty, 0, empty, empty, empty],
    [1, 190, "MailReply", 0, empty, 0, empty, empty, empty],
    [1, 191, "MailForward", 0, empty, 0, empty, empty, empty],
    [1, 192, "MailSend", 0, empty, 0, empty, empty, empty],
    // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
    // If an Input Method Editor is processing key input and the event is keydown, return 229.
    [1, 0, empty, 114, "KeyInComposition", 229, empty, empty, empty],
    [1, 0, empty, 116, "ABNT_C2", 194, "VK_ABNT_C2", empty, empty],
    [1, 0, empty, 96, "OEM_8", 223, "VK_OEM_8", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_KANA", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_HANGUL", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_JUNJA", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_FINAL", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_HANJA", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_KANJI", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_CONVERT", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_NONCONVERT", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_ACCEPT", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_MODECHANGE", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_SELECT", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_PRINT", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_EXECUTE", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_SNAPSHOT", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_HELP", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_APPS", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_PROCESSKEY", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_PACKET", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_DBE_SBCSCHAR", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_DBE_DBCSCHAR", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_ATTN", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_CRSEL", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_EXSEL", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_EREOF", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_PLAY", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_ZOOM", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_NONAME", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_PA1", empty, empty],
    [1, 0, empty, 0, empty, 0, "VK_OEM_CLEAR", empty, empty]
  ];
  const seenKeyCode = [];
  const seenScanCode = [];
  for (const mapping of mappings) {
    const [immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;
    if (!seenScanCode[scanCode]) {
      seenScanCode[scanCode] = true;
      scanCodeIntToStr[scanCode] = scanCodeStr;
      scanCodeStrToInt[scanCodeStr] = scanCode;
      scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;
      if (immutable) {
        IMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;
        if (keyCode !== 0 && keyCode !== 3 && keyCode !== 5 && keyCode !== 4 && keyCode !== 6 && keyCode !== 57) {
          IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;
        }
      }
    }
    if (!seenKeyCode[keyCode]) {
      seenKeyCode[keyCode] = true;
      if (!keyCodeStr) {
        throw new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);
      }
      uiMap.define(keyCode, keyCodeStr);
      userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);
      userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);
    }
    if (eventKeyCode) {
      EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;
    }
    if (vkey) {
      NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;
    }
  }
  IMMUTABLE_KEY_CODE_TO_CODE[
    3
    /* KeyCode.Enter */
  ] = 46;
})();
var KeyCodeUtils;
(function(KeyCodeUtils2) {
  function toString(keyCode) {
    return uiMap.keyCodeToStr(keyCode);
  }
  KeyCodeUtils2.toString = toString;
  function fromString(key) {
    return uiMap.strToKeyCode(key);
  }
  KeyCodeUtils2.fromString = fromString;
  function toUserSettingsUS(keyCode) {
    return userSettingsUSMap.keyCodeToStr(keyCode);
  }
  KeyCodeUtils2.toUserSettingsUS = toUserSettingsUS;
  function toUserSettingsGeneral(keyCode) {
    return userSettingsGeneralMap.keyCodeToStr(keyCode);
  }
  KeyCodeUtils2.toUserSettingsGeneral = toUserSettingsGeneral;
  function fromUserSettings(key) {
    return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);
  }
  KeyCodeUtils2.fromUserSettings = fromUserSettings;
  function toElectronAccelerator(keyCode) {
    if (keyCode >= 98 && keyCode <= 113) {
      return null;
    }
    switch (keyCode) {
      case 16:
        return "Up";
      case 18:
        return "Down";
      case 15:
        return "Left";
      case 17:
        return "Right";
    }
    return uiMap.keyCodeToStr(keyCode);
  }
  KeyCodeUtils2.toElectronAccelerator = toElectronAccelerator;
})(KeyCodeUtils || (KeyCodeUtils = {}));
function KeyChord(firstPart, secondPart) {
  const chordPart = (secondPart & 65535) << 16 >>> 0;
  return (firstPart | chordPart) >>> 0;
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/core/selection.js
var Selection = class _Selection extends Range {
  constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
    super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
    this.selectionStartLineNumber = selectionStartLineNumber;
    this.selectionStartColumn = selectionStartColumn;
    this.positionLineNumber = positionLineNumber;
    this.positionColumn = positionColumn;
  }
  /**
   * Transform to a human-readable representation.
   */
  toString() {
    return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
  }
  /**
   * Test if equals other selection.
   */
  equalsSelection(other) {
    return _Selection.selectionsEqual(this, other);
  }
  /**
   * Test if the two selections are equal.
   */
  static selectionsEqual(a2, b) {
    return a2.selectionStartLineNumber === b.selectionStartLineNumber && a2.selectionStartColumn === b.selectionStartColumn && a2.positionLineNumber === b.positionLineNumber && a2.positionColumn === b.positionColumn;
  }
  /**
   * Get directions (LTR or RTL).
   */
  getDirection() {
    if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
      return 0;
    }
    return 1;
  }
  /**
   * Create a new selection with a different `positionLineNumber` and `positionColumn`.
   */
  setEndPosition(endLineNumber, endColumn) {
    if (this.getDirection() === 0) {
      return new _Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
    }
    return new _Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
  }
  /**
   * Get the position at `positionLineNumber` and `positionColumn`.
   */
  getPosition() {
    return new Position(this.positionLineNumber, this.positionColumn);
  }
  /**
   * Get the position at the start of the selection.
  */
  getSelectionStart() {
    return new Position(this.selectionStartLineNumber, this.selectionStartColumn);
  }
  /**
   * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
   */
  setStartPosition(startLineNumber, startColumn) {
    if (this.getDirection() === 0) {
      return new _Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
    }
    return new _Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
  }
  // ----
  /**
   * Create a `Selection` from one or two positions
   */
  static fromPositions(start, end = start) {
    return new _Selection(start.lineNumber, start.column, end.lineNumber, end.column);
  }
  /**
   * Creates a `Selection` from a range, given a direction.
   */
  static fromRange(range, direction) {
    if (direction === 0) {
      return new _Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
    } else {
      return new _Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);
    }
  }
  /**
   * Create a `Selection` from an `ISelection`.
   */
  static liftSelection(sel) {
    return new _Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
  }
  /**
   * `a` equals `b`.
   */
  static selectionsArrEqual(a2, b) {
    if (a2 && !b || !a2 && b) {
      return false;
    }
    if (!a2 && !b) {
      return true;
    }
    if (a2.length !== b.length) {
      return false;
    }
    for (let i = 0, len = a2.length; i < len; i++) {
      if (!this.selectionsEqual(a2[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Test if `obj` is an `ISelection`.
   */
  static isISelection(obj) {
    return obj && typeof obj.selectionStartLineNumber === "number" && typeof obj.selectionStartColumn === "number" && typeof obj.positionLineNumber === "number" && typeof obj.positionColumn === "number";
  }
  /**
   * Create with a direction.
   */
  static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {
    if (direction === 0) {
      return new _Selection(startLineNumber, startColumn, endLineNumber, endColumn);
    }
    return new _Selection(endLineNumber, endColumn, startLineNumber, startColumn);
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/codicons.js
var _codiconFontCharacters = /* @__PURE__ */ Object.create(null);
function register(id, fontCharacter) {
  if (isString(fontCharacter)) {
    const val = _codiconFontCharacters[fontCharacter];
    if (val === void 0) {
      throw new Error(`${id} references an unknown codicon: ${fontCharacter}`);
    }
    fontCharacter = val;
  }
  _codiconFontCharacters[id] = fontCharacter;
  return { id };
}
var Codicon = {
  // built-in icons, with image name
  add: register("add", 6e4),
  plus: register("plus", 6e4),
  gistNew: register("gist-new", 6e4),
  repoCreate: register("repo-create", 6e4),
  lightbulb: register("lightbulb", 60001),
  lightBulb: register("light-bulb", 60001),
  repo: register("repo", 60002),
  repoDelete: register("repo-delete", 60002),
  gistFork: register("gist-fork", 60003),
  repoForked: register("repo-forked", 60003),
  gitPullRequest: register("git-pull-request", 60004),
  gitPullRequestAbandoned: register("git-pull-request-abandoned", 60004),
  recordKeys: register("record-keys", 60005),
  keyboard: register("keyboard", 60005),
  tag: register("tag", 60006),
  tagAdd: register("tag-add", 60006),
  tagRemove: register("tag-remove", 60006),
  gitPullRequestLabel: register("git-pull-request-label", 60006),
  person: register("person", 60007),
  personFollow: register("person-follow", 60007),
  personOutline: register("person-outline", 60007),
  personFilled: register("person-filled", 60007),
  gitBranch: register("git-branch", 60008),
  gitBranchCreate: register("git-branch-create", 60008),
  gitBranchDelete: register("git-branch-delete", 60008),
  sourceControl: register("source-control", 60008),
  mirror: register("mirror", 60009),
  mirrorPublic: register("mirror-public", 60009),
  star: register("star", 60010),
  starAdd: register("star-add", 60010),
  starDelete: register("star-delete", 60010),
  starEmpty: register("star-empty", 60010),
  comment: register("comment", 60011),
  commentAdd: register("comment-add", 60011),
  alert: register("alert", 60012),
  warning: register("warning", 60012),
  search: register("search", 60013),
  searchSave: register("search-save", 60013),
  logOut: register("log-out", 60014),
  signOut: register("sign-out", 60014),
  logIn: register("log-in", 60015),
  signIn: register("sign-in", 60015),
  eye: register("eye", 60016),
  eyeUnwatch: register("eye-unwatch", 60016),
  eyeWatch: register("eye-watch", 60016),
  circleFilled: register("circle-filled", 60017),
  primitiveDot: register("primitive-dot", 60017),
  closeDirty: register("close-dirty", 60017),
  debugBreakpoint: register("debug-breakpoint", 60017),
  debugBreakpointDisabled: register("debug-breakpoint-disabled", 60017),
  debugBreakpointPending: register("debug-breakpoint-pending", 60377),
  debugHint: register("debug-hint", 60017),
  primitiveSquare: register("primitive-square", 60018),
  edit: register("edit", 60019),
  pencil: register("pencil", 60019),
  info: register("info", 60020),
  issueOpened: register("issue-opened", 60020),
  gistPrivate: register("gist-private", 60021),
  gitForkPrivate: register("git-fork-private", 60021),
  lock: register("lock", 60021),
  mirrorPrivate: register("mirror-private", 60021),
  close: register("close", 60022),
  removeClose: register("remove-close", 60022),
  x: register("x", 60022),
  repoSync: register("repo-sync", 60023),
  sync: register("sync", 60023),
  clone: register("clone", 60024),
  desktopDownload: register("desktop-download", 60024),
  beaker: register("beaker", 60025),
  microscope: register("microscope", 60025),
  vm: register("vm", 60026),
  deviceDesktop: register("device-desktop", 60026),
  file: register("file", 60027),
  fileText: register("file-text", 60027),
  more: register("more", 60028),
  ellipsis: register("ellipsis", 60028),
  kebabHorizontal: register("kebab-horizontal", 60028),
  mailReply: register("mail-reply", 60029),
  reply: register("reply", 60029),
  organization: register("organization", 60030),
  organizationFilled: register("organization-filled", 60030),
  organizationOutline: register("organization-outline", 60030),
  newFile: register("new-file", 60031),
  fileAdd: register("file-add", 60031),
  newFolder: register("new-folder", 60032),
  fileDirectoryCreate: register("file-directory-create", 60032),
  trash: register("trash", 60033),
  trashcan: register("trashcan", 60033),
  history: register("history", 60034),
  clock: register("clock", 60034),
  folder: register("folder", 60035),
  fileDirectory: register("file-directory", 60035),
  symbolFolder: register("symbol-folder", 60035),
  logoGithub: register("logo-github", 60036),
  markGithub: register("mark-github", 60036),
  github: register("github", 60036),
  terminal: register("terminal", 60037),
  console: register("console", 60037),
  repl: register("repl", 60037),
  zap: register("zap", 60038),
  symbolEvent: register("symbol-event", 60038),
  error: register("error", 60039),
  stop: register("stop", 60039),
  variable: register("variable", 60040),
  symbolVariable: register("symbol-variable", 60040),
  array: register("array", 60042),
  symbolArray: register("symbol-array", 60042),
  symbolModule: register("symbol-module", 60043),
  symbolPackage: register("symbol-package", 60043),
  symbolNamespace: register("symbol-namespace", 60043),
  symbolObject: register("symbol-object", 60043),
  symbolMethod: register("symbol-method", 60044),
  symbolFunction: register("symbol-function", 60044),
  symbolConstructor: register("symbol-constructor", 60044),
  symbolBoolean: register("symbol-boolean", 60047),
  symbolNull: register("symbol-null", 60047),
  symbolNumeric: register("symbol-numeric", 60048),
  symbolNumber: register("symbol-number", 60048),
  symbolStructure: register("symbol-structure", 60049),
  symbolStruct: register("symbol-struct", 60049),
  symbolParameter: register("symbol-parameter", 60050),
  symbolTypeParameter: register("symbol-type-parameter", 60050),
  symbolKey: register("symbol-key", 60051),
  symbolText: register("symbol-text", 60051),
  symbolReference: register("symbol-reference", 60052),
  goToFile: register("go-to-file", 60052),
  symbolEnum: register("symbol-enum", 60053),
  symbolValue: register("symbol-value", 60053),
  symbolRuler: register("symbol-ruler", 60054),
  symbolUnit: register("symbol-unit", 60054),
  activateBreakpoints: register("activate-breakpoints", 60055),
  archive: register("archive", 60056),
  arrowBoth: register("arrow-both", 60057),
  arrowDown: register("arrow-down", 60058),
  arrowLeft: register("arrow-left", 60059),
  arrowRight: register("arrow-right", 60060),
  arrowSmallDown: register("arrow-small-down", 60061),
  arrowSmallLeft: register("arrow-small-left", 60062),
  arrowSmallRight: register("arrow-small-right", 60063),
  arrowSmallUp: register("arrow-small-up", 60064),
  arrowUp: register("arrow-up", 60065),
  bell: register("bell", 60066),
  bold: register("bold", 60067),
  book: register("book", 60068),
  bookmark: register("bookmark", 60069),
  debugBreakpointConditionalUnverified: register("debug-breakpoint-conditional-unverified", 60070),
  debugBreakpointConditional: register("debug-breakpoint-conditional", 60071),
  debugBreakpointConditionalDisabled: register("debug-breakpoint-conditional-disabled", 60071),
  debugBreakpointDataUnverified: register("debug-breakpoint-data-unverified", 60072),
  debugBreakpointData: register("debug-breakpoint-data", 60073),
  debugBreakpointDataDisabled: register("debug-breakpoint-data-disabled", 60073),
  debugBreakpointLogUnverified: register("debug-breakpoint-log-unverified", 60074),
  debugBreakpointLog: register("debug-breakpoint-log", 60075),
  debugBreakpointLogDisabled: register("debug-breakpoint-log-disabled", 60075),
  briefcase: register("briefcase", 60076),
  broadcast: register("broadcast", 60077),
  browser: register("browser", 60078),
  bug: register("bug", 60079),
  calendar: register("calendar", 60080),
  caseSensitive: register("case-sensitive", 60081),
  check: register("check", 60082),
  checklist: register("checklist", 60083),
  chevronDown: register("chevron-down", 60084),
  dropDownButton: register("drop-down-button", 60084),
  chevronLeft: register("chevron-left", 60085),
  chevronRight: register("chevron-right", 60086),
  chevronUp: register("chevron-up", 60087),
  chromeClose: register("chrome-close", 60088),
  chromeMaximize: register("chrome-maximize", 60089),
  chromeMinimize: register("chrome-minimize", 60090),
  chromeRestore: register("chrome-restore", 60091),
  circle: register("circle", 60092),
  circleOutline: register("circle-outline", 60092),
  debugBreakpointUnverified: register("debug-breakpoint-unverified", 60092),
  circleSlash: register("circle-slash", 60093),
  circuitBoard: register("circuit-board", 60094),
  clearAll: register("clear-all", 60095),
  clippy: register("clippy", 60096),
  closeAll: register("close-all", 60097),
  cloudDownload: register("cloud-download", 60098),
  cloudUpload: register("cloud-upload", 60099),
  code: register("code", 60100),
  collapseAll: register("collapse-all", 60101),
  colorMode: register("color-mode", 60102),
  commentDiscussion: register("comment-discussion", 60103),
  compareChanges: register("compare-changes", 60157),
  creditCard: register("credit-card", 60105),
  dash: register("dash", 60108),
  dashboard: register("dashboard", 60109),
  database: register("database", 60110),
  debugContinue: register("debug-continue", 60111),
  debugDisconnect: register("debug-disconnect", 60112),
  debugPause: register("debug-pause", 60113),
  debugRestart: register("debug-restart", 60114),
  debugStart: register("debug-start", 60115),
  debugStepInto: register("debug-step-into", 60116),
  debugStepOut: register("debug-step-out", 60117),
  debugStepOver: register("debug-step-over", 60118),
  debugStop: register("debug-stop", 60119),
  debug: register("debug", 60120),
  deviceCameraVideo: register("device-camera-video", 60121),
  deviceCamera: register("device-camera", 60122),
  deviceMobile: register("device-mobile", 60123),
  diffAdded: register("diff-added", 60124),
  diffIgnored: register("diff-ignored", 60125),
  diffModified: register("diff-modified", 60126),
  diffRemoved: register("diff-removed", 60127),
  diffRenamed: register("diff-renamed", 60128),
  diff: register("diff", 60129),
  discard: register("discard", 60130),
  editorLayout: register("editor-layout", 60131),
  emptyWindow: register("empty-window", 60132),
  exclude: register("exclude", 60133),
  extensions: register("extensions", 60134),
  eyeClosed: register("eye-closed", 60135),
  fileBinary: register("file-binary", 60136),
  fileCode: register("file-code", 60137),
  fileMedia: register("file-media", 60138),
  filePdf: register("file-pdf", 60139),
  fileSubmodule: register("file-submodule", 60140),
  fileSymlinkDirectory: register("file-symlink-directory", 60141),
  fileSymlinkFile: register("file-symlink-file", 60142),
  fileZip: register("file-zip", 60143),
  files: register("files", 60144),
  filter: register("filter", 60145),
  flame: register("flame", 60146),
  foldDown: register("fold-down", 60147),
  foldUp: register("fold-up", 60148),
  fold: register("fold", 60149),
  folderActive: register("folder-active", 60150),
  folderOpened: register("folder-opened", 60151),
  gear: register("gear", 60152),
  gift: register("gift", 60153),
  gistSecret: register("gist-secret", 60154),
  gist: register("gist", 60155),
  gitCommit: register("git-commit", 60156),
  gitCompare: register("git-compare", 60157),
  gitMerge: register("git-merge", 60158),
  githubAction: register("github-action", 60159),
  githubAlt: register("github-alt", 60160),
  globe: register("globe", 60161),
  grabber: register("grabber", 60162),
  graph: register("graph", 60163),
  gripper: register("gripper", 60164),
  heart: register("heart", 60165),
  home: register("home", 60166),
  horizontalRule: register("horizontal-rule", 60167),
  hubot: register("hubot", 60168),
  inbox: register("inbox", 60169),
  issueClosed: register("issue-closed", 60324),
  issueReopened: register("issue-reopened", 60171),
  issues: register("issues", 60172),
  italic: register("italic", 60173),
  jersey: register("jersey", 60174),
  json: register("json", 60175),
  bracket: register("bracket", 60175),
  kebabVertical: register("kebab-vertical", 60176),
  key: register("key", 60177),
  law: register("law", 60178),
  lightbulbAutofix: register("lightbulb-autofix", 60179),
  linkExternal: register("link-external", 60180),
  link: register("link", 60181),
  listOrdered: register("list-ordered", 60182),
  listUnordered: register("list-unordered", 60183),
  liveShare: register("live-share", 60184),
  loading: register("loading", 60185),
  location: register("location", 60186),
  mailRead: register("mail-read", 60187),
  mail: register("mail", 60188),
  markdown: register("markdown", 60189),
  megaphone: register("megaphone", 60190),
  mention: register("mention", 60191),
  milestone: register("milestone", 60192),
  gitPullRequestMilestone: register("git-pull-request-milestone", 60192),
  mortarBoard: register("mortar-board", 60193),
  move: register("move", 60194),
  multipleWindows: register("multiple-windows", 60195),
  mute: register("mute", 60196),
  noNewline: register("no-newline", 60197),
  note: register("note", 60198),
  octoface: register("octoface", 60199),
  openPreview: register("open-preview", 60200),
  package: register("package", 60201),
  paintcan: register("paintcan", 60202),
  pin: register("pin", 60203),
  play: register("play", 60204),
  run: register("run", 60204),
  plug: register("plug", 60205),
  preserveCase: register("preserve-case", 60206),
  preview: register("preview", 60207),
  project: register("project", 60208),
  pulse: register("pulse", 60209),
  question: register("question", 60210),
  quote: register("quote", 60211),
  radioTower: register("radio-tower", 60212),
  reactions: register("reactions", 60213),
  references: register("references", 60214),
  refresh: register("refresh", 60215),
  regex: register("regex", 60216),
  remoteExplorer: register("remote-explorer", 60217),
  remote: register("remote", 60218),
  remove: register("remove", 60219),
  replaceAll: register("replace-all", 60220),
  replace: register("replace", 60221),
  repoClone: register("repo-clone", 60222),
  repoForcePush: register("repo-force-push", 60223),
  repoPull: register("repo-pull", 60224),
  repoPush: register("repo-push", 60225),
  report: register("report", 60226),
  requestChanges: register("request-changes", 60227),
  rocket: register("rocket", 60228),
  rootFolderOpened: register("root-folder-opened", 60229),
  rootFolder: register("root-folder", 60230),
  rss: register("rss", 60231),
  ruby: register("ruby", 60232),
  saveAll: register("save-all", 60233),
  saveAs: register("save-as", 60234),
  save: register("save", 60235),
  screenFull: register("screen-full", 60236),
  screenNormal: register("screen-normal", 60237),
  searchStop: register("search-stop", 60238),
  server: register("server", 60240),
  settingsGear: register("settings-gear", 60241),
  settings: register("settings", 60242),
  shield: register("shield", 60243),
  smiley: register("smiley", 60244),
  sortPrecedence: register("sort-precedence", 60245),
  splitHorizontal: register("split-horizontal", 60246),
  splitVertical: register("split-vertical", 60247),
  squirrel: register("squirrel", 60248),
  starFull: register("star-full", 60249),
  starHalf: register("star-half", 60250),
  symbolClass: register("symbol-class", 60251),
  symbolColor: register("symbol-color", 60252),
  symbolCustomColor: register("symbol-customcolor", 60252),
  symbolConstant: register("symbol-constant", 60253),
  symbolEnumMember: register("symbol-enum-member", 60254),
  symbolField: register("symbol-field", 60255),
  symbolFile: register("symbol-file", 60256),
  symbolInterface: register("symbol-interface", 60257),
  symbolKeyword: register("symbol-keyword", 60258),
  symbolMisc: register("symbol-misc", 60259),
  symbolOperator: register("symbol-operator", 60260),
  symbolProperty: register("symbol-property", 60261),
  wrench: register("wrench", 60261),
  wrenchSubaction: register("wrench-subaction", 60261),
  symbolSnippet: register("symbol-snippet", 60262),
  tasklist: register("tasklist", 60263),
  telescope: register("telescope", 60264),
  textSize: register("text-size", 60265),
  threeBars: register("three-bars", 60266),
  thumbsdown: register("thumbsdown", 60267),
  thumbsup: register("thumbsup", 60268),
  tools: register("tools", 60269),
  triangleDown: register("triangle-down", 60270),
  triangleLeft: register("triangle-left", 60271),
  triangleRight: register("triangle-right", 60272),
  triangleUp: register("triangle-up", 60273),
  twitter: register("twitter", 60274),
  unfold: register("unfold", 60275),
  unlock: register("unlock", 60276),
  unmute: register("unmute", 60277),
  unverified: register("unverified", 60278),
  verified: register("verified", 60279),
  versions: register("versions", 60280),
  vmActive: register("vm-active", 60281),
  vmOutline: register("vm-outline", 60282),
  vmRunning: register("vm-running", 60283),
  watch: register("watch", 60284),
  whitespace: register("whitespace", 60285),
  wholeWord: register("whole-word", 60286),
  window: register("window", 60287),
  wordWrap: register("word-wrap", 60288),
  zoomIn: register("zoom-in", 60289),
  zoomOut: register("zoom-out", 60290),
  listFilter: register("list-filter", 60291),
  listFlat: register("list-flat", 60292),
  listSelection: register("list-selection", 60293),
  selection: register("selection", 60293),
  listTree: register("list-tree", 60294),
  debugBreakpointFunctionUnverified: register("debug-breakpoint-function-unverified", 60295),
  debugBreakpointFunction: register("debug-breakpoint-function", 60296),
  debugBreakpointFunctionDisabled: register("debug-breakpoint-function-disabled", 60296),
  debugStackframeActive: register("debug-stackframe-active", 60297),
  circleSmallFilled: register("circle-small-filled", 60298),
  debugStackframeDot: register("debug-stackframe-dot", 60298),
  debugStackframe: register("debug-stackframe", 60299),
  debugStackframeFocused: register("debug-stackframe-focused", 60299),
  debugBreakpointUnsupported: register("debug-breakpoint-unsupported", 60300),
  symbolString: register("symbol-string", 60301),
  debugReverseContinue: register("debug-reverse-continue", 60302),
  debugStepBack: register("debug-step-back", 60303),
  debugRestartFrame: register("debug-restart-frame", 60304),
  callIncoming: register("call-incoming", 60306),
  callOutgoing: register("call-outgoing", 60307),
  menu: register("menu", 60308),
  expandAll: register("expand-all", 60309),
  feedback: register("feedback", 60310),
  gitPullRequestReviewer: register("git-pull-request-reviewer", 60310),
  groupByRefType: register("group-by-ref-type", 60311),
  ungroupByRefType: register("ungroup-by-ref-type", 60312),
  account: register("account", 60313),
  gitPullRequestAssignee: register("git-pull-request-assignee", 60313),
  bellDot: register("bell-dot", 60314),
  debugConsole: register("debug-console", 60315),
  library: register("library", 60316),
  output: register("output", 60317),
  runAll: register("run-all", 60318),
  syncIgnored: register("sync-ignored", 60319),
  pinned: register("pinned", 60320),
  githubInverted: register("github-inverted", 60321),
  debugAlt: register("debug-alt", 60305),
  serverProcess: register("server-process", 60322),
  serverEnvironment: register("server-environment", 60323),
  pass: register("pass", 60324),
  stopCircle: register("stop-circle", 60325),
  playCircle: register("play-circle", 60326),
  record: register("record", 60327),
  debugAltSmall: register("debug-alt-small", 60328),
  vmConnect: register("vm-connect", 60329),
  cloud: register("cloud", 60330),
  merge: register("merge", 60331),
  exportIcon: register("export", 60332),
  graphLeft: register("graph-left", 60333),
  magnet: register("magnet", 60334),
  notebook: register("notebook", 60335),
  redo: register("redo", 60336),
  checkAll: register("check-all", 60337),
  pinnedDirty: register("pinned-dirty", 60338),
  passFilled: register("pass-filled", 60339),
  circleLargeFilled: register("circle-large-filled", 60340),
  circleLarge: register("circle-large", 60341),
  circleLargeOutline: register("circle-large-outline", 60341),
  combine: register("combine", 60342),
  gather: register("gather", 60342),
  table: register("table", 60343),
  variableGroup: register("variable-group", 60344),
  typeHierarchy: register("type-hierarchy", 60345),
  typeHierarchySub: register("type-hierarchy-sub", 60346),
  typeHierarchySuper: register("type-hierarchy-super", 60347),
  gitPullRequestCreate: register("git-pull-request-create", 60348),
  runAbove: register("run-above", 60349),
  runBelow: register("run-below", 60350),
  notebookTemplate: register("notebook-template", 60351),
  debugRerun: register("debug-rerun", 60352),
  workspaceTrusted: register("workspace-trusted", 60353),
  workspaceUntrusted: register("workspace-untrusted", 60354),
  workspaceUnspecified: register("workspace-unspecified", 60355),
  terminalCmd: register("terminal-cmd", 60356),
  terminalDebian: register("terminal-debian", 60357),
  terminalLinux: register("terminal-linux", 60358),
  terminalPowershell: register("terminal-powershell", 60359),
  terminalTmux: register("terminal-tmux", 60360),
  terminalUbuntu: register("terminal-ubuntu", 60361),
  terminalBash: register("terminal-bash", 60362),
  arrowSwap: register("arrow-swap", 60363),
  copy: register("copy", 60364),
  personAdd: register("person-add", 60365),
  filterFilled: register("filter-filled", 60366),
  wand: register("wand", 60367),
  debugLineByLine: register("debug-line-by-line", 60368),
  inspect: register("inspect", 60369),
  layers: register("layers", 60370),
  layersDot: register("layers-dot", 60371),
  layersActive: register("layers-active", 60372),
  compass: register("compass", 60373),
  compassDot: register("compass-dot", 60374),
  compassActive: register("compass-active", 60375),
  azure: register("azure", 60376),
  issueDraft: register("issue-draft", 60377),
  gitPullRequestClosed: register("git-pull-request-closed", 60378),
  gitPullRequestDraft: register("git-pull-request-draft", 60379),
  debugAll: register("debug-all", 60380),
  debugCoverage: register("debug-coverage", 60381),
  runErrors: register("run-errors", 60382),
  folderLibrary: register("folder-library", 60383),
  debugContinueSmall: register("debug-continue-small", 60384),
  beakerStop: register("beaker-stop", 60385),
  graphLine: register("graph-line", 60386),
  graphScatter: register("graph-scatter", 60387),
  pieChart: register("pie-chart", 60388),
  bracketDot: register("bracket-dot", 60389),
  bracketError: register("bracket-error", 60390),
  lockSmall: register("lock-small", 60391),
  azureDevops: register("azure-devops", 60392),
  verifiedFilled: register("verified-filled", 60393),
  newLine: register("newline", 60394),
  layout: register("layout", 60395),
  layoutActivitybarLeft: register("layout-activitybar-left", 60396),
  layoutActivitybarRight: register("layout-activitybar-right", 60397),
  layoutPanelLeft: register("layout-panel-left", 60398),
  layoutPanelCenter: register("layout-panel-center", 60399),
  layoutPanelJustify: register("layout-panel-justify", 60400),
  layoutPanelRight: register("layout-panel-right", 60401),
  layoutPanel: register("layout-panel", 60402),
  layoutSidebarLeft: register("layout-sidebar-left", 60403),
  layoutSidebarRight: register("layout-sidebar-right", 60404),
  layoutStatusbar: register("layout-statusbar", 60405),
  layoutMenubar: register("layout-menubar", 60406),
  layoutCentered: register("layout-centered", 60407),
  layoutSidebarRightOff: register("layout-sidebar-right-off", 60416),
  layoutPanelOff: register("layout-panel-off", 60417),
  layoutSidebarLeftOff: register("layout-sidebar-left-off", 60418),
  target: register("target", 60408),
  indent: register("indent", 60409),
  recordSmall: register("record-small", 60410),
  errorSmall: register("error-small", 60411),
  arrowCircleDown: register("arrow-circle-down", 60412),
  arrowCircleLeft: register("arrow-circle-left", 60413),
  arrowCircleRight: register("arrow-circle-right", 60414),
  arrowCircleUp: register("arrow-circle-up", 60415),
  heartFilled: register("heart-filled", 60420),
  map: register("map", 60421),
  mapFilled: register("map-filled", 60422),
  circleSmall: register("circle-small", 60423),
  bellSlash: register("bell-slash", 60424),
  bellSlashDot: register("bell-slash-dot", 60425),
  commentUnresolved: register("comment-unresolved", 60426),
  gitPullRequestGoToChanges: register("git-pull-request-go-to-changes", 60427),
  gitPullRequestNewChanges: register("git-pull-request-new-changes", 60428),
  searchFuzzy: register("search-fuzzy", 60429),
  commentDraft: register("comment-draft", 60430),
  send: register("send", 60431),
  sparkle: register("sparkle", 60432),
  insert: register("insert", 60433),
  mic: register("mic", 60434),
  thumbsDownFilled: register("thumbsdown-filled", 60435),
  thumbsUpFilled: register("thumbsup-filled", 60436),
  coffee: register("coffee", 60437),
  snake: register("snake", 60438),
  game: register("game", 60439),
  vr: register("vr", 60440),
  chip: register("chip", 60441),
  piano: register("piano", 60442),
  music: register("music", 60443),
  micFilled: register("mic-filled", 60444),
  gitFetch: register("git-fetch", 60445),
  copilot: register("copilot", 60446),
  lightbulbSparkle: register("lightbulb-sparkle", 60447),
  lightbulbSparkleAutofix: register("lightbulb-sparkle-autofix", 60447),
  robot: register("robot", 60448),
  sparkleFilled: register("sparkle-filled", 60449),
  diffSingle: register("diff-single", 60450),
  diffMultiple: register("diff-multiple", 60451),
  surroundWith: register("surround-with", 60452),
  gitStash: register("git-stash", 60454),
  gitStashApply: register("git-stash-apply", 60455),
  gitStashPop: register("git-stash-pop", 60456),
  runAllCoverage: register("run-all-coverage", 60461),
  runCoverage: register("run-all-coverage", 60460),
  coverage: register("coverage", 60462),
  githubProject: register("github-project", 60463),
  // derived icons, that could become separate icons
  // TODO: These mappings should go in the vscode-codicons mapping file
  dialogError: register("dialog-error", "error"),
  dialogWarning: register("dialog-warning", "warning"),
  dialogInfo: register("dialog-info", "info"),
  dialogClose: register("dialog-close", "close"),
  treeItemExpanded: register("tree-item-expanded", "chevron-down"),
  // collapsed is done with rotation
  treeFilterOnTypeOn: register("tree-filter-on-type-on", "list-filter"),
  treeFilterOnTypeOff: register("tree-filter-on-type-off", "list-selection"),
  treeFilterClear: register("tree-filter-clear", "close"),
  treeItemLoading: register("tree-item-loading", "loading"),
  menuSelection: register("menu-selection", "check"),
  menuSubmenu: register("menu-submenu", "chevron-right"),
  menuBarMore: register("menubar-more", "more"),
  scrollbarButtonLeft: register("scrollbar-button-left", "triangle-left"),
  scrollbarButtonRight: register("scrollbar-button-right", "triangle-right"),
  scrollbarButtonUp: register("scrollbar-button-up", "triangle-up"),
  scrollbarButtonDown: register("scrollbar-button-down", "triangle-down"),
  toolBarMore: register("toolbar-more", "more"),
  quickInputBack: register("quick-input-back", "arrow-left")
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js
var TokenizationRegistry = class {
  constructor() {
    this._tokenizationSupports = /* @__PURE__ */ new Map();
    this._factories = /* @__PURE__ */ new Map();
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._colorMap = null;
  }
  handleChange(languageIds) {
    this._onDidChange.fire({
      changedLanguages: languageIds,
      changedColorMap: false
    });
  }
  register(languageId, support) {
    this._tokenizationSupports.set(languageId, support);
    this.handleChange([languageId]);
    return toDisposable(() => {
      if (this._tokenizationSupports.get(languageId) !== support) {
        return;
      }
      this._tokenizationSupports.delete(languageId);
      this.handleChange([languageId]);
    });
  }
  get(languageId) {
    return this._tokenizationSupports.get(languageId) || null;
  }
  registerFactory(languageId, factory) {
    var _a4;
    (_a4 = this._factories.get(languageId)) === null || _a4 === void 0 ? void 0 : _a4.dispose();
    const myData = new TokenizationSupportFactoryData(this, languageId, factory);
    this._factories.set(languageId, myData);
    return toDisposable(() => {
      const v = this._factories.get(languageId);
      if (!v || v !== myData) {
        return;
      }
      this._factories.delete(languageId);
      v.dispose();
    });
  }
  async getOrCreate(languageId) {
    const tokenizationSupport = this.get(languageId);
    if (tokenizationSupport) {
      return tokenizationSupport;
    }
    const factory = this._factories.get(languageId);
    if (!factory || factory.isResolved) {
      return null;
    }
    await factory.resolve();
    return this.get(languageId);
  }
  isResolved(languageId) {
    const tokenizationSupport = this.get(languageId);
    if (tokenizationSupport) {
      return true;
    }
    const factory = this._factories.get(languageId);
    if (!factory || factory.isResolved) {
      return true;
    }
    return false;
  }
  setColorMap(colorMap) {
    this._colorMap = colorMap;
    this._onDidChange.fire({
      changedLanguages: Array.from(this._tokenizationSupports.keys()),
      changedColorMap: true
    });
  }
  getColorMap() {
    return this._colorMap;
  }
  getDefaultBackground() {
    if (this._colorMap && this._colorMap.length > 2) {
      return this._colorMap[
        2
        /* ColorId.DefaultBackground */
      ];
    }
    return null;
  }
};
var TokenizationSupportFactoryData = class extends Disposable {
  get isResolved() {
    return this._isResolved;
  }
  constructor(_registry, _languageId, _factory) {
    super();
    this._registry = _registry;
    this._languageId = _languageId;
    this._factory = _factory;
    this._isDisposed = false;
    this._resolvePromise = null;
    this._isResolved = false;
  }
  dispose() {
    this._isDisposed = true;
    super.dispose();
  }
  async resolve() {
    if (!this._resolvePromise) {
      this._resolvePromise = this._create();
    }
    return this._resolvePromise;
  }
  async _create() {
    const value = await this._factory.tokenizationSupport;
    this._isResolved = true;
    if (value && !this._isDisposed) {
      this._register(this._registry.register(this._languageId, value));
    }
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/languages.js
var Token = class {
  constructor(offset, type, language) {
    this.offset = offset;
    this.type = type;
    this.language = language;
    this._tokenBrand = void 0;
  }
  toString() {
    return "(" + this.offset + ", " + this.type + ")";
  }
};
var CompletionItemKinds;
(function(CompletionItemKinds2) {
  const byKind = /* @__PURE__ */ new Map();
  byKind.set(0, Codicon.symbolMethod);
  byKind.set(1, Codicon.symbolFunction);
  byKind.set(2, Codicon.symbolConstructor);
  byKind.set(3, Codicon.symbolField);
  byKind.set(4, Codicon.symbolVariable);
  byKind.set(5, Codicon.symbolClass);
  byKind.set(6, Codicon.symbolStruct);
  byKind.set(7, Codicon.symbolInterface);
  byKind.set(8, Codicon.symbolModule);
  byKind.set(9, Codicon.symbolProperty);
  byKind.set(10, Codicon.symbolEvent);
  byKind.set(11, Codicon.symbolOperator);
  byKind.set(12, Codicon.symbolUnit);
  byKind.set(13, Codicon.symbolValue);
  byKind.set(15, Codicon.symbolEnum);
  byKind.set(14, Codicon.symbolConstant);
  byKind.set(15, Codicon.symbolEnum);
  byKind.set(16, Codicon.symbolEnumMember);
  byKind.set(17, Codicon.symbolKeyword);
  byKind.set(27, Codicon.symbolSnippet);
  byKind.set(18, Codicon.symbolText);
  byKind.set(19, Codicon.symbolColor);
  byKind.set(20, Codicon.symbolFile);
  byKind.set(21, Codicon.symbolReference);
  byKind.set(22, Codicon.symbolCustomColor);
  byKind.set(23, Codicon.symbolFolder);
  byKind.set(24, Codicon.symbolTypeParameter);
  byKind.set(25, Codicon.account);
  byKind.set(26, Codicon.issues);
  function toIcon(kind) {
    let codicon = byKind.get(kind);
    if (!codicon) {
      console.info("No codicon found for CompletionItemKind " + kind);
      codicon = Codicon.symbolProperty;
    }
    return codicon;
  }
  CompletionItemKinds2.toIcon = toIcon;
  const data = /* @__PURE__ */ new Map();
  data.set(
    "method",
    0
    /* CompletionItemKind.Method */
  );
  data.set(
    "function",
    1
    /* CompletionItemKind.Function */
  );
  data.set(
    "constructor",
    2
    /* CompletionItemKind.Constructor */
  );
  data.set(
    "field",
    3
    /* CompletionItemKind.Field */
  );
  data.set(
    "variable",
    4
    /* CompletionItemKind.Variable */
  );
  data.set(
    "class",
    5
    /* CompletionItemKind.Class */
  );
  data.set(
    "struct",
    6
    /* CompletionItemKind.Struct */
  );
  data.set(
    "interface",
    7
    /* CompletionItemKind.Interface */
  );
  data.set(
    "module",
    8
    /* CompletionItemKind.Module */
  );
  data.set(
    "property",
    9
    /* CompletionItemKind.Property */
  );
  data.set(
    "event",
    10
    /* CompletionItemKind.Event */
  );
  data.set(
    "operator",
    11
    /* CompletionItemKind.Operator */
  );
  data.set(
    "unit",
    12
    /* CompletionItemKind.Unit */
  );
  data.set(
    "value",
    13
    /* CompletionItemKind.Value */
  );
  data.set(
    "constant",
    14
    /* CompletionItemKind.Constant */
  );
  data.set(
    "enum",
    15
    /* CompletionItemKind.Enum */
  );
  data.set(
    "enum-member",
    16
    /* CompletionItemKind.EnumMember */
  );
  data.set(
    "enumMember",
    16
    /* CompletionItemKind.EnumMember */
  );
  data.set(
    "keyword",
    17
    /* CompletionItemKind.Keyword */
  );
  data.set(
    "snippet",
    27
    /* CompletionItemKind.Snippet */
  );
  data.set(
    "text",
    18
    /* CompletionItemKind.Text */
  );
  data.set(
    "color",
    19
    /* CompletionItemKind.Color */
  );
  data.set(
    "file",
    20
    /* CompletionItemKind.File */
  );
  data.set(
    "reference",
    21
    /* CompletionItemKind.Reference */
  );
  data.set(
    "customcolor",
    22
    /* CompletionItemKind.Customcolor */
  );
  data.set(
    "folder",
    23
    /* CompletionItemKind.Folder */
  );
  data.set(
    "type-parameter",
    24
    /* CompletionItemKind.TypeParameter */
  );
  data.set(
    "typeParameter",
    24
    /* CompletionItemKind.TypeParameter */
  );
  data.set(
    "account",
    25
    /* CompletionItemKind.User */
  );
  data.set(
    "issue",
    26
    /* CompletionItemKind.Issue */
  );
  function fromString(value, strict) {
    let res = data.get(value);
    if (typeof res === "undefined" && !strict) {
      res = 9;
    }
    return res;
  }
  CompletionItemKinds2.fromString = fromString;
})(CompletionItemKinds || (CompletionItemKinds = {}));
var InlineCompletionTriggerKind;
(function(InlineCompletionTriggerKind4) {
  InlineCompletionTriggerKind4[InlineCompletionTriggerKind4["Automatic"] = 0] = "Automatic";
  InlineCompletionTriggerKind4[InlineCompletionTriggerKind4["Explicit"] = 1] = "Explicit";
})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
var SignatureHelpTriggerKind;
(function(SignatureHelpTriggerKind3) {
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
var DocumentHighlightKind;
(function(DocumentHighlightKind4) {
  DocumentHighlightKind4[DocumentHighlightKind4["Text"] = 0] = "Text";
  DocumentHighlightKind4[DocumentHighlightKind4["Read"] = 1] = "Read";
  DocumentHighlightKind4[DocumentHighlightKind4["Write"] = 2] = "Write";
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
var symbolKindNames = {
  [
    17
    /* SymbolKind.Array */
  ]: localize("Array", "array"),
  [
    16
    /* SymbolKind.Boolean */
  ]: localize("Boolean", "boolean"),
  [
    4
    /* SymbolKind.Class */
  ]: localize("Class", "class"),
  [
    13
    /* SymbolKind.Constant */
  ]: localize("Constant", "constant"),
  [
    8
    /* SymbolKind.Constructor */
  ]: localize("Constructor", "constructor"),
  [
    9
    /* SymbolKind.Enum */
  ]: localize("Enum", "enumeration"),
  [
    21
    /* SymbolKind.EnumMember */
  ]: localize("EnumMember", "enumeration member"),
  [
    23
    /* SymbolKind.Event */
  ]: localize("Event", "event"),
  [
    7
    /* SymbolKind.Field */
  ]: localize("Field", "field"),
  [
    0
    /* SymbolKind.File */
  ]: localize("File", "file"),
  [
    11
    /* SymbolKind.Function */
  ]: localize("Function", "function"),
  [
    10
    /* SymbolKind.Interface */
  ]: localize("Interface", "interface"),
  [
    19
    /* SymbolKind.Key */
  ]: localize("Key", "key"),
  [
    5
    /* SymbolKind.Method */
  ]: localize("Method", "method"),
  [
    1
    /* SymbolKind.Module */
  ]: localize("Module", "module"),
  [
    2
    /* SymbolKind.Namespace */
  ]: localize("Namespace", "namespace"),
  [
    20
    /* SymbolKind.Null */
  ]: localize("Null", "null"),
  [
    15
    /* SymbolKind.Number */
  ]: localize("Number", "number"),
  [
    18
    /* SymbolKind.Object */
  ]: localize("Object", "object"),
  [
    24
    /* SymbolKind.Operator */
  ]: localize("Operator", "operator"),
  [
    3
    /* SymbolKind.Package */
  ]: localize("Package", "package"),
  [
    6
    /* SymbolKind.Property */
  ]: localize("Property", "property"),
  [
    14
    /* SymbolKind.String */
  ]: localize("String", "string"),
  [
    22
    /* SymbolKind.Struct */
  ]: localize("Struct", "struct"),
  [
    25
    /* SymbolKind.TypeParameter */
  ]: localize("TypeParameter", "type parameter"),
  [
    12
    /* SymbolKind.Variable */
  ]: localize("Variable", "variable")
};
var SymbolKinds;
(function(SymbolKinds2) {
  const byKind = /* @__PURE__ */ new Map();
  byKind.set(0, Codicon.symbolFile);
  byKind.set(1, Codicon.symbolModule);
  byKind.set(2, Codicon.symbolNamespace);
  byKind.set(3, Codicon.symbolPackage);
  byKind.set(4, Codicon.symbolClass);
  byKind.set(5, Codicon.symbolMethod);
  byKind.set(6, Codicon.symbolProperty);
  byKind.set(7, Codicon.symbolField);
  byKind.set(8, Codicon.symbolConstructor);
  byKind.set(9, Codicon.symbolEnum);
  byKind.set(10, Codicon.symbolInterface);
  byKind.set(11, Codicon.symbolFunction);
  byKind.set(12, Codicon.symbolVariable);
  byKind.set(13, Codicon.symbolConstant);
  byKind.set(14, Codicon.symbolString);
  byKind.set(15, Codicon.symbolNumber);
  byKind.set(16, Codicon.symbolBoolean);
  byKind.set(17, Codicon.symbolArray);
  byKind.set(18, Codicon.symbolObject);
  byKind.set(19, Codicon.symbolKey);
  byKind.set(20, Codicon.symbolNull);
  byKind.set(21, Codicon.symbolEnumMember);
  byKind.set(22, Codicon.symbolStruct);
  byKind.set(23, Codicon.symbolEvent);
  byKind.set(24, Codicon.symbolOperator);
  byKind.set(25, Codicon.symbolTypeParameter);
  function toIcon(kind) {
    let icon = byKind.get(kind);
    if (!icon) {
      console.info("No codicon found for SymbolKind " + kind);
      icon = Codicon.symbolProperty;
    }
    return icon;
  }
  SymbolKinds2.toIcon = toIcon;
})(SymbolKinds || (SymbolKinds = {}));
var FoldingRangeKind = class _FoldingRangeKind {
  /**
   * Returns a {@link FoldingRangeKind} for the given value.
   *
   * @param value of the kind.
   */
  static fromValue(value) {
    switch (value) {
      case "comment":
        return _FoldingRangeKind.Comment;
      case "imports":
        return _FoldingRangeKind.Imports;
      case "region":
        return _FoldingRangeKind.Region;
    }
    return new _FoldingRangeKind(value);
  }
  /**
   * Creates a new {@link FoldingRangeKind}.
   *
   * @param value of the kind.
   */
  constructor(value) {
    this.value = value;
  }
};
FoldingRangeKind.Comment = new FoldingRangeKind("comment");
FoldingRangeKind.Imports = new FoldingRangeKind("imports");
FoldingRangeKind.Region = new FoldingRangeKind("region");
var NewSymbolNameTag;
(function(NewSymbolNameTag3) {
  NewSymbolNameTag3[NewSymbolNameTag3["AIGenerated"] = 1] = "AIGenerated";
})(NewSymbolNameTag || (NewSymbolNameTag = {}));
var Command;
(function(Command3) {
  function is(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return typeof obj.id === "string" && typeof obj.title === "string";
  }
  Command3.is = is;
})(Command || (Command = {}));
var InlayHintKind;
(function(InlayHintKind4) {
  InlayHintKind4[InlayHintKind4["Type"] = 1] = "Type";
  InlayHintKind4[InlayHintKind4["Parameter"] = 2] = "Parameter";
})(InlayHintKind || (InlayHintKind = {}));
var TokenizationRegistry2 = new TokenizationRegistry();
var InlineEditTriggerKind;
(function(InlineEditTriggerKind3) {
  InlineEditTriggerKind3[InlineEditTriggerKind3["Invoke"] = 0] = "Invoke";
  InlineEditTriggerKind3[InlineEditTriggerKind3["Automatic"] = 1] = "Automatic";
})(InlineEditTriggerKind || (InlineEditTriggerKind = {}));

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js
var AccessibilitySupport;
(function(AccessibilitySupport2) {
  AccessibilitySupport2[AccessibilitySupport2["Unknown"] = 0] = "Unknown";
  AccessibilitySupport2[AccessibilitySupport2["Disabled"] = 1] = "Disabled";
  AccessibilitySupport2[AccessibilitySupport2["Enabled"] = 2] = "Enabled";
})(AccessibilitySupport || (AccessibilitySupport = {}));
var CodeActionTriggerType;
(function(CodeActionTriggerType2) {
  CodeActionTriggerType2[CodeActionTriggerType2["Invoke"] = 1] = "Invoke";
  CodeActionTriggerType2[CodeActionTriggerType2["Auto"] = 2] = "Auto";
})(CodeActionTriggerType || (CodeActionTriggerType = {}));
var CompletionItemInsertTextRule;
(function(CompletionItemInsertTextRule2) {
  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["None"] = 0] = "None";
  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["KeepWhitespace"] = 1] = "KeepWhitespace";
  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["InsertAsSnippet"] = 4] = "InsertAsSnippet";
})(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));
var CompletionItemKind;
(function(CompletionItemKind3) {
  CompletionItemKind3[CompletionItemKind3["Method"] = 0] = "Method";
  CompletionItemKind3[CompletionItemKind3["Function"] = 1] = "Function";
  CompletionItemKind3[CompletionItemKind3["Constructor"] = 2] = "Constructor";
  CompletionItemKind3[CompletionItemKind3["Field"] = 3] = "Field";
  CompletionItemKind3[CompletionItemKind3["Variable"] = 4] = "Variable";
  CompletionItemKind3[CompletionItemKind3["Class"] = 5] = "Class";
  CompletionItemKind3[CompletionItemKind3["Struct"] = 6] = "Struct";
  CompletionItemKind3[CompletionItemKind3["Interface"] = 7] = "Interface";
  CompletionItemKind3[CompletionItemKind3["Module"] = 8] = "Module";
  CompletionItemKind3[CompletionItemKind3["Property"] = 9] = "Property";
  CompletionItemKind3[CompletionItemKind3["Event"] = 10] = "Event";
  CompletionItemKind3[CompletionItemKind3["Operator"] = 11] = "Operator";
  CompletionItemKind3[CompletionItemKind3["Unit"] = 12] = "Unit";
  CompletionItemKind3[CompletionItemKind3["Value"] = 13] = "Value";
  CompletionItemKind3[CompletionItemKind3["Constant"] = 14] = "Constant";
  CompletionItemKind3[CompletionItemKind3["Enum"] = 15] = "Enum";
  CompletionItemKind3[CompletionItemKind3["EnumMember"] = 16] = "EnumMember";
  CompletionItemKind3[CompletionItemKind3["Keyword"] = 17] = "Keyword";
  CompletionItemKind3[CompletionItemKind3["Text"] = 18] = "Text";
  CompletionItemKind3[CompletionItemKind3["Color"] = 19] = "Color";
  CompletionItemKind3[CompletionItemKind3["File"] = 20] = "File";
  CompletionItemKind3[CompletionItemKind3["Reference"] = 21] = "Reference";
  CompletionItemKind3[CompletionItemKind3["Customcolor"] = 22] = "Customcolor";
  CompletionItemKind3[CompletionItemKind3["Folder"] = 23] = "Folder";
  CompletionItemKind3[CompletionItemKind3["TypeParameter"] = 24] = "TypeParameter";
  CompletionItemKind3[CompletionItemKind3["User"] = 25] = "User";
  CompletionItemKind3[CompletionItemKind3["Issue"] = 26] = "Issue";
  CompletionItemKind3[CompletionItemKind3["Snippet"] = 27] = "Snippet";
})(CompletionItemKind || (CompletionItemKind = {}));
var CompletionItemTag;
(function(CompletionItemTag3) {
  CompletionItemTag3[CompletionItemTag3["Deprecated"] = 1] = "Deprecated";
})(CompletionItemTag || (CompletionItemTag = {}));
var CompletionTriggerKind;
(function(CompletionTriggerKind2) {
  CompletionTriggerKind2[CompletionTriggerKind2["Invoke"] = 0] = "Invoke";
  CompletionTriggerKind2[CompletionTriggerKind2["TriggerCharacter"] = 1] = "TriggerCharacter";
  CompletionTriggerKind2[CompletionTriggerKind2["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
})(CompletionTriggerKind || (CompletionTriggerKind = {}));
var ContentWidgetPositionPreference;
(function(ContentWidgetPositionPreference2) {
  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["EXACT"] = 0] = "EXACT";
  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["ABOVE"] = 1] = "ABOVE";
  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["BELOW"] = 2] = "BELOW";
})(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));
var CursorChangeReason;
(function(CursorChangeReason2) {
  CursorChangeReason2[CursorChangeReason2["NotSet"] = 0] = "NotSet";
  CursorChangeReason2[CursorChangeReason2["ContentFlush"] = 1] = "ContentFlush";
  CursorChangeReason2[CursorChangeReason2["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
  CursorChangeReason2[CursorChangeReason2["Explicit"] = 3] = "Explicit";
  CursorChangeReason2[CursorChangeReason2["Paste"] = 4] = "Paste";
  CursorChangeReason2[CursorChangeReason2["Undo"] = 5] = "Undo";
  CursorChangeReason2[CursorChangeReason2["Redo"] = 6] = "Redo";
})(CursorChangeReason || (CursorChangeReason = {}));
var DefaultEndOfLine;
(function(DefaultEndOfLine2) {
  DefaultEndOfLine2[DefaultEndOfLine2["LF"] = 1] = "LF";
  DefaultEndOfLine2[DefaultEndOfLine2["CRLF"] = 2] = "CRLF";
})(DefaultEndOfLine || (DefaultEndOfLine = {}));
var DocumentHighlightKind2;
(function(DocumentHighlightKind4) {
  DocumentHighlightKind4[DocumentHighlightKind4["Text"] = 0] = "Text";
  DocumentHighlightKind4[DocumentHighlightKind4["Read"] = 1] = "Read";
  DocumentHighlightKind4[DocumentHighlightKind4["Write"] = 2] = "Write";
})(DocumentHighlightKind2 || (DocumentHighlightKind2 = {}));
var EditorAutoIndentStrategy;
(function(EditorAutoIndentStrategy2) {
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["None"] = 0] = "None";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Keep"] = 1] = "Keep";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Brackets"] = 2] = "Brackets";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Advanced"] = 3] = "Advanced";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Full"] = 4] = "Full";
})(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));
var EditorOption;
(function(EditorOption2) {
  EditorOption2[EditorOption2["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
  EditorOption2[EditorOption2["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
  EditorOption2[EditorOption2["accessibilitySupport"] = 2] = "accessibilitySupport";
  EditorOption2[EditorOption2["accessibilityPageSize"] = 3] = "accessibilityPageSize";
  EditorOption2[EditorOption2["ariaLabel"] = 4] = "ariaLabel";
  EditorOption2[EditorOption2["ariaRequired"] = 5] = "ariaRequired";
  EditorOption2[EditorOption2["autoClosingBrackets"] = 6] = "autoClosingBrackets";
  EditorOption2[EditorOption2["autoClosingComments"] = 7] = "autoClosingComments";
  EditorOption2[EditorOption2["screenReaderAnnounceInlineSuggestion"] = 8] = "screenReaderAnnounceInlineSuggestion";
  EditorOption2[EditorOption2["autoClosingDelete"] = 9] = "autoClosingDelete";
  EditorOption2[EditorOption2["autoClosingOvertype"] = 10] = "autoClosingOvertype";
  EditorOption2[EditorOption2["autoClosingQuotes"] = 11] = "autoClosingQuotes";
  EditorOption2[EditorOption2["autoIndent"] = 12] = "autoIndent";
  EditorOption2[EditorOption2["automaticLayout"] = 13] = "automaticLayout";
  EditorOption2[EditorOption2["autoSurround"] = 14] = "autoSurround";
  EditorOption2[EditorOption2["bracketPairColorization"] = 15] = "bracketPairColorization";
  EditorOption2[EditorOption2["guides"] = 16] = "guides";
  EditorOption2[EditorOption2["codeLens"] = 17] = "codeLens";
  EditorOption2[EditorOption2["codeLensFontFamily"] = 18] = "codeLensFontFamily";
  EditorOption2[EditorOption2["codeLensFontSize"] = 19] = "codeLensFontSize";
  EditorOption2[EditorOption2["colorDecorators"] = 20] = "colorDecorators";
  EditorOption2[EditorOption2["colorDecoratorsLimit"] = 21] = "colorDecoratorsLimit";
  EditorOption2[EditorOption2["columnSelection"] = 22] = "columnSelection";
  EditorOption2[EditorOption2["comments"] = 23] = "comments";
  EditorOption2[EditorOption2["contextmenu"] = 24] = "contextmenu";
  EditorOption2[EditorOption2["copyWithSyntaxHighlighting"] = 25] = "copyWithSyntaxHighlighting";
  EditorOption2[EditorOption2["cursorBlinking"] = 26] = "cursorBlinking";
  EditorOption2[EditorOption2["cursorSmoothCaretAnimation"] = 27] = "cursorSmoothCaretAnimation";
  EditorOption2[EditorOption2["cursorStyle"] = 28] = "cursorStyle";
  EditorOption2[EditorOption2["cursorSurroundingLines"] = 29] = "cursorSurroundingLines";
  EditorOption2[EditorOption2["cursorSurroundingLinesStyle"] = 30] = "cursorSurroundingLinesStyle";
  EditorOption2[EditorOption2["cursorWidth"] = 31] = "cursorWidth";
  EditorOption2[EditorOption2["disableLayerHinting"] = 32] = "disableLayerHinting";
  EditorOption2[EditorOption2["disableMonospaceOptimizations"] = 33] = "disableMonospaceOptimizations";
  EditorOption2[EditorOption2["domReadOnly"] = 34] = "domReadOnly";
  EditorOption2[EditorOption2["dragAndDrop"] = 35] = "dragAndDrop";
  EditorOption2[EditorOption2["dropIntoEditor"] = 36] = "dropIntoEditor";
  EditorOption2[EditorOption2["emptySelectionClipboard"] = 37] = "emptySelectionClipboard";
  EditorOption2[EditorOption2["experimentalWhitespaceRendering"] = 38] = "experimentalWhitespaceRendering";
  EditorOption2[EditorOption2["extraEditorClassName"] = 39] = "extraEditorClassName";
  EditorOption2[EditorOption2["fastScrollSensitivity"] = 40] = "fastScrollSensitivity";
  EditorOption2[EditorOption2["find"] = 41] = "find";
  EditorOption2[EditorOption2["fixedOverflowWidgets"] = 42] = "fixedOverflowWidgets";
  EditorOption2[EditorOption2["folding"] = 43] = "folding";
  EditorOption2[EditorOption2["foldingStrategy"] = 44] = "foldingStrategy";
  EditorOption2[EditorOption2["foldingHighlight"] = 45] = "foldingHighlight";
  EditorOption2[EditorOption2["foldingImportsByDefault"] = 46] = "foldingImportsByDefault";
  EditorOption2[EditorOption2["foldingMaximumRegions"] = 47] = "foldingMaximumRegions";
  EditorOption2[EditorOption2["unfoldOnClickAfterEndOfLine"] = 48] = "unfoldOnClickAfterEndOfLine";
  EditorOption2[EditorOption2["fontFamily"] = 49] = "fontFamily";
  EditorOption2[EditorOption2["fontInfo"] = 50] = "fontInfo";
  EditorOption2[EditorOption2["fontLigatures"] = 51] = "fontLigatures";
  EditorOption2[EditorOption2["fontSize"] = 52] = "fontSize";
  EditorOption2[EditorOption2["fontWeight"] = 53] = "fontWeight";
  EditorOption2[EditorOption2["fontVariations"] = 54] = "fontVariations";
  EditorOption2[EditorOption2["formatOnPaste"] = 55] = "formatOnPaste";
  EditorOption2[EditorOption2["formatOnType"] = 56] = "formatOnType";
  EditorOption2[EditorOption2["glyphMargin"] = 57] = "glyphMargin";
  EditorOption2[EditorOption2["gotoLocation"] = 58] = "gotoLocation";
  EditorOption2[EditorOption2["hideCursorInOverviewRuler"] = 59] = "hideCursorInOverviewRuler";
  EditorOption2[EditorOption2["hover"] = 60] = "hover";
  EditorOption2[EditorOption2["inDiffEditor"] = 61] = "inDiffEditor";
  EditorOption2[EditorOption2["inlineSuggest"] = 62] = "inlineSuggest";
  EditorOption2[EditorOption2["inlineEdit"] = 63] = "inlineEdit";
  EditorOption2[EditorOption2["letterSpacing"] = 64] = "letterSpacing";
  EditorOption2[EditorOption2["lightbulb"] = 65] = "lightbulb";
  EditorOption2[EditorOption2["lineDecorationsWidth"] = 66] = "lineDecorationsWidth";
  EditorOption2[EditorOption2["lineHeight"] = 67] = "lineHeight";
  EditorOption2[EditorOption2["lineNumbers"] = 68] = "lineNumbers";
  EditorOption2[EditorOption2["lineNumbersMinChars"] = 69] = "lineNumbersMinChars";
  EditorOption2[EditorOption2["linkedEditing"] = 70] = "linkedEditing";
  EditorOption2[EditorOption2["links"] = 71] = "links";
  EditorOption2[EditorOption2["matchBrackets"] = 72] = "matchBrackets";
  EditorOption2[EditorOption2["minimap"] = 73] = "minimap";
  EditorOption2[EditorOption2["mouseStyle"] = 74] = "mouseStyle";
  EditorOption2[EditorOption2["mouseWheelScrollSensitivity"] = 75] = "mouseWheelScrollSensitivity";
  EditorOption2[EditorOption2["mouseWheelZoom"] = 76] = "mouseWheelZoom";
  EditorOption2[EditorOption2["multiCursorMergeOverlapping"] = 77] = "multiCursorMergeOverlapping";
  EditorOption2[EditorOption2["multiCursorModifier"] = 78] = "multiCursorModifier";
  EditorOption2[EditorOption2["multiCursorPaste"] = 79] = "multiCursorPaste";
  EditorOption2[EditorOption2["multiCursorLimit"] = 80] = "multiCursorLimit";
  EditorOption2[EditorOption2["occurrencesHighlight"] = 81] = "occurrencesHighlight";
  EditorOption2[EditorOption2["overviewRulerBorder"] = 82] = "overviewRulerBorder";
  EditorOption2[EditorOption2["overviewRulerLanes"] = 83] = "overviewRulerLanes";
  EditorOption2[EditorOption2["padding"] = 84] = "padding";
  EditorOption2[EditorOption2["pasteAs"] = 85] = "pasteAs";
  EditorOption2[EditorOption2["parameterHints"] = 86] = "parameterHints";
  EditorOption2[EditorOption2["peekWidgetDefaultFocus"] = 87] = "peekWidgetDefaultFocus";
  EditorOption2[EditorOption2["definitionLinkOpensInPeek"] = 88] = "definitionLinkOpensInPeek";
  EditorOption2[EditorOption2["quickSuggestions"] = 89] = "quickSuggestions";
  EditorOption2[EditorOption2["quickSuggestionsDelay"] = 90] = "quickSuggestionsDelay";
  EditorOption2[EditorOption2["readOnly"] = 91] = "readOnly";
  EditorOption2[EditorOption2["readOnlyMessage"] = 92] = "readOnlyMessage";
  EditorOption2[EditorOption2["renameOnType"] = 93] = "renameOnType";
  EditorOption2[EditorOption2["renderControlCharacters"] = 94] = "renderControlCharacters";
  EditorOption2[EditorOption2["renderFinalNewline"] = 95] = "renderFinalNewline";
  EditorOption2[EditorOption2["renderLineHighlight"] = 96] = "renderLineHighlight";
  EditorOption2[EditorOption2["renderLineHighlightOnlyWhenFocus"] = 97] = "renderLineHighlightOnlyWhenFocus";
  EditorOption2[EditorOption2["renderValidationDecorations"] = 98] = "renderValidationDecorations";
  EditorOption2[EditorOption2["renderWhitespace"] = 99] = "renderWhitespace";
  EditorOption2[EditorOption2["revealHorizontalRightPadding"] = 100] = "revealHorizontalRightPadding";
  EditorOption2[EditorOption2["roundedSelection"] = 101] = "roundedSelection";
  EditorOption2[EditorOption2["rulers"] = 102] = "rulers";
  EditorOption2[EditorOption2["scrollbar"] = 103] = "scrollbar";
  EditorOption2[EditorOption2["scrollBeyondLastColumn"] = 104] = "scrollBeyondLastColumn";
  EditorOption2[EditorOption2["scrollBeyondLastLine"] = 105] = "scrollBeyondLastLine";
  EditorOption2[EditorOption2["scrollPredominantAxis"] = 106] = "scrollPredominantAxis";
  EditorOption2[EditorOption2["selectionClipboard"] = 107] = "selectionClipboard";
  EditorOption2[EditorOption2["selectionHighlight"] = 108] = "selectionHighlight";
  EditorOption2[EditorOption2["selectOnLineNumbers"] = 109] = "selectOnLineNumbers";
  EditorOption2[EditorOption2["showFoldingControls"] = 110] = "showFoldingControls";
  EditorOption2[EditorOption2["showUnused"] = 111] = "showUnused";
  EditorOption2[EditorOption2["snippetSuggestions"] = 112] = "snippetSuggestions";
  EditorOption2[EditorOption2["smartSelect"] = 113] = "smartSelect";
  EditorOption2[EditorOption2["smoothScrolling"] = 114] = "smoothScrolling";
  EditorOption2[EditorOption2["stickyScroll"] = 115] = "stickyScroll";
  EditorOption2[EditorOption2["stickyTabStops"] = 116] = "stickyTabStops";
  EditorOption2[EditorOption2["stopRenderingLineAfter"] = 117] = "stopRenderingLineAfter";
  EditorOption2[EditorOption2["suggest"] = 118] = "suggest";
  EditorOption2[EditorOption2["suggestFontSize"] = 119] = "suggestFontSize";
  EditorOption2[EditorOption2["suggestLineHeight"] = 120] = "suggestLineHeight";
  EditorOption2[EditorOption2["suggestOnTriggerCharacters"] = 121] = "suggestOnTriggerCharacters";
  EditorOption2[EditorOption2["suggestSelection"] = 122] = "suggestSelection";
  EditorOption2[EditorOption2["tabCompletion"] = 123] = "tabCompletion";
  EditorOption2[EditorOption2["tabIndex"] = 124] = "tabIndex";
  EditorOption2[EditorOption2["unicodeHighlighting"] = 125] = "unicodeHighlighting";
  EditorOption2[EditorOption2["unusualLineTerminators"] = 126] = "unusualLineTerminators";
  EditorOption2[EditorOption2["useShadowDOM"] = 127] = "useShadowDOM";
  EditorOption2[EditorOption2["useTabStops"] = 128] = "useTabStops";
  EditorOption2[EditorOption2["wordBreak"] = 129] = "wordBreak";
  EditorOption2[EditorOption2["wordSeparators"] = 130] = "wordSeparators";
  EditorOption2[EditorOption2["wordWrap"] = 131] = "wordWrap";
  EditorOption2[EditorOption2["wordWrapBreakAfterCharacters"] = 132] = "wordWrapBreakAfterCharacters";
  EditorOption2[EditorOption2["wordWrapBreakBeforeCharacters"] = 133] = "wordWrapBreakBeforeCharacters";
  EditorOption2[EditorOption2["wordWrapColumn"] = 134] = "wordWrapColumn";
  EditorOption2[EditorOption2["wordWrapOverride1"] = 135] = "wordWrapOverride1";
  EditorOption2[EditorOption2["wordWrapOverride2"] = 136] = "wordWrapOverride2";
  EditorOption2[EditorOption2["wrappingIndent"] = 137] = "wrappingIndent";
  EditorOption2[EditorOption2["wrappingStrategy"] = 138] = "wrappingStrategy";
  EditorOption2[EditorOption2["showDeprecated"] = 139] = "showDeprecated";
  EditorOption2[EditorOption2["inlayHints"] = 140] = "inlayHints";
  EditorOption2[EditorOption2["editorClassName"] = 141] = "editorClassName";
  EditorOption2[EditorOption2["pixelRatio"] = 142] = "pixelRatio";
  EditorOption2[EditorOption2["tabFocusMode"] = 143] = "tabFocusMode";
  EditorOption2[EditorOption2["layoutInfo"] = 144] = "layoutInfo";
  EditorOption2[EditorOption2["wrappingInfo"] = 145] = "wrappingInfo";
  EditorOption2[EditorOption2["defaultColorDecorators"] = 146] = "defaultColorDecorators";
  EditorOption2[EditorOption2["colorDecoratorsActivatedOn"] = 147] = "colorDecoratorsActivatedOn";
  EditorOption2[EditorOption2["inlineCompletionsAccessibilityVerbose"] = 148] = "inlineCompletionsAccessibilityVerbose";
})(EditorOption || (EditorOption = {}));
var EndOfLinePreference;
(function(EndOfLinePreference2) {
  EndOfLinePreference2[EndOfLinePreference2["TextDefined"] = 0] = "TextDefined";
  EndOfLinePreference2[EndOfLinePreference2["LF"] = 1] = "LF";
  EndOfLinePreference2[EndOfLinePreference2["CRLF"] = 2] = "CRLF";
})(EndOfLinePreference || (EndOfLinePreference = {}));
var EndOfLineSequence;
(function(EndOfLineSequence2) {
  EndOfLineSequence2[EndOfLineSequence2["LF"] = 0] = "LF";
  EndOfLineSequence2[EndOfLineSequence2["CRLF"] = 1] = "CRLF";
})(EndOfLineSequence || (EndOfLineSequence = {}));
var GlyphMarginLane;
(function(GlyphMarginLane3) {
  GlyphMarginLane3[GlyphMarginLane3["Left"] = 1] = "Left";
  GlyphMarginLane3[GlyphMarginLane3["Center"] = 2] = "Center";
  GlyphMarginLane3[GlyphMarginLane3["Right"] = 3] = "Right";
})(GlyphMarginLane || (GlyphMarginLane = {}));
var IndentAction;
(function(IndentAction2) {
  IndentAction2[IndentAction2["None"] = 0] = "None";
  IndentAction2[IndentAction2["Indent"] = 1] = "Indent";
  IndentAction2[IndentAction2["IndentOutdent"] = 2] = "IndentOutdent";
  IndentAction2[IndentAction2["Outdent"] = 3] = "Outdent";
})(IndentAction || (IndentAction = {}));
var InjectedTextCursorStops;
(function(InjectedTextCursorStops3) {
  InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
  InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
  InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
  InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
var InlayHintKind2;
(function(InlayHintKind4) {
  InlayHintKind4[InlayHintKind4["Type"] = 1] = "Type";
  InlayHintKind4[InlayHintKind4["Parameter"] = 2] = "Parameter";
})(InlayHintKind2 || (InlayHintKind2 = {}));
var InlineCompletionTriggerKind2;
(function(InlineCompletionTriggerKind4) {
  InlineCompletionTriggerKind4[InlineCompletionTriggerKind4["Automatic"] = 0] = "Automatic";
  InlineCompletionTriggerKind4[InlineCompletionTriggerKind4["Explicit"] = 1] = "Explicit";
})(InlineCompletionTriggerKind2 || (InlineCompletionTriggerKind2 = {}));
var InlineEditTriggerKind2;
(function(InlineEditTriggerKind3) {
  InlineEditTriggerKind3[InlineEditTriggerKind3["Invoke"] = 0] = "Invoke";
  InlineEditTriggerKind3[InlineEditTriggerKind3["Automatic"] = 1] = "Automatic";
})(InlineEditTriggerKind2 || (InlineEditTriggerKind2 = {}));
var KeyCode;
(function(KeyCode2) {
  KeyCode2[KeyCode2["DependsOnKbLayout"] = -1] = "DependsOnKbLayout";
  KeyCode2[KeyCode2["Unknown"] = 0] = "Unknown";
  KeyCode2[KeyCode2["Backspace"] = 1] = "Backspace";
  KeyCode2[KeyCode2["Tab"] = 2] = "Tab";
  KeyCode2[KeyCode2["Enter"] = 3] = "Enter";
  KeyCode2[KeyCode2["Shift"] = 4] = "Shift";
  KeyCode2[KeyCode2["Ctrl"] = 5] = "Ctrl";
  KeyCode2[KeyCode2["Alt"] = 6] = "Alt";
  KeyCode2[KeyCode2["PauseBreak"] = 7] = "PauseBreak";
  KeyCode2[KeyCode2["CapsLock"] = 8] = "CapsLock";
  KeyCode2[KeyCode2["Escape"] = 9] = "Escape";
  KeyCode2[KeyCode2["Space"] = 10] = "Space";
  KeyCode2[KeyCode2["PageUp"] = 11] = "PageUp";
  KeyCode2[KeyCode2["PageDown"] = 12] = "PageDown";
  KeyCode2[KeyCode2["End"] = 13] = "End";
  KeyCode2[KeyCode2["Home"] = 14] = "Home";
  KeyCode2[KeyCode2["LeftArrow"] = 15] = "LeftArrow";
  KeyCode2[KeyCode2["UpArrow"] = 16] = "UpArrow";
  KeyCode2[KeyCode2["RightArrow"] = 17] = "RightArrow";
  KeyCode2[KeyCode2["DownArrow"] = 18] = "DownArrow";
  KeyCode2[KeyCode2["Insert"] = 19] = "Insert";
  KeyCode2[KeyCode2["Delete"] = 20] = "Delete";
  KeyCode2[KeyCode2["Digit0"] = 21] = "Digit0";
  KeyCode2[KeyCode2["Digit1"] = 22] = "Digit1";
  KeyCode2[KeyCode2["Digit2"] = 23] = "Digit2";
  KeyCode2[KeyCode2["Digit3"] = 24] = "Digit3";
  KeyCode2[KeyCode2["Digit4"] = 25] = "Digit4";
  KeyCode2[KeyCode2["Digit5"] = 26] = "Digit5";
  KeyCode2[KeyCode2["Digit6"] = 27] = "Digit6";
  KeyCode2[KeyCode2["Digit7"] = 28] = "Digit7";
  KeyCode2[KeyCode2["Digit8"] = 29] = "Digit8";
  KeyCode2[KeyCode2["Digit9"] = 30] = "Digit9";
  KeyCode2[KeyCode2["KeyA"] = 31] = "KeyA";
  KeyCode2[KeyCode2["KeyB"] = 32] = "KeyB";
  KeyCode2[KeyCode2["KeyC"] = 33] = "KeyC";
  KeyCode2[KeyCode2["KeyD"] = 34] = "KeyD";
  KeyCode2[KeyCode2["KeyE"] = 35] = "KeyE";
  KeyCode2[KeyCode2["KeyF"] = 36] = "KeyF";
  KeyCode2[KeyCode2["KeyG"] = 37] = "KeyG";
  KeyCode2[KeyCode2["KeyH"] = 38] = "KeyH";
  KeyCode2[KeyCode2["KeyI"] = 39] = "KeyI";
  KeyCode2[KeyCode2["KeyJ"] = 40] = "KeyJ";
  KeyCode2[KeyCode2["KeyK"] = 41] = "KeyK";
  KeyCode2[KeyCode2["KeyL"] = 42] = "KeyL";
  KeyCode2[KeyCode2["KeyM"] = 43] = "KeyM";
  KeyCode2[KeyCode2["KeyN"] = 44] = "KeyN";
  KeyCode2[KeyCode2["KeyO"] = 45] = "KeyO";
  KeyCode2[KeyCode2["KeyP"] = 46] = "KeyP";
  KeyCode2[KeyCode2["KeyQ"] = 47] = "KeyQ";
  KeyCode2[KeyCode2["KeyR"] = 48] = "KeyR";
  KeyCode2[KeyCode2["KeyS"] = 49] = "KeyS";
  KeyCode2[KeyCode2["KeyT"] = 50] = "KeyT";
  KeyCode2[KeyCode2["KeyU"] = 51] = "KeyU";
  KeyCode2[KeyCode2["KeyV"] = 52] = "KeyV";
  KeyCode2[KeyCode2["KeyW"] = 53] = "KeyW";
  KeyCode2[KeyCode2["KeyX"] = 54] = "KeyX";
  KeyCode2[KeyCode2["KeyY"] = 55] = "KeyY";
  KeyCode2[KeyCode2["KeyZ"] = 56] = "KeyZ";
  KeyCode2[KeyCode2["Meta"] = 57] = "Meta";
  KeyCode2[KeyCode2["ContextMenu"] = 58] = "ContextMenu";
  KeyCode2[KeyCode2["F1"] = 59] = "F1";
  KeyCode2[KeyCode2["F2"] = 60] = "F2";
  KeyCode2[KeyCode2["F3"] = 61] = "F3";
  KeyCode2[KeyCode2["F4"] = 62] = "F4";
  KeyCode2[KeyCode2["F5"] = 63] = "F5";
  KeyCode2[KeyCode2["F6"] = 64] = "F6";
  KeyCode2[KeyCode2["F7"] = 65] = "F7";
  KeyCode2[KeyCode2["F8"] = 66] = "F8";
  KeyCode2[KeyCode2["F9"] = 67] = "F9";
  KeyCode2[KeyCode2["F10"] = 68] = "F10";
  KeyCode2[KeyCode2["F11"] = 69] = "F11";
  KeyCode2[KeyCode2["F12"] = 70] = "F12";
  KeyCode2[KeyCode2["F13"] = 71] = "F13";
  KeyCode2[KeyCode2["F14"] = 72] = "F14";
  KeyCode2[KeyCode2["F15"] = 73] = "F15";
  KeyCode2[KeyCode2["F16"] = 74] = "F16";
  KeyCode2[KeyCode2["F17"] = 75] = "F17";
  KeyCode2[KeyCode2["F18"] = 76] = "F18";
  KeyCode2[KeyCode2["F19"] = 77] = "F19";
  KeyCode2[KeyCode2["F20"] = 78] = "F20";
  KeyCode2[KeyCode2["F21"] = 79] = "F21";
  KeyCode2[KeyCode2["F22"] = 80] = "F22";
  KeyCode2[KeyCode2["F23"] = 81] = "F23";
  KeyCode2[KeyCode2["F24"] = 82] = "F24";
  KeyCode2[KeyCode2["NumLock"] = 83] = "NumLock";
  KeyCode2[KeyCode2["ScrollLock"] = 84] = "ScrollLock";
  KeyCode2[KeyCode2["Semicolon"] = 85] = "Semicolon";
  KeyCode2[KeyCode2["Equal"] = 86] = "Equal";
  KeyCode2[KeyCode2["Comma"] = 87] = "Comma";
  KeyCode2[KeyCode2["Minus"] = 88] = "Minus";
  KeyCode2[KeyCode2["Period"] = 89] = "Period";
  KeyCode2[KeyCode2["Slash"] = 90] = "Slash";
  KeyCode2[KeyCode2["Backquote"] = 91] = "Backquote";
  KeyCode2[KeyCode2["BracketLeft"] = 92] = "BracketLeft";
  KeyCode2[KeyCode2["Backslash"] = 93] = "Backslash";
  KeyCode2[KeyCode2["BracketRight"] = 94] = "BracketRight";
  KeyCode2[KeyCode2["Quote"] = 95] = "Quote";
  KeyCode2[KeyCode2["OEM_8"] = 96] = "OEM_8";
  KeyCode2[KeyCode2["IntlBackslash"] = 97] = "IntlBackslash";
  KeyCode2[KeyCode2["Numpad0"] = 98] = "Numpad0";
  KeyCode2[KeyCode2["Numpad1"] = 99] = "Numpad1";
  KeyCode2[KeyCode2["Numpad2"] = 100] = "Numpad2";
  KeyCode2[KeyCode2["Numpad3"] = 101] = "Numpad3";
  KeyCode2[KeyCode2["Numpad4"] = 102] = "Numpad4";
  KeyCode2[KeyCode2["Numpad5"] = 103] = "Numpad5";
  KeyCode2[KeyCode2["Numpad6"] = 104] = "Numpad6";
  KeyCode2[KeyCode2["Numpad7"] = 105] = "Numpad7";
  KeyCode2[KeyCode2["Numpad8"] = 106] = "Numpad8";
  KeyCode2[KeyCode2["Numpad9"] = 107] = "Numpad9";
  KeyCode2[KeyCode2["NumpadMultiply"] = 108] = "NumpadMultiply";
  KeyCode2[KeyCode2["NumpadAdd"] = 109] = "NumpadAdd";
  KeyCode2[KeyCode2["NUMPAD_SEPARATOR"] = 110] = "NUMPAD_SEPARATOR";
  KeyCode2[KeyCode2["NumpadSubtract"] = 111] = "NumpadSubtract";
  KeyCode2[KeyCode2["NumpadDecimal"] = 112] = "NumpadDecimal";
  KeyCode2[KeyCode2["NumpadDivide"] = 113] = "NumpadDivide";
  KeyCode2[KeyCode2["KEY_IN_COMPOSITION"] = 114] = "KEY_IN_COMPOSITION";
  KeyCode2[KeyCode2["ABNT_C1"] = 115] = "ABNT_C1";
  KeyCode2[KeyCode2["ABNT_C2"] = 116] = "ABNT_C2";
  KeyCode2[KeyCode2["AudioVolumeMute"] = 117] = "AudioVolumeMute";
  KeyCode2[KeyCode2["AudioVolumeUp"] = 118] = "AudioVolumeUp";
  KeyCode2[KeyCode2["AudioVolumeDown"] = 119] = "AudioVolumeDown";
  KeyCode2[KeyCode2["BrowserSearch"] = 120] = "BrowserSearch";
  KeyCode2[KeyCode2["BrowserHome"] = 121] = "BrowserHome";
  KeyCode2[KeyCode2["BrowserBack"] = 122] = "BrowserBack";
  KeyCode2[KeyCode2["BrowserForward"] = 123] = "BrowserForward";
  KeyCode2[KeyCode2["MediaTrackNext"] = 124] = "MediaTrackNext";
  KeyCode2[KeyCode2["MediaTrackPrevious"] = 125] = "MediaTrackPrevious";
  KeyCode2[KeyCode2["MediaStop"] = 126] = "MediaStop";
  KeyCode2[KeyCode2["MediaPlayPause"] = 127] = "MediaPlayPause";
  KeyCode2[KeyCode2["LaunchMediaPlayer"] = 128] = "LaunchMediaPlayer";
  KeyCode2[KeyCode2["LaunchMail"] = 129] = "LaunchMail";
  KeyCode2[KeyCode2["LaunchApp2"] = 130] = "LaunchApp2";
  KeyCode2[KeyCode2["Clear"] = 131] = "Clear";
  KeyCode2[KeyCode2["MAX_VALUE"] = 132] = "MAX_VALUE";
})(KeyCode || (KeyCode = {}));
var MarkerSeverity;
(function(MarkerSeverity2) {
  MarkerSeverity2[MarkerSeverity2["Hint"] = 1] = "Hint";
  MarkerSeverity2[MarkerSeverity2["Info"] = 2] = "Info";
  MarkerSeverity2[MarkerSeverity2["Warning"] = 4] = "Warning";
  MarkerSeverity2[MarkerSeverity2["Error"] = 8] = "Error";
})(MarkerSeverity || (MarkerSeverity = {}));
var MarkerTag;
(function(MarkerTag2) {
  MarkerTag2[MarkerTag2["Unnecessary"] = 1] = "Unnecessary";
  MarkerTag2[MarkerTag2["Deprecated"] = 2] = "Deprecated";
})(MarkerTag || (MarkerTag = {}));
var MinimapPosition;
(function(MinimapPosition3) {
  MinimapPosition3[MinimapPosition3["Inline"] = 1] = "Inline";
  MinimapPosition3[MinimapPosition3["Gutter"] = 2] = "Gutter";
})(MinimapPosition || (MinimapPosition = {}));
var MouseTargetType;
(function(MouseTargetType2) {
  MouseTargetType2[MouseTargetType2["UNKNOWN"] = 0] = "UNKNOWN";
  MouseTargetType2[MouseTargetType2["TEXTAREA"] = 1] = "TEXTAREA";
  MouseTargetType2[MouseTargetType2["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
  MouseTargetType2[MouseTargetType2["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
  MouseTargetType2[MouseTargetType2["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
  MouseTargetType2[MouseTargetType2["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
  MouseTargetType2[MouseTargetType2["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
  MouseTargetType2[MouseTargetType2["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
  MouseTargetType2[MouseTargetType2["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
  MouseTargetType2[MouseTargetType2["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
  MouseTargetType2[MouseTargetType2["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
  MouseTargetType2[MouseTargetType2["SCROLLBAR"] = 11] = "SCROLLBAR";
  MouseTargetType2[MouseTargetType2["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
  MouseTargetType2[MouseTargetType2["OUTSIDE_EDITOR"] = 13] = "OUTSIDE_EDITOR";
})(MouseTargetType || (MouseTargetType = {}));
var NewSymbolNameTag2;
(function(NewSymbolNameTag3) {
  NewSymbolNameTag3[NewSymbolNameTag3["AIGenerated"] = 1] = "AIGenerated";
})(NewSymbolNameTag2 || (NewSymbolNameTag2 = {}));
var OverlayWidgetPositionPreference;
(function(OverlayWidgetPositionPreference2) {
  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_CENTER"] = 2] = "TOP_CENTER";
})(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));
var OverviewRulerLane;
(function(OverviewRulerLane3) {
  OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
  OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
  OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
  OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
})(OverviewRulerLane || (OverviewRulerLane = {}));
var PositionAffinity;
(function(PositionAffinity2) {
  PositionAffinity2[PositionAffinity2["Left"] = 0] = "Left";
  PositionAffinity2[PositionAffinity2["Right"] = 1] = "Right";
  PositionAffinity2[PositionAffinity2["None"] = 2] = "None";
  PositionAffinity2[PositionAffinity2["LeftOfInjectedText"] = 3] = "LeftOfInjectedText";
  PositionAffinity2[PositionAffinity2["RightOfInjectedText"] = 4] = "RightOfInjectedText";
})(PositionAffinity || (PositionAffinity = {}));
var RenderLineNumbersType;
(function(RenderLineNumbersType2) {
  RenderLineNumbersType2[RenderLineNumbersType2["Off"] = 0] = "Off";
  RenderLineNumbersType2[RenderLineNumbersType2["On"] = 1] = "On";
  RenderLineNumbersType2[RenderLineNumbersType2["Relative"] = 2] = "Relative";
  RenderLineNumbersType2[RenderLineNumbersType2["Interval"] = 3] = "Interval";
  RenderLineNumbersType2[RenderLineNumbersType2["Custom"] = 4] = "Custom";
})(RenderLineNumbersType || (RenderLineNumbersType = {}));
var RenderMinimap;
(function(RenderMinimap2) {
  RenderMinimap2[RenderMinimap2["None"] = 0] = "None";
  RenderMinimap2[RenderMinimap2["Text"] = 1] = "Text";
  RenderMinimap2[RenderMinimap2["Blocks"] = 2] = "Blocks";
})(RenderMinimap || (RenderMinimap = {}));
var ScrollType;
(function(ScrollType2) {
  ScrollType2[ScrollType2["Smooth"] = 0] = "Smooth";
  ScrollType2[ScrollType2["Immediate"] = 1] = "Immediate";
})(ScrollType || (ScrollType = {}));
var ScrollbarVisibility;
(function(ScrollbarVisibility2) {
  ScrollbarVisibility2[ScrollbarVisibility2["Auto"] = 1] = "Auto";
  ScrollbarVisibility2[ScrollbarVisibility2["Hidden"] = 2] = "Hidden";
  ScrollbarVisibility2[ScrollbarVisibility2["Visible"] = 3] = "Visible";
})(ScrollbarVisibility || (ScrollbarVisibility = {}));
var SelectionDirection;
(function(SelectionDirection2) {
  SelectionDirection2[SelectionDirection2["LTR"] = 0] = "LTR";
  SelectionDirection2[SelectionDirection2["RTL"] = 1] = "RTL";
})(SelectionDirection || (SelectionDirection = {}));
var ShowLightbulbIconMode;
(function(ShowLightbulbIconMode2) {
  ShowLightbulbIconMode2["Off"] = "off";
  ShowLightbulbIconMode2["OnCode"] = "onCode";
  ShowLightbulbIconMode2["On"] = "on";
})(ShowLightbulbIconMode || (ShowLightbulbIconMode = {}));
var SignatureHelpTriggerKind2;
(function(SignatureHelpTriggerKind3) {
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
  SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind2 || (SignatureHelpTriggerKind2 = {}));
var SymbolKind;
(function(SymbolKind3) {
  SymbolKind3[SymbolKind3["File"] = 0] = "File";
  SymbolKind3[SymbolKind3["Module"] = 1] = "Module";
  SymbolKind3[SymbolKind3["Namespace"] = 2] = "Namespace";
  SymbolKind3[SymbolKind3["Package"] = 3] = "Package";
  SymbolKind3[SymbolKind3["Class"] = 4] = "Class";
  SymbolKind3[SymbolKind3["Method"] = 5] = "Method";
  SymbolKind3[SymbolKind3["Property"] = 6] = "Property";
  SymbolKind3[SymbolKind3["Field"] = 7] = "Field";
  SymbolKind3[SymbolKind3["Constructor"] = 8] = "Constructor";
  SymbolKind3[SymbolKind3["Enum"] = 9] = "Enum";
  SymbolKind3[SymbolKind3["Interface"] = 10] = "Interface";
  SymbolKind3[SymbolKind3["Function"] = 11] = "Function";
  SymbolKind3[SymbolKind3["Variable"] = 12] = "Variable";
  SymbolKind3[SymbolKind3["Constant"] = 13] = "Constant";
  SymbolKind3[SymbolKind3["String"] = 14] = "String";
  SymbolKind3[SymbolKind3["Number"] = 15] = "Number";
  SymbolKind3[SymbolKind3["Boolean"] = 16] = "Boolean";
  SymbolKind3[SymbolKind3["Array"] = 17] = "Array";
  SymbolKind3[SymbolKind3["Object"] = 18] = "Object";
  SymbolKind3[SymbolKind3["Key"] = 19] = "Key";
  SymbolKind3[SymbolKind3["Null"] = 20] = "Null";
  SymbolKind3[SymbolKind3["EnumMember"] = 21] = "EnumMember";
  SymbolKind3[SymbolKind3["Struct"] = 22] = "Struct";
  SymbolKind3[SymbolKind3["Event"] = 23] = "Event";
  SymbolKind3[SymbolKind3["Operator"] = 24] = "Operator";
  SymbolKind3[SymbolKind3["TypeParameter"] = 25] = "TypeParameter";
})(SymbolKind || (SymbolKind = {}));
var SymbolTag;
(function(SymbolTag3) {
  SymbolTag3[SymbolTag3["Deprecated"] = 1] = "Deprecated";
})(SymbolTag || (SymbolTag = {}));
var TextEditorCursorBlinkingStyle;
(function(TextEditorCursorBlinkingStyle2) {
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Hidden"] = 0] = "Hidden";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Blink"] = 1] = "Blink";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Smooth"] = 2] = "Smooth";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Phase"] = 3] = "Phase";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Expand"] = 4] = "Expand";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Solid"] = 5] = "Solid";
})(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
var TextEditorCursorStyle;
(function(TextEditorCursorStyle2) {
  TextEditorCursorStyle2[TextEditorCursorStyle2["Line"] = 1] = "Line";
  TextEditorCursorStyle2[TextEditorCursorStyle2["Block"] = 2] = "Block";
  TextEditorCursorStyle2[TextEditorCursorStyle2["Underline"] = 3] = "Underline";
  TextEditorCursorStyle2[TextEditorCursorStyle2["LineThin"] = 4] = "LineThin";
  TextEditorCursorStyle2[TextEditorCursorStyle2["BlockOutline"] = 5] = "BlockOutline";
  TextEditorCursorStyle2[TextEditorCursorStyle2["UnderlineThin"] = 6] = "UnderlineThin";
})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
var TrackedRangeStickiness;
(function(TrackedRangeStickiness2) {
  TrackedRangeStickiness2[TrackedRangeStickiness2["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
  TrackedRangeStickiness2[TrackedRangeStickiness2["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
  TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
  TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
})(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
var WrappingIndent;
(function(WrappingIndent2) {
  WrappingIndent2[WrappingIndent2["None"] = 0] = "None";
  WrappingIndent2[WrappingIndent2["Same"] = 1] = "Same";
  WrappingIndent2[WrappingIndent2["Indent"] = 2] = "Indent";
  WrappingIndent2[WrappingIndent2["DeepIndent"] = 3] = "DeepIndent";
})(WrappingIndent || (WrappingIndent = {}));

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js
var KeyMod = class {
  static chord(firstPart, secondPart) {
    return KeyChord(firstPart, secondPart);
  }
};
KeyMod.CtrlCmd = 2048;
KeyMod.Shift = 1024;
KeyMod.Alt = 512;
KeyMod.WinCtrl = 256;
function createMonacoBaseAPI() {
  return {
    editor: void 0,
    // undefined override expected here
    languages: void 0,
    // undefined override expected here
    CancellationTokenSource,
    Emitter,
    KeyCode,
    KeyMod,
    Position,
    Range,
    Selection,
    SelectionDirection,
    MarkerSeverity,
    MarkerTag,
    Uri: URI,
    Token
  };
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js
var WordCharacterClassifier = class extends CharacterClassifier {
  constructor(wordSeparators) {
    super(
      0
      /* WordCharacterClass.Regular */
    );
    for (let i = 0, len = wordSeparators.length; i < len; i++) {
      this.set(
        wordSeparators.charCodeAt(i),
        2
        /* WordCharacterClass.WordSeparator */
      );
    }
    this.set(
      32,
      1
      /* WordCharacterClass.Whitespace */
    );
    this.set(
      9,
      1
      /* WordCharacterClass.Whitespace */
    );
  }
};
function once(computeFn) {
  const cache = {};
  return (input) => {
    if (!cache.hasOwnProperty(input)) {
      cache[input] = computeFn(input);
    }
    return cache[input];
  };
}
var getMapForWordSeparators = once((input) => new WordCharacterClassifier(input));

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/model.js
var OverviewRulerLane2;
(function(OverviewRulerLane3) {
  OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
  OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
  OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
  OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
})(OverviewRulerLane2 || (OverviewRulerLane2 = {}));
var GlyphMarginLane2;
(function(GlyphMarginLane3) {
  GlyphMarginLane3[GlyphMarginLane3["Left"] = 1] = "Left";
  GlyphMarginLane3[GlyphMarginLane3["Center"] = 2] = "Center";
  GlyphMarginLane3[GlyphMarginLane3["Right"] = 3] = "Right";
})(GlyphMarginLane2 || (GlyphMarginLane2 = {}));
var MinimapPosition2;
(function(MinimapPosition3) {
  MinimapPosition3[MinimapPosition3["Inline"] = 1] = "Inline";
  MinimapPosition3[MinimapPosition3["Gutter"] = 2] = "Gutter";
})(MinimapPosition2 || (MinimapPosition2 = {}));
var InjectedTextCursorStops2;
(function(InjectedTextCursorStops3) {
  InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
  InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
  InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
  InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
})(InjectedTextCursorStops2 || (InjectedTextCursorStops2 = {}));

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js
function leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
  if (matchStartIndex === 0) {
    return true;
  }
  const charBefore = text.charCodeAt(matchStartIndex - 1);
  if (wordSeparators.get(charBefore) !== 0) {
    return true;
  }
  if (charBefore === 13 || charBefore === 10) {
    return true;
  }
  if (matchLength > 0) {
    const firstCharInMatch = text.charCodeAt(matchStartIndex);
    if (wordSeparators.get(firstCharInMatch) !== 0) {
      return true;
    }
  }
  return false;
}
function rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
  if (matchStartIndex + matchLength === textLength) {
    return true;
  }
  const charAfter = text.charCodeAt(matchStartIndex + matchLength);
  if (wordSeparators.get(charAfter) !== 0) {
    return true;
  }
  if (charAfter === 13 || charAfter === 10) {
    return true;
  }
  if (matchLength > 0) {
    const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);
    if (wordSeparators.get(lastCharInMatch) !== 0) {
      return true;
    }
  }
  return false;
}
function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {
  return leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength);
}
var Searcher = class {
  constructor(wordSeparators, searchRegex) {
    this._wordSeparators = wordSeparators;
    this._searchRegex = searchRegex;
    this._prevMatchStartIndex = -1;
    this._prevMatchLength = 0;
  }
  reset(lastIndex) {
    this._searchRegex.lastIndex = lastIndex;
    this._prevMatchStartIndex = -1;
    this._prevMatchLength = 0;
  }
  next(text) {
    const textLength = text.length;
    let m;
    do {
      if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
        return null;
      }
      m = this._searchRegex.exec(text);
      if (!m) {
        return null;
      }
      const matchStartIndex = m.index;
      const matchLength = m[0].length;
      if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
        if (matchLength === 0) {
          if (getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 65535) {
            this._searchRegex.lastIndex += 2;
          } else {
            this._searchRegex.lastIndex += 1;
          }
          continue;
        }
        return null;
      }
      this._prevMatchStartIndex = matchStartIndex;
      this._prevMatchLength = matchLength;
      if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {
        return m;
      }
    } while (m);
    return null;
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/assert.js
function assertNever(value, message = "Unreachable") {
  throw new Error(message);
}
function assertFn(condition) {
  if (!condition()) {
    debugger;
    condition();
    onUnexpectedError(new BugIndicatingError("Assertion Failed"));
  }
}
function checkAdjacentItems(items, predicate) {
  let i = 0;
  while (i < items.length - 1) {
    const a2 = items[i];
    const b = items[i + 1];
    if (!predicate(a2, b)) {
      return false;
    }
    i++;
  }
  return true;
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js
var UnicodeTextModelHighlighter = class {
  static computeUnicodeHighlights(model, options, range) {
    const startLine = range ? range.startLineNumber : 1;
    const endLine = range ? range.endLineNumber : model.getLineCount();
    const codePointHighlighter = new CodePointHighlighter(options);
    const candidates = codePointHighlighter.getCandidateCodePoints();
    let regex;
    if (candidates === "allNonBasicAscii") {
      regex = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g");
    } else {
      regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, "g");
    }
    const searcher = new Searcher(null, regex);
    const ranges = [];
    let hasMore = false;
    let m;
    let ambiguousCharacterCount = 0;
    let invisibleCharacterCount = 0;
    let nonBasicAsciiCharacterCount = 0;
    forLoop: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {
      const lineContent = model.getLineContent(lineNumber);
      const lineLength = lineContent.length;
      searcher.reset(0);
      do {
        m = searcher.next(lineContent);
        if (m) {
          let startIndex = m.index;
          let endIndex = m.index + m[0].length;
          if (startIndex > 0) {
            const charCodeBefore = lineContent.charCodeAt(startIndex - 1);
            if (isHighSurrogate(charCodeBefore)) {
              startIndex--;
            }
          }
          if (endIndex + 1 < lineLength) {
            const charCodeBefore = lineContent.charCodeAt(endIndex - 1);
            if (isHighSurrogate(charCodeBefore)) {
              endIndex++;
            }
          }
          const str = lineContent.substring(startIndex, endIndex);
          let word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);
          if (word && word.endColumn <= startIndex + 1) {
            word = null;
          }
          const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);
          if (highlightReason !== 0) {
            if (highlightReason === 3) {
              ambiguousCharacterCount++;
            } else if (highlightReason === 2) {
              invisibleCharacterCount++;
            } else if (highlightReason === 1) {
              nonBasicAsciiCharacterCount++;
            } else {
              assertNever(highlightReason);
            }
            const MAX_RESULT_LENGTH = 1e3;
            if (ranges.length >= MAX_RESULT_LENGTH) {
              hasMore = true;
              break forLoop;
            }
            ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));
          }
        }
      } while (m);
    }
    return {
      ranges,
      hasMore,
      ambiguousCharacterCount,
      invisibleCharacterCount,
      nonBasicAsciiCharacterCount
    };
  }
  static computeUnicodeHighlightReason(char, options) {
    const codePointHighlighter = new CodePointHighlighter(options);
    const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);
    switch (reason) {
      case 0:
        return null;
      case 2:
        return {
          kind: 1
          /* UnicodeHighlighterReasonKind.Invisible */
        };
      case 3: {
        const codePoint = char.codePointAt(0);
        const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);
        const notAmbiguousInLocales = AmbiguousCharacters.getLocales().filter((l) => !AmbiguousCharacters.getInstance(/* @__PURE__ */ new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));
        return { kind: 0, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };
      }
      case 1:
        return {
          kind: 2
          /* UnicodeHighlighterReasonKind.NonBasicAscii */
        };
    }
  }
};
function buildRegExpCharClassExpr(codePoints, flags) {
  const src = `[${escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(""))}]`;
  return src;
}
var CodePointHighlighter = class {
  constructor(options) {
    this.options = options;
    this.allowedCodePoints = new Set(options.allowedCodePoints);
    this.ambiguousCharacters = AmbiguousCharacters.getInstance(new Set(options.allowedLocales));
  }
  getCandidateCodePoints() {
    if (this.options.nonBasicASCII) {
      return "allNonBasicAscii";
    }
    const set2 = /* @__PURE__ */ new Set();
    if (this.options.invisibleCharacters) {
      for (const cp of InvisibleCharacters.codePoints) {
        if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {
          set2.add(cp);
        }
      }
    }
    if (this.options.ambiguousCharacters) {
      for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {
        set2.add(cp);
      }
    }
    for (const cp of this.allowedCodePoints) {
      set2.delete(cp);
    }
    return set2;
  }
  shouldHighlightNonBasicASCII(character, wordContext) {
    const codePoint = character.codePointAt(0);
    if (this.allowedCodePoints.has(codePoint)) {
      return 0;
    }
    if (this.options.nonBasicASCII) {
      return 1;
    }
    let hasBasicASCIICharacters = false;
    let hasNonConfusableNonBasicAsciiCharacter = false;
    if (wordContext) {
      for (const char of wordContext) {
        const codePoint2 = char.codePointAt(0);
        const isBasicASCII2 = isBasicASCII(char);
        hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII2;
        if (!isBasicASCII2 && !this.ambiguousCharacters.isAmbiguous(codePoint2) && !InvisibleCharacters.isInvisibleCharacter(codePoint2)) {
          hasNonConfusableNonBasicAsciiCharacter = true;
        }
      }
    }
    if (
      /* Don't allow mixing weird looking characters with ASCII */
      !hasBasicASCIICharacters && /* Is there an obviously weird looking character? */
      hasNonConfusableNonBasicAsciiCharacter
    ) {
      return 0;
    }
    if (this.options.invisibleCharacters) {
      if (!isAllowedInvisibleCharacter(character) && InvisibleCharacters.isInvisibleCharacter(codePoint)) {
        return 2;
      }
    }
    if (this.options.ambiguousCharacters) {
      if (this.ambiguousCharacters.isAmbiguous(codePoint)) {
        return 3;
      }
    }
    return 0;
  }
};
function isAllowedInvisibleCharacter(character) {
  return character === " " || character === "\n" || character === "	";
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js
var LinesDiff = class {
  constructor(changes, moves, hitTimeout) {
    this.changes = changes;
    this.moves = moves;
    this.hitTimeout = hitTimeout;
  }
};
var MovedText = class {
  constructor(lineRangeMapping, changes) {
    this.lineRangeMapping = lineRangeMapping;
    this.changes = changes;
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js
var OffsetRange = class _OffsetRange {
  static addRange(range, sortedRanges) {
    let i = 0;
    while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {
      i++;
    }
    let j = i;
    while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {
      j++;
    }
    if (i === j) {
      sortedRanges.splice(i, 0, range);
    } else {
      const start = Math.min(range.start, sortedRanges[i].start);
      const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);
      sortedRanges.splice(i, j - i, new _OffsetRange(start, end));
    }
  }
  static ofLength(length) {
    return new _OffsetRange(0, length);
  }
  static ofStartAndLength(start, length) {
    return new _OffsetRange(start, start + length);
  }
  constructor(start, endExclusive) {
    this.start = start;
    this.endExclusive = endExclusive;
    if (start > endExclusive) {
      throw new BugIndicatingError(`Invalid range: ${this.toString()}`);
    }
  }
  get isEmpty() {
    return this.start === this.endExclusive;
  }
  delta(offset) {
    return new _OffsetRange(this.start + offset, this.endExclusive + offset);
  }
  deltaStart(offset) {
    return new _OffsetRange(this.start + offset, this.endExclusive);
  }
  deltaEnd(offset) {
    return new _OffsetRange(this.start, this.endExclusive + offset);
  }
  get length() {
    return this.endExclusive - this.start;
  }
  toString() {
    return `[${this.start}, ${this.endExclusive})`;
  }
  contains(offset) {
    return this.start <= offset && offset < this.endExclusive;
  }
  /**
   * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)
   * The joined range is the smallest range that contains both ranges.
   */
  join(other) {
    return new _OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));
  }
  /**
   * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)
   *
   * The resulting range is empty if the ranges do not intersect, but touch.
   * If the ranges don't even touch, the result is undefined.
   */
  intersect(other) {
    const start = Math.max(this.start, other.start);
    const end = Math.min(this.endExclusive, other.endExclusive);
    if (start <= end) {
      return new _OffsetRange(start, end);
    }
    return void 0;
  }
  intersects(other) {
    const start = Math.max(this.start, other.start);
    const end = Math.min(this.endExclusive, other.endExclusive);
    return start < end;
  }
  isBefore(other) {
    return this.endExclusive <= other.start;
  }
  isAfter(other) {
    return this.start >= other.endExclusive;
  }
  slice(arr) {
    return arr.slice(this.start, this.endExclusive);
  }
  /**
   * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.
   * The range must not be empty.
   */
  clip(value) {
    if (this.isEmpty) {
      throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
    }
    return Math.max(this.start, Math.min(this.endExclusive - 1, value));
  }
  /**
   * Returns `r := value + k * length` such that `r` is contained in this range.
   * The range must not be empty.
   *
   * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.
   */
  clipCyclic(value) {
    if (this.isEmpty) {
      throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);
    }
    if (value < this.start) {
      return this.endExclusive - (this.start - value) % this.length;
    }
    if (value >= this.endExclusive) {
      return this.start + (value - this.start) % this.length;
    }
    return value;
  }
  forEach(f2) {
    for (let i = this.start; i < this.endExclusive; i++) {
      f2(i);
    }
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/arraysFind.js
function findLastMonotonous(array, predicate) {
  const idx = findLastIdxMonotonous(array, predicate);
  return idx === -1 ? void 0 : array[idx];
}
function findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {
  let i = startIdx;
  let j = endIdxEx;
  while (i < j) {
    const k = Math.floor((i + j) / 2);
    if (predicate(array[k])) {
      i = k + 1;
    } else {
      j = k;
    }
  }
  return i - 1;
}
function findFirstMonotonous(array, predicate) {
  const idx = findFirstIdxMonotonousOrArrLen(array, predicate);
  return idx === array.length ? void 0 : array[idx];
}
function findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {
  let i = startIdx;
  let j = endIdxEx;
  while (i < j) {
    const k = Math.floor((i + j) / 2);
    if (predicate(array[k])) {
      j = k;
    } else {
      i = k + 1;
    }
  }
  return i;
}
var MonotonousArray = class _MonotonousArray {
  constructor(_array) {
    this._array = _array;
    this._findLastMonotonousLastIdx = 0;
  }
  /**
   * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!
   * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.
   */
  findLastMonotonous(predicate) {
    if (_MonotonousArray.assertInvariants) {
      if (this._prevFindLastPredicate) {
        for (const item of this._array) {
          if (this._prevFindLastPredicate(item) && !predicate(item)) {
            throw new Error("MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.");
          }
        }
      }
      this._prevFindLastPredicate = predicate;
    }
    const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);
    this._findLastMonotonousLastIdx = idx + 1;
    return idx === -1 ? void 0 : this._array[idx];
  }
};
MonotonousArray.assertInvariants = false;

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js
var LineRange = class _LineRange {
  static fromRangeInclusive(range) {
    return new _LineRange(range.startLineNumber, range.endLineNumber + 1);
  }
  /**
   * @param lineRanges An array of sorted line ranges.
   */
  static joinMany(lineRanges) {
    if (lineRanges.length === 0) {
      return [];
    }
    let result = new LineRangeSet(lineRanges[0].slice());
    for (let i = 1; i < lineRanges.length; i++) {
      result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));
    }
    return result.ranges;
  }
  static ofLength(startLineNumber, length) {
    return new _LineRange(startLineNumber, startLineNumber + length);
  }
  /**
   * @internal
   */
  static deserialize(lineRange) {
    return new _LineRange(lineRange[0], lineRange[1]);
  }
  constructor(startLineNumber, endLineNumberExclusive) {
    if (startLineNumber > endLineNumberExclusive) {
      throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);
    }
    this.startLineNumber = startLineNumber;
    this.endLineNumberExclusive = endLineNumberExclusive;
  }
  /**
   * Indicates if this line range contains the given line number.
   */
  contains(lineNumber) {
    return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
  }
  /**
   * Indicates if this line range is empty.
   */
  get isEmpty() {
    return this.startLineNumber === this.endLineNumberExclusive;
  }
  /**
   * Moves this line range by the given offset of line numbers.
   */
  delta(offset) {
    return new _LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);
  }
  deltaLength(offset) {
    return new _LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);
  }
  /**
   * The number of lines this line range spans.
   */
  get length() {
    return this.endLineNumberExclusive - this.startLineNumber;
  }
  /**
   * Creates a line range that combines this and the given line range.
   */
  join(other) {
    return new _LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));
  }
  toString() {
    return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
  }
  /**
   * The resulting range is empty if the ranges do not intersect, but touch.
   * If the ranges don't even touch, the result is undefined.
   */
  intersect(other) {
    const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);
    const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);
    if (startLineNumber <= endLineNumberExclusive) {
      return new _LineRange(startLineNumber, endLineNumberExclusive);
    }
    return void 0;
  }
  intersectsStrict(other) {
    return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;
  }
  overlapOrTouch(other) {
    return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;
  }
  equals(b) {
    return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;
  }
  toInclusiveRange() {
    if (this.isEmpty) {
      return null;
    }
    return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);
  }
  toExclusiveRange() {
    return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
  }
  mapToLineArray(f2) {
    const result = [];
    for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
      result.push(f2(lineNumber));
    }
    return result;
  }
  forEach(f2) {
    for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
      f2(lineNumber);
    }
  }
  /**
   * @internal
   */
  serialize() {
    return [this.startLineNumber, this.endLineNumberExclusive];
  }
  includes(lineNumber) {
    return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
  }
  /**
   * Converts this 1-based line range to a 0-based offset range (subtracts 1!).
   * @internal
   */
  toOffsetRange() {
    return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);
  }
};
var LineRangeSet = class _LineRangeSet {
  constructor(_normalizedRanges = []) {
    this._normalizedRanges = _normalizedRanges;
  }
  get ranges() {
    return this._normalizedRanges;
  }
  addRange(range) {
    if (range.length === 0) {
      return;
    }
    const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r) => r.endLineNumberExclusive >= range.startLineNumber);
    const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r) => r.startLineNumber <= range.endLineNumberExclusive) + 1;
    if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
      this._normalizedRanges.splice(joinRangeStartIdx, 0, range);
    } else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {
      const joinRange = this._normalizedRanges[joinRangeStartIdx];
      this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);
    } else {
      const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);
      this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);
    }
  }
  contains(lineNumber) {
    const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r) => r.startLineNumber <= lineNumber);
    return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;
  }
  intersects(range) {
    const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, (r) => r.startLineNumber < range.endLineNumberExclusive);
    return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;
  }
  getUnion(other) {
    if (this._normalizedRanges.length === 0) {
      return other;
    }
    if (other._normalizedRanges.length === 0) {
      return this;
    }
    const result = [];
    let i1 = 0;
    let i2 = 0;
    let current = null;
    while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {
      let next = null;
      if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {
        const lineRange1 = this._normalizedRanges[i1];
        const lineRange2 = other._normalizedRanges[i2];
        if (lineRange1.startLineNumber < lineRange2.startLineNumber) {
          next = lineRange1;
          i1++;
        } else {
          next = lineRange2;
          i2++;
        }
      } else if (i1 < this._normalizedRanges.length) {
        next = this._normalizedRanges[i1];
        i1++;
      } else {
        next = other._normalizedRanges[i2];
        i2++;
      }
      if (current === null) {
        current = next;
      } else {
        if (current.endLineNumberExclusive >= next.startLineNumber) {
          current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));
        } else {
          result.push(current);
          current = next;
        }
      }
    }
    if (current !== null) {
      result.push(current);
    }
    return new _LineRangeSet(result);
  }
  /**
   * Subtracts all ranges in this set from `range` and returns the result.
   */
  subtractFrom(range) {
    const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, (r) => r.endLineNumberExclusive >= range.startLineNumber);
    const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, (r) => r.startLineNumber <= range.endLineNumberExclusive) + 1;
    if (joinRangeStartIdx === joinRangeEndIdxExclusive) {
      return new _LineRangeSet([range]);
    }
    const result = [];
    let startLineNumber = range.startLineNumber;
    for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {
      const r = this._normalizedRanges[i];
      if (r.startLineNumber > startLineNumber) {
        result.push(new LineRange(startLineNumber, r.startLineNumber));
      }
      startLineNumber = r.endLineNumberExclusive;
    }
    if (startLineNumber < range.endLineNumberExclusive) {
      result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));
    }
    return new _LineRangeSet(result);
  }
  toString() {
    return this._normalizedRanges.map((r) => r.toString()).join(", ");
  }
  getIntersection(other) {
    const result = [];
    let i1 = 0;
    let i2 = 0;
    while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {
      const r1 = this._normalizedRanges[i1];
      const r2 = other._normalizedRanges[i2];
      const i = r1.intersect(r2);
      if (i && !i.isEmpty) {
        result.push(i);
      }
      if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {
        i1++;
      } else {
        i2++;
      }
    }
    return new _LineRangeSet(result);
  }
  getWithDelta(value) {
    return new _LineRangeSet(this._normalizedRanges.map((r) => r.delta(value)));
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js
var LineRangeMapping = class _LineRangeMapping {
  static inverse(mapping, originalLineCount, modifiedLineCount) {
    const result = [];
    let lastOriginalEndLineNumber = 1;
    let lastModifiedEndLineNumber = 1;
    for (const m of mapping) {
      const r2 = new _LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber));
      if (!r2.modified.isEmpty) {
        result.push(r2);
      }
      lastOriginalEndLineNumber = m.original.endLineNumberExclusive;
      lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;
    }
    const r = new _LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1));
    if (!r.modified.isEmpty) {
      result.push(r);
    }
    return result;
  }
  static clip(mapping, originalRange, modifiedRange) {
    const result = [];
    for (const m of mapping) {
      const original = m.original.intersect(originalRange);
      const modified = m.modified.intersect(modifiedRange);
      if (original && !original.isEmpty && modified && !modified.isEmpty) {
        result.push(new _LineRangeMapping(original, modified));
      }
    }
    return result;
  }
  constructor(originalRange, modifiedRange) {
    this.original = originalRange;
    this.modified = modifiedRange;
  }
  toString() {
    return `{${this.original.toString()}->${this.modified.toString()}}`;
  }
  flip() {
    return new _LineRangeMapping(this.modified, this.original);
  }
  join(other) {
    return new _LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));
  }
};
var DetailedLineRangeMapping = class _DetailedLineRangeMapping extends LineRangeMapping {
  constructor(originalRange, modifiedRange, innerChanges) {
    super(originalRange, modifiedRange);
    this.innerChanges = innerChanges;
  }
  flip() {
    var _a4;
    return new _DetailedLineRangeMapping(this.modified, this.original, (_a4 = this.innerChanges) === null || _a4 === void 0 ? void 0 : _a4.map((c) => c.flip()));
  }
};
var RangeMapping = class _RangeMapping {
  constructor(originalRange, modifiedRange) {
    this.originalRange = originalRange;
    this.modifiedRange = modifiedRange;
  }
  toString() {
    return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
  }
  flip() {
    return new _RangeMapping(this.modifiedRange, this.originalRange);
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js
var MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
var LegacyLinesDiffComputer = class {
  computeDiff(originalLines, modifiedLines, options) {
    var _a4;
    const diffComputer = new DiffComputer(originalLines, modifiedLines, {
      maxComputationTime: options.maxComputationTimeMs,
      shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,
      shouldComputeCharChanges: true,
      shouldMakePrettyDiff: true,
      shouldPostProcessCharChanges: true
    });
    const result = diffComputer.computeDiff();
    const changes = [];
    let lastChange = null;
    for (const c of result.changes) {
      let originalRange;
      if (c.originalEndLineNumber === 0) {
        originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);
      } else {
        originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);
      }
      let modifiedRange;
      if (c.modifiedEndLineNumber === 0) {
        modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);
      } else {
        modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);
      }
      let change = new DetailedLineRangeMapping(originalRange, modifiedRange, (_a4 = c.charChanges) === null || _a4 === void 0 ? void 0 : _a4.map((c2) => new RangeMapping(new Range(c2.originalStartLineNumber, c2.originalStartColumn, c2.originalEndLineNumber, c2.originalEndColumn), new Range(c2.modifiedStartLineNumber, c2.modifiedStartColumn, c2.modifiedEndLineNumber, c2.modifiedEndColumn))));
      if (lastChange) {
        if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {
          change = new DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges && change.innerChanges ? lastChange.innerChanges.concat(change.innerChanges) : void 0);
          changes.pop();
        }
      }
      changes.push(change);
      lastChange = change;
    }
    assertFn(() => {
      return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
      m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);
    });
    return new LinesDiff(changes, [], result.quitEarly);
  }
};
function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
  const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
  return diffAlgo.ComputeDiff(pretty);
}
var LineSequence = class {
  constructor(lines) {
    const startColumns = [];
    const endColumns = [];
    for (let i = 0, length = lines.length; i < length; i++) {
      startColumns[i] = getFirstNonBlankColumn(lines[i], 1);
      endColumns[i] = getLastNonBlankColumn(lines[i], 1);
    }
    this.lines = lines;
    this._startColumns = startColumns;
    this._endColumns = endColumns;
  }
  getElements() {
    const elements = [];
    for (let i = 0, len = this.lines.length; i < len; i++) {
      elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);
    }
    return elements;
  }
  getStrictElement(index) {
    return this.lines[index];
  }
  getStartLineNumber(i) {
    return i + 1;
  }
  getEndLineNumber(i) {
    return i + 1;
  }
  createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
    const charCodes = [];
    const lineNumbers = [];
    const columns = [];
    let len = 0;
    for (let index = startIndex; index <= endIndex; index++) {
      const lineContent = this.lines[index];
      const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;
      const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;
      for (let col = startColumn; col < endColumn; col++) {
        charCodes[len] = lineContent.charCodeAt(col - 1);
        lineNumbers[len] = index + 1;
        columns[len] = col;
        len++;
      }
      if (!shouldIgnoreTrimWhitespace && index < endIndex) {
        charCodes[len] = 10;
        lineNumbers[len] = index + 1;
        columns[len] = lineContent.length + 1;
        len++;
      }
    }
    return new CharSequence(charCodes, lineNumbers, columns);
  }
};
var CharSequence = class {
  constructor(charCodes, lineNumbers, columns) {
    this._charCodes = charCodes;
    this._lineNumbers = lineNumbers;
    this._columns = columns;
  }
  toString() {
    return "[" + this._charCodes.map((s, idx) => (s === 10 ? "\\n" : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(", ") + "]";
  }
  _assertIndex(index, arr) {
    if (index < 0 || index >= arr.length) {
      throw new Error(`Illegal index`);
    }
  }
  getElements() {
    return this._charCodes;
  }
  getStartLineNumber(i) {
    if (i > 0 && i === this._lineNumbers.length) {
      return this.getEndLineNumber(i - 1);
    }
    this._assertIndex(i, this._lineNumbers);
    return this._lineNumbers[i];
  }
  getEndLineNumber(i) {
    if (i === -1) {
      return this.getStartLineNumber(i + 1);
    }
    this._assertIndex(i, this._lineNumbers);
    if (this._charCodes[i] === 10) {
      return this._lineNumbers[i] + 1;
    }
    return this._lineNumbers[i];
  }
  getStartColumn(i) {
    if (i > 0 && i === this._columns.length) {
      return this.getEndColumn(i - 1);
    }
    this._assertIndex(i, this._columns);
    return this._columns[i];
  }
  getEndColumn(i) {
    if (i === -1) {
      return this.getStartColumn(i + 1);
    }
    this._assertIndex(i, this._columns);
    if (this._charCodes[i] === 10) {
      return 1;
    }
    return this._columns[i] + 1;
  }
};
var CharChange = class _CharChange {
  constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
    this.originalStartLineNumber = originalStartLineNumber;
    this.originalStartColumn = originalStartColumn;
    this.originalEndLineNumber = originalEndLineNumber;
    this.originalEndColumn = originalEndColumn;
    this.modifiedStartLineNumber = modifiedStartLineNumber;
    this.modifiedStartColumn = modifiedStartColumn;
    this.modifiedEndLineNumber = modifiedEndLineNumber;
    this.modifiedEndColumn = modifiedEndColumn;
  }
  static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
    const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
    const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
    const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
    const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
    const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
    const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
    const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
    const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
    return new _CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
  }
};
function postProcessCharChanges(rawChanges) {
  if (rawChanges.length <= 1) {
    return rawChanges;
  }
  const result = [rawChanges[0]];
  let prevChange = result[0];
  for (let i = 1, len = rawChanges.length; i < len; i++) {
    const currChange = rawChanges[i];
    const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
    const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
    const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
    if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
      prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;
      prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;
    } else {
      result.push(currChange);
      prevChange = currChange;
    }
  }
  return result;
}
var LineChange = class _LineChange {
  constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
    this.originalStartLineNumber = originalStartLineNumber;
    this.originalEndLineNumber = originalEndLineNumber;
    this.modifiedStartLineNumber = modifiedStartLineNumber;
    this.modifiedEndLineNumber = modifiedEndLineNumber;
    this.charChanges = charChanges;
  }
  static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
    let originalStartLineNumber;
    let originalEndLineNumber;
    let modifiedStartLineNumber;
    let modifiedEndLineNumber;
    let charChanges = void 0;
    if (diffChange.originalLength === 0) {
      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
      originalEndLineNumber = 0;
    } else {
      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
      originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
    }
    if (diffChange.modifiedLength === 0) {
      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
      modifiedEndLineNumber = 0;
    } else {
      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
      modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
    }
    if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
      const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
      const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
      if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {
        let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
        if (shouldPostProcessCharChanges) {
          rawChanges = postProcessCharChanges(rawChanges);
        }
        charChanges = [];
        for (let i = 0, length = rawChanges.length; i < length; i++) {
          charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));
        }
      }
    }
    return new _LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
  }
};
var DiffComputer = class {
  constructor(originalLines, modifiedLines, opts) {
    this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
    this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
    this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
    this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
    this.originalLines = originalLines;
    this.modifiedLines = modifiedLines;
    this.original = new LineSequence(originalLines);
    this.modified = new LineSequence(modifiedLines);
    this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
    this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5e3));
  }
  computeDiff() {
    if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
      if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
        return {
          quitEarly: false,
          changes: []
        };
      }
      return {
        quitEarly: false,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: 1,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: this.modified.lines.length,
          charChanges: void 0
        }]
      };
    }
    if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
      return {
        quitEarly: false,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: this.original.lines.length,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: 1,
          charChanges: void 0
        }]
      };
    }
    const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
    const rawChanges = diffResult.changes;
    const quitEarly = diffResult.quitEarly;
    if (this.shouldIgnoreTrimWhitespace) {
      const lineChanges = [];
      for (let i = 0, length = rawChanges.length; i < length; i++) {
        lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
      }
      return {
        quitEarly,
        changes: lineChanges
      };
    }
    const result = [];
    let originalLineIndex = 0;
    let modifiedLineIndex = 0;
    for (let i = -1, len = rawChanges.length; i < len; i++) {
      const nextChange = i + 1 < len ? rawChanges[i + 1] : null;
      const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;
      const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;
      while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
        const originalLine = this.originalLines[originalLineIndex];
        const modifiedLine = this.modifiedLines[modifiedLineIndex];
        if (originalLine !== modifiedLine) {
          {
            let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
            let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
            while (originalStartColumn > 1 && modifiedStartColumn > 1) {
              const originalChar = originalLine.charCodeAt(originalStartColumn - 2);
              const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
              if (originalChar !== modifiedChar) {
                break;
              }
              originalStartColumn--;
              modifiedStartColumn--;
            }
            if (originalStartColumn > 1 || modifiedStartColumn > 1) {
              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
            }
          }
          {
            let originalEndColumn = getLastNonBlankColumn(originalLine, 1);
            let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
            const originalMaxColumn = originalLine.length + 1;
            const modifiedMaxColumn = modifiedLine.length + 1;
            while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
              const originalChar = originalLine.charCodeAt(originalEndColumn - 1);
              const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
              if (originalChar !== modifiedChar) {
                break;
              }
              originalEndColumn++;
              modifiedEndColumn++;
            }
            if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
            }
          }
        }
        originalLineIndex++;
        modifiedLineIndex++;
      }
      if (nextChange) {
        result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
        originalLineIndex += nextChange.originalLength;
        modifiedLineIndex += nextChange.modifiedLength;
      }
    }
    return {
      quitEarly,
      changes: result
    };
  }
  _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
    if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
      return;
    }
    let charChanges = void 0;
    if (this.shouldComputeCharChanges) {
      charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
    }
    result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
  }
  _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
    const len = result.length;
    if (len === 0) {
      return false;
    }
    const prevChange = result[len - 1];
    if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
      return false;
    }
    if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {
      if (this.shouldComputeCharChanges && prevChange.charChanges) {
        prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
      }
      return true;
    }
    if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
      prevChange.originalEndLineNumber = originalLineNumber;
      prevChange.modifiedEndLineNumber = modifiedLineNumber;
      if (this.shouldComputeCharChanges && prevChange.charChanges) {
        prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
      }
      return true;
    }
    return false;
  }
};
function getFirstNonBlankColumn(txt, defaultValue) {
  const r = firstNonWhitespaceIndex(txt);
  if (r === -1) {
    return defaultValue;
  }
  return r + 1;
}
function getLastNonBlankColumn(txt, defaultValue) {
  const r = lastNonWhitespaceIndex(txt);
  if (r === -1) {
    return defaultValue;
  }
  return r + 2;
}
function createContinueProcessingPredicate(maximumRuntime) {
  if (maximumRuntime === 0) {
    return () => true;
  }
  const startTime = Date.now();
  return () => {
    return Date.now() - startTime < maximumRuntime;
  };
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js
var DiffAlgorithmResult = class _DiffAlgorithmResult {
  static trivial(seq1, seq2) {
    return new _DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);
  }
  static trivialTimedOut(seq1, seq2) {
    return new _DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);
  }
  constructor(diffs, hitTimeout) {
    this.diffs = diffs;
    this.hitTimeout = hitTimeout;
  }
};
var SequenceDiff = class _SequenceDiff {
  static invert(sequenceDiffs, doc1Length) {
    const result = [];
    forEachAdjacent(sequenceDiffs, (a2, b) => {
      result.push(_SequenceDiff.fromOffsetPairs(a2 ? a2.getEndExclusives() : OffsetPair.zero, b ? b.getStarts() : new OffsetPair(doc1Length, (a2 ? a2.seq2Range.endExclusive - a2.seq1Range.endExclusive : 0) + doc1Length)));
    });
    return result;
  }
  static fromOffsetPairs(start, endExclusive) {
    return new _SequenceDiff(new OffsetRange(start.offset1, endExclusive.offset1), new OffsetRange(start.offset2, endExclusive.offset2));
  }
  constructor(seq1Range, seq2Range) {
    this.seq1Range = seq1Range;
    this.seq2Range = seq2Range;
  }
  swap() {
    return new _SequenceDiff(this.seq2Range, this.seq1Range);
  }
  toString() {
    return `${this.seq1Range} <-> ${this.seq2Range}`;
  }
  join(other) {
    return new _SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));
  }
  delta(offset) {
    if (offset === 0) {
      return this;
    }
    return new _SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));
  }
  deltaStart(offset) {
    if (offset === 0) {
      return this;
    }
    return new _SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));
  }
  deltaEnd(offset) {
    if (offset === 0) {
      return this;
    }
    return new _SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));
  }
  intersect(other) {
    const i1 = this.seq1Range.intersect(other.seq1Range);
    const i2 = this.seq2Range.intersect(other.seq2Range);
    if (!i1 || !i2) {
      return void 0;
    }
    return new _SequenceDiff(i1, i2);
  }
  getStarts() {
    return new OffsetPair(this.seq1Range.start, this.seq2Range.start);
  }
  getEndExclusives() {
    return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);
  }
};
var OffsetPair = class _OffsetPair {
  constructor(offset1, offset2) {
    this.offset1 = offset1;
    this.offset2 = offset2;
  }
  toString() {
    return `${this.offset1} <-> ${this.offset2}`;
  }
  delta(offset) {
    if (offset === 0) {
      return this;
    }
    return new _OffsetPair(this.offset1 + offset, this.offset2 + offset);
  }
  equals(other) {
    return this.offset1 === other.offset1 && this.offset2 === other.offset2;
  }
};
OffsetPair.zero = new OffsetPair(0, 0);
OffsetPair.max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
var InfiniteTimeout = class {
  isValid() {
    return true;
  }
};
InfiniteTimeout.instance = new InfiniteTimeout();
var DateTimeout = class {
  constructor(timeout) {
    this.timeout = timeout;
    this.startTime = Date.now();
    this.valid = true;
    if (timeout <= 0) {
      throw new BugIndicatingError("timeout must be positive");
    }
  }
  // Recommendation: Set a log-point `{this.disable()}` in the body
  isValid() {
    const valid = Date.now() - this.startTime < this.timeout;
    if (!valid && this.valid) {
      this.valid = false;
      debugger;
    }
    return this.valid;
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js
var Array2D = class {
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.array = [];
    this.array = new Array(width * height);
  }
  get(x, y) {
    return this.array[x + y * this.width];
  }
  set(x, y, value) {
    this.array[x + y * this.width] = value;
  }
};
function isSpace(charCode) {
  return charCode === 32 || charCode === 9;
}
var LineRangeFragment = class _LineRangeFragment {
  static getKey(chr) {
    let key = this.chrKeys.get(chr);
    if (key === void 0) {
      key = this.chrKeys.size;
      this.chrKeys.set(chr, key);
    }
    return key;
  }
  constructor(range, lines, source) {
    this.range = range;
    this.lines = lines;
    this.source = source;
    this.histogram = [];
    let counter = 0;
    for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {
      const line = lines[i];
      for (let j = 0; j < line.length; j++) {
        counter++;
        const chr = line[j];
        const key2 = _LineRangeFragment.getKey(chr);
        this.histogram[key2] = (this.histogram[key2] || 0) + 1;
      }
      counter++;
      const key = _LineRangeFragment.getKey("\n");
      this.histogram[key] = (this.histogram[key] || 0) + 1;
    }
    this.totalCount = counter;
  }
  computeSimilarity(other) {
    var _a4, _b2;
    let sumDifferences = 0;
    const maxLength = Math.max(this.histogram.length, other.histogram.length);
    for (let i = 0; i < maxLength; i++) {
      sumDifferences += Math.abs(((_a4 = this.histogram[i]) !== null && _a4 !== void 0 ? _a4 : 0) - ((_b2 = other.histogram[i]) !== null && _b2 !== void 0 ? _b2 : 0));
    }
    return 1 - sumDifferences / (this.totalCount + other.totalCount);
  }
};
LineRangeFragment.chrKeys = /* @__PURE__ */ new Map();

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js
var DynamicProgrammingDiffing = class {
  compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {
    if (sequence1.length === 0 || sequence2.length === 0) {
      return DiffAlgorithmResult.trivial(sequence1, sequence2);
    }
    const lcsLengths = new Array2D(sequence1.length, sequence2.length);
    const directions = new Array2D(sequence1.length, sequence2.length);
    const lengths = new Array2D(sequence1.length, sequence2.length);
    for (let s12 = 0; s12 < sequence1.length; s12++) {
      for (let s22 = 0; s22 < sequence2.length; s22++) {
        if (!timeout.isValid()) {
          return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);
        }
        const horizontalLen = s12 === 0 ? 0 : lcsLengths.get(s12 - 1, s22);
        const verticalLen = s22 === 0 ? 0 : lcsLengths.get(s12, s22 - 1);
        let extendedSeqScore;
        if (sequence1.getElement(s12) === sequence2.getElement(s22)) {
          if (s12 === 0 || s22 === 0) {
            extendedSeqScore = 0;
          } else {
            extendedSeqScore = lcsLengths.get(s12 - 1, s22 - 1);
          }
          if (s12 > 0 && s22 > 0 && directions.get(s12 - 1, s22 - 1) === 3) {
            extendedSeqScore += lengths.get(s12 - 1, s22 - 1);
          }
          extendedSeqScore += equalityScore ? equalityScore(s12, s22) : 1;
        } else {
          extendedSeqScore = -1;
        }
        const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);
        if (newValue === extendedSeqScore) {
          const prevLen = s12 > 0 && s22 > 0 ? lengths.get(s12 - 1, s22 - 1) : 0;
          lengths.set(s12, s22, prevLen + 1);
          directions.set(s12, s22, 3);
        } else if (newValue === horizontalLen) {
          lengths.set(s12, s22, 0);
          directions.set(s12, s22, 1);
        } else if (newValue === verticalLen) {
          lengths.set(s12, s22, 0);
          directions.set(s12, s22, 2);
        }
        lcsLengths.set(s12, s22, newValue);
      }
    }
    const result = [];
    let lastAligningPosS1 = sequence1.length;
    let lastAligningPosS2 = sequence2.length;
    function reportDecreasingAligningPositions(s12, s22) {
      if (s12 + 1 !== lastAligningPosS1 || s22 + 1 !== lastAligningPosS2) {
        result.push(new SequenceDiff(new OffsetRange(s12 + 1, lastAligningPosS1), new OffsetRange(s22 + 1, lastAligningPosS2)));
      }
      lastAligningPosS1 = s12;
      lastAligningPosS2 = s22;
    }
    let s1 = sequence1.length - 1;
    let s2 = sequence2.length - 1;
    while (s1 >= 0 && s2 >= 0) {
      if (directions.get(s1, s2) === 3) {
        reportDecreasingAligningPositions(s1, s2);
        s1--;
        s2--;
      } else {
        if (directions.get(s1, s2) === 1) {
          s1--;
        } else {
          s2--;
        }
      }
    }
    reportDecreasingAligningPositions(-1, -1);
    result.reverse();
    return new DiffAlgorithmResult(result, false);
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js
var MyersDiffAlgorithm = class {
  compute(seq1, seq2, timeout = InfiniteTimeout.instance) {
    if (seq1.length === 0 || seq2.length === 0) {
      return DiffAlgorithmResult.trivial(seq1, seq2);
    }
    const seqX = seq1;
    const seqY = seq2;
    function getXAfterSnake(x, y) {
      while (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {
        x++;
        y++;
      }
      return x;
    }
    let d = 0;
    const V = new FastInt32Array();
    V.set(0, getXAfterSnake(0, 0));
    const paths = new FastArrayNegativeIndices();
    paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));
    let k = 0;
    loop: while (true) {
      d++;
      if (!timeout.isValid()) {
        return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);
      }
      const lowerBound = -Math.min(d, seqY.length + d % 2);
      const upperBound = Math.min(d, seqX.length + d % 2);
      for (k = lowerBound; k <= upperBound; k += 2) {
        let step = 0;
        const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1);
        const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1;
        step++;
        const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);
        const y = x - k;
        step++;
        if (x > seqX.length || y > seqY.length) {
          continue;
        }
        const newMaxX = getXAfterSnake(x, y);
        V.set(k, newMaxX);
        const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);
        paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);
        if (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {
          break loop;
        }
      }
    }
    let path5 = paths.get(k);
    const result = [];
    let lastAligningPosS1 = seqX.length;
    let lastAligningPosS2 = seqY.length;
    while (true) {
      const endX = path5 ? path5.x + path5.length : 0;
      const endY = path5 ? path5.y + path5.length : 0;
      if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {
        result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));
      }
      if (!path5) {
        break;
      }
      lastAligningPosS1 = path5.x;
      lastAligningPosS2 = path5.y;
      path5 = path5.prev;
    }
    result.reverse();
    return new DiffAlgorithmResult(result, false);
  }
};
var SnakePath = class {
  constructor(prev, x, y, length) {
    this.prev = prev;
    this.x = x;
    this.y = y;
    this.length = length;
  }
};
var FastInt32Array = class {
  constructor() {
    this.positiveArr = new Int32Array(10);
    this.negativeArr = new Int32Array(10);
  }
  get(idx) {
    if (idx < 0) {
      idx = -idx - 1;
      return this.negativeArr[idx];
    } else {
      return this.positiveArr[idx];
    }
  }
  set(idx, value) {
    if (idx < 0) {
      idx = -idx - 1;
      if (idx >= this.negativeArr.length) {
        const arr = this.negativeArr;
        this.negativeArr = new Int32Array(arr.length * 2);
        this.negativeArr.set(arr);
      }
      this.negativeArr[idx] = value;
    } else {
      if (idx >= this.positiveArr.length) {
        const arr = this.positiveArr;
        this.positiveArr = new Int32Array(arr.length * 2);
        this.positiveArr.set(arr);
      }
      this.positiveArr[idx] = value;
    }
  }
};
var FastArrayNegativeIndices = class {
  constructor() {
    this.positiveArr = [];
    this.negativeArr = [];
  }
  get(idx) {
    if (idx < 0) {
      idx = -idx - 1;
      return this.negativeArr[idx];
    } else {
      return this.positiveArr[idx];
    }
  }
  set(idx, value) {
    if (idx < 0) {
      idx = -idx - 1;
      this.negativeArr[idx] = value;
    } else {
      this.positiveArr[idx] = value;
    }
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/map.js
var _a3;
var _b;
var ResourceMapEntry = class {
  constructor(uri, value) {
    this.uri = uri;
    this.value = value;
  }
};
function isEntries(arg) {
  return Array.isArray(arg);
}
var ResourceMap = class _ResourceMap {
  constructor(arg, toKey) {
    this[_a3] = "ResourceMap";
    if (arg instanceof _ResourceMap) {
      this.map = new Map(arg.map);
      this.toKey = toKey !== null && toKey !== void 0 ? toKey : _ResourceMap.defaultToKey;
    } else if (isEntries(arg)) {
      this.map = /* @__PURE__ */ new Map();
      this.toKey = toKey !== null && toKey !== void 0 ? toKey : _ResourceMap.defaultToKey;
      for (const [resource, value] of arg) {
        this.set(resource, value);
      }
    } else {
      this.map = /* @__PURE__ */ new Map();
      this.toKey = arg !== null && arg !== void 0 ? arg : _ResourceMap.defaultToKey;
    }
  }
  set(resource, value) {
    this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));
    return this;
  }
  get(resource) {
    var _c;
    return (_c = this.map.get(this.toKey(resource))) === null || _c === void 0 ? void 0 : _c.value;
  }
  has(resource) {
    return this.map.has(this.toKey(resource));
  }
  get size() {
    return this.map.size;
  }
  clear() {
    this.map.clear();
  }
  delete(resource) {
    return this.map.delete(this.toKey(resource));
  }
  forEach(clb, thisArg) {
    if (typeof thisArg !== "undefined") {
      clb = clb.bind(thisArg);
    }
    for (const [_, entry] of this.map) {
      clb(entry.value, entry.uri, this);
    }
  }
  *values() {
    for (const entry of this.map.values()) {
      yield entry.value;
    }
  }
  *keys() {
    for (const entry of this.map.values()) {
      yield entry.uri;
    }
  }
  *entries() {
    for (const entry of this.map.values()) {
      yield [entry.uri, entry.value];
    }
  }
  *[(_a3 = Symbol.toStringTag, Symbol.iterator)]() {
    for (const [, entry] of this.map) {
      yield [entry.uri, entry.value];
    }
  }
};
ResourceMap.defaultToKey = (resource) => resource.toString();
var LinkedMap = class {
  constructor() {
    this[_b] = "LinkedMap";
    this._map = /* @__PURE__ */ new Map();
    this._head = void 0;
    this._tail = void 0;
    this._size = 0;
    this._state = 0;
  }
  clear() {
    this._map.clear();
    this._head = void 0;
    this._tail = void 0;
    this._size = 0;
    this._state++;
  }
  isEmpty() {
    return !this._head && !this._tail;
  }
  get size() {
    return this._size;
  }
  get first() {
    var _c;
    return (_c = this._head) === null || _c === void 0 ? void 0 : _c.value;
  }
  get last() {
    var _c;
    return (_c = this._tail) === null || _c === void 0 ? void 0 : _c.value;
  }
  has(key) {
    return this._map.has(key);
  }
  get(key, touch = 0) {
    const item = this._map.get(key);
    if (!item) {
      return void 0;
    }
    if (touch !== 0) {
      this.touch(item, touch);
    }
    return item.value;
  }
  set(key, value, touch = 0) {
    let item = this._map.get(key);
    if (item) {
      item.value = value;
      if (touch !== 0) {
        this.touch(item, touch);
      }
    } else {
      item = { key, value, next: void 0, previous: void 0 };
      switch (touch) {
        case 0:
          this.addItemLast(item);
          break;
        case 1:
          this.addItemFirst(item);
          break;
        case 2:
          this.addItemLast(item);
          break;
        default:
          this.addItemLast(item);
          break;
      }
      this._map.set(key, item);
      this._size++;
    }
    return this;
  }
  delete(key) {
    return !!this.remove(key);
  }
  remove(key) {
    const item = this._map.get(key);
    if (!item) {
      return void 0;
    }
    this._map.delete(key);
    this.removeItem(item);
    this._size--;
    return item.value;
  }
  shift() {
    if (!this._head && !this._tail) {
      return void 0;
    }
    if (!this._head || !this._tail) {
      throw new Error("Invalid list");
    }
    const item = this._head;
    this._map.delete(item.key);
    this.removeItem(item);
    this._size--;
    return item.value;
  }
  forEach(callbackfn, thisArg) {
    const state = this._state;
    let current = this._head;
    while (current) {
      if (thisArg) {
        callbackfn.bind(thisArg)(current.value, current.key, this);
      } else {
        callbackfn(current.value, current.key, this);
      }
      if (this._state !== state) {
        throw new Error(`LinkedMap got modified during iteration.`);
      }
      current = current.next;
    }
  }
  keys() {
    const map2 = this;
    const state = this._state;
    let current = this._head;
    const iterator = {
      [Symbol.iterator]() {
        return iterator;
      },
      next() {
        if (map2._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        if (current) {
          const result = { value: current.key, done: false };
          current = current.next;
          return result;
        } else {
          return { value: void 0, done: true };
        }
      }
    };
    return iterator;
  }
  values() {
    const map2 = this;
    const state = this._state;
    let current = this._head;
    const iterator = {
      [Symbol.iterator]() {
        return iterator;
      },
      next() {
        if (map2._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        if (current) {
          const result = { value: current.value, done: false };
          current = current.next;
          return result;
        } else {
          return { value: void 0, done: true };
        }
      }
    };
    return iterator;
  }
  entries() {
    const map2 = this;
    const state = this._state;
    let current = this._head;
    const iterator = {
      [Symbol.iterator]() {
        return iterator;
      },
      next() {
        if (map2._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        if (current) {
          const result = { value: [current.key, current.value], done: false };
          current = current.next;
          return result;
        } else {
          return { value: void 0, done: true };
        }
      }
    };
    return iterator;
  }
  [(_b = Symbol.toStringTag, Symbol.iterator)]() {
    return this.entries();
  }
  trimOld(newSize) {
    if (newSize >= this.size) {
      return;
    }
    if (newSize === 0) {
      this.clear();
      return;
    }
    let current = this._head;
    let currentSize = this.size;
    while (current && currentSize > newSize) {
      this._map.delete(current.key);
      current = current.next;
      currentSize--;
    }
    this._head = current;
    this._size = currentSize;
    if (current) {
      current.previous = void 0;
    }
    this._state++;
  }
  addItemFirst(item) {
    if (!this._head && !this._tail) {
      this._tail = item;
    } else if (!this._head) {
      throw new Error("Invalid list");
    } else {
      item.next = this._head;
      this._head.previous = item;
    }
    this._head = item;
    this._state++;
  }
  addItemLast(item) {
    if (!this._head && !this._tail) {
      this._head = item;
    } else if (!this._tail) {
      throw new Error("Invalid list");
    } else {
      item.previous = this._tail;
      this._tail.next = item;
    }
    this._tail = item;
    this._state++;
  }
  removeItem(item) {
    if (item === this._head && item === this._tail) {
      this._head = void 0;
      this._tail = void 0;
    } else if (item === this._head) {
      if (!item.next) {
        throw new Error("Invalid list");
      }
      item.next.previous = void 0;
      this._head = item.next;
    } else if (item === this._tail) {
      if (!item.previous) {
        throw new Error("Invalid list");
      }
      item.previous.next = void 0;
      this._tail = item.previous;
    } else {
      const next = item.next;
      const previous = item.previous;
      if (!next || !previous) {
        throw new Error("Invalid list");
      }
      next.previous = previous;
      previous.next = next;
    }
    item.next = void 0;
    item.previous = void 0;
    this._state++;
  }
  touch(item, touch) {
    if (!this._head || !this._tail) {
      throw new Error("Invalid list");
    }
    if (touch !== 1 && touch !== 2) {
      return;
    }
    if (touch === 1) {
      if (item === this._head) {
        return;
      }
      const next = item.next;
      const previous = item.previous;
      if (item === this._tail) {
        previous.next = void 0;
        this._tail = previous;
      } else {
        next.previous = previous;
        previous.next = next;
      }
      item.previous = void 0;
      item.next = this._head;
      this._head.previous = item;
      this._head = item;
      this._state++;
    } else if (touch === 2) {
      if (item === this._tail) {
        return;
      }
      const next = item.next;
      const previous = item.previous;
      if (item === this._head) {
        next.previous = void 0;
        this._head = next;
      } else {
        next.previous = previous;
        previous.next = next;
      }
      item.next = void 0;
      item.previous = this._tail;
      this._tail.next = item;
      this._tail = item;
      this._state++;
    }
  }
  toJSON() {
    const data = [];
    this.forEach((value, key) => {
      data.push([key, value]);
    });
    return data;
  }
  fromJSON(data) {
    this.clear();
    for (const [key, value] of data) {
      this.set(key, value);
    }
  }
};
var SetMap = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  add(key, value) {
    let values = this.map.get(key);
    if (!values) {
      values = /* @__PURE__ */ new Set();
      this.map.set(key, values);
    }
    values.add(value);
  }
  delete(key, value) {
    const values = this.map.get(key);
    if (!values) {
      return;
    }
    values.delete(value);
    if (values.size === 0) {
      this.map.delete(key);
    }
  }
  forEach(key, fn) {
    const values = this.map.get(key);
    if (!values) {
      return;
    }
    values.forEach(fn);
  }
  get(key) {
    const values = this.map.get(key);
    if (!values) {
      return /* @__PURE__ */ new Set();
    }
    return values;
  }
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js
var LinesSliceCharSequence = class {
  constructor(lines, lineRange, considerWhitespaceChanges) {
    this.lines = lines;
    this.considerWhitespaceChanges = considerWhitespaceChanges;
    this.elements = [];
    this.firstCharOffsetByLine = [];
    this.additionalOffsetByLine = [];
    let trimFirstLineFully = false;
    if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {
      lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);
      trimFirstLineFully = true;
    }
    this.lineRange = lineRange;
    this.firstCharOffsetByLine[0] = 0;
    for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {
      let line = lines[i];
      let offset = 0;
      if (trimFirstLineFully) {
        offset = line.length;
        line = "";
        trimFirstLineFully = false;
      } else if (!considerWhitespaceChanges) {
        const trimmedStartLine = line.trimStart();
        offset = line.length - trimmedStartLine.length;
        line = trimmedStartLine.trimEnd();
      }
      this.additionalOffsetByLine.push(offset);
      for (let i2 = 0; i2 < line.length; i2++) {
        this.elements.push(line.charCodeAt(i2));
      }
      if (i < lines.length - 1) {
        this.elements.push("\n".charCodeAt(0));
        this.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;
      }
    }
    this.additionalOffsetByLine.push(0);
  }
  toString() {
    return `Slice: "${this.text}"`;
  }
  get text() {
    return this.getText(new OffsetRange(0, this.length));
  }
  getText(range) {
    return this.elements.slice(range.start, range.endExclusive).map((e) => String.fromCharCode(e)).join("");
  }
  getElement(offset) {
    return this.elements[offset];
  }
  get length() {
    return this.elements.length;
  }
  getBoundaryScore(length) {
    const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);
    const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);
    if (prevCategory === 7 && nextCategory === 8) {
      return 0;
    }
    if (prevCategory === 8) {
      return 150;
    }
    let score2 = 0;
    if (prevCategory !== nextCategory) {
      score2 += 10;
      if (prevCategory === 0 && nextCategory === 1) {
        score2 += 1;
      }
    }
    score2 += getCategoryBoundaryScore(prevCategory);
    score2 += getCategoryBoundaryScore(nextCategory);
    return score2;
  }
  translateOffset(offset) {
    if (this.lineRange.isEmpty) {
      return new Position(this.lineRange.start + 1, 1);
    }
    const i = findLastIdxMonotonous(this.firstCharOffsetByLine, (value) => value <= offset);
    return new Position(this.lineRange.start + i + 1, offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);
  }
  translateRange(range) {
    return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));
  }
  /**
   * Finds the word that contains the character at the given offset
   */
  findWordContaining(offset) {
    if (offset < 0 || offset >= this.elements.length) {
      return void 0;
    }
    if (!isWordChar(this.elements[offset])) {
      return void 0;
    }
    let start = offset;
    while (start > 0 && isWordChar(this.elements[start - 1])) {
      start--;
    }
    let end = offset;
    while (end < this.elements.length && isWordChar(this.elements[end])) {
      end++;
    }
    return new OffsetRange(start, end);
  }
  countLinesIn(range) {
    return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;
  }
  isStronglyEqual(offset1, offset2) {
    return this.elements[offset1] === this.elements[offset2];
  }
  extendToFullLines(range) {
    var _a4, _b2;
    const start = (_a4 = findLastMonotonous(this.firstCharOffsetByLine, (x) => x <= range.start)) !== null && _a4 !== void 0 ? _a4 : 0;
    const end = (_b2 = findFirstMonotonous(this.firstCharOffsetByLine, (x) => range.endExclusive <= x)) !== null && _b2 !== void 0 ? _b2 : this.elements.length;
    return new OffsetRange(start, end);
  }
};
function isWordChar(charCode) {
  return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90 || charCode >= 48 && charCode <= 57;
}
var score = {
  [
    0
    /* CharBoundaryCategory.WordLower */
  ]: 0,
  [
    1
    /* CharBoundaryCategory.WordUpper */
  ]: 0,
  [
    2
    /* CharBoundaryCategory.WordNumber */
  ]: 0,
  [
    3
    /* CharBoundaryCategory.End */
  ]: 10,
  [
    4
    /* CharBoundaryCategory.Other */
  ]: 2,
  [
    5
    /* CharBoundaryCategory.Separator */
  ]: 30,
  [
    6
    /* CharBoundaryCategory.Space */
  ]: 3,
  [
    7
    /* CharBoundaryCategory.LineBreakCR */
  ]: 10,
  [
    8
    /* CharBoundaryCategory.LineBreakLF */
  ]: 10
};
function getCategoryBoundaryScore(category) {
  return score[category];
}
function getCategory(charCode) {
  if (charCode === 10) {
    return 8;
  } else if (charCode === 13) {
    return 7;
  } else if (isSpace(charCode)) {
    return 6;
  } else if (charCode >= 97 && charCode <= 122) {
    return 0;
  } else if (charCode >= 65 && charCode <= 90) {
    return 1;
  } else if (charCode >= 48 && charCode <= 57) {
    return 2;
  } else if (charCode === -1) {
    return 3;
  } else if (charCode === 44 || charCode === 59) {
    return 5;
  } else {
    return 4;
  }
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js
function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {
  let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);
  if (!timeout.isValid()) {
    return [];
  }
  const filteredChanges = changes.filter((c) => !excludedChanges.has(c));
  const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);
  pushMany(moves, unchangedMoves);
  moves = joinCloseConsecutiveMoves(moves);
  moves = moves.filter((current) => {
    const lines = current.original.toOffsetRange().slice(originalLines).map((l) => l.trim());
    const originalText = lines.join("\n");
    return originalText.length >= 15 && countWhere(lines, (l) => l.length >= 2) >= 2;
  });
  moves = removeMovesInSameDiff(changes, moves);
  return moves;
}
function countWhere(arr, predicate) {
  let count = 0;
  for (const t of arr) {
    if (predicate(t)) {
      count++;
    }
  }
  return count;
}
function computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {
  const moves = [];
  const deletions = changes.filter((c) => c.modified.isEmpty && c.original.length >= 3).map((d) => new LineRangeFragment(d.original, originalLines, d));
  const insertions = new Set(changes.filter((c) => c.original.isEmpty && c.modified.length >= 3).map((d) => new LineRangeFragment(d.modified, modifiedLines, d)));
  const excludedChanges = /* @__PURE__ */ new Set();
  for (const deletion of deletions) {
    let highestSimilarity = -1;
    let best;
    for (const insertion of insertions) {
      const similarity = deletion.computeSimilarity(insertion);
      if (similarity > highestSimilarity) {
        highestSimilarity = similarity;
        best = insertion;
      }
    }
    if (highestSimilarity > 0.9 && best) {
      insertions.delete(best);
      moves.push(new LineRangeMapping(deletion.range, best.range));
      excludedChanges.add(deletion.source);
      excludedChanges.add(best.source);
    }
    if (!timeout.isValid()) {
      return { moves, excludedChanges };
    }
  }
  return { moves, excludedChanges };
}
function computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {
  const moves = [];
  const original3LineHashes = new SetMap();
  for (const change of changes) {
    for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {
      const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;
      original3LineHashes.add(key, { range: new LineRange(i, i + 3) });
    }
  }
  const possibleMappings = [];
  changes.sort(compareBy((c) => c.modified.startLineNumber, numberComparator));
  for (const change of changes) {
    let lastMappings = [];
    for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {
      const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;
      const currentModifiedRange = new LineRange(i, i + 3);
      const nextMappings = [];
      original3LineHashes.forEach(key, ({ range }) => {
        for (const lastMapping of lastMappings) {
          if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive && lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {
            lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);
            lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);
            nextMappings.push(lastMapping);
            return;
          }
        }
        const mapping = {
          modifiedLineRange: currentModifiedRange,
          originalLineRange: range
        };
        possibleMappings.push(mapping);
        nextMappings.push(mapping);
      });
      lastMappings = nextMappings;
    }
    if (!timeout.isValid()) {
      return [];
    }
  }
  possibleMappings.sort(reverseOrder(compareBy((m) => m.modifiedLineRange.length, numberComparator)));
  const modifiedSet = new LineRangeSet();
  const originalSet = new LineRangeSet();
  for (const mapping of possibleMappings) {
    const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;
    const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);
    const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);
    const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);
    for (const s of modifiedIntersectedSections.ranges) {
      if (s.length < 3) {
        continue;
      }
      const modifiedLineRange = s;
      const originalLineRange = s.delta(-diffOrigToMod);
      moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));
      modifiedSet.addRange(modifiedLineRange);
      originalSet.addRange(originalLineRange);
    }
  }
  moves.sort(compareBy((m) => m.original.startLineNumber, numberComparator));
  const monotonousChanges = new MonotonousArray(changes);
  for (let i = 0; i < moves.length; i++) {
    const move = moves[i];
    const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous((c) => c.original.startLineNumber <= move.original.startLineNumber);
    const firstTouchingChangeMod = findLastMonotonous(changes, (c) => c.modified.startLineNumber <= move.modified.startLineNumber);
    const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);
    const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous((c) => c.original.startLineNumber < move.original.endLineNumberExclusive);
    const lastTouchingChangeMod = findLastMonotonous(changes, (c) => c.modified.startLineNumber < move.modified.endLineNumberExclusive);
    const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);
    let extendToTop;
    for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {
      const origLine = move.original.startLineNumber - extendToTop - 1;
      const modLine = move.modified.startLineNumber - extendToTop - 1;
      if (origLine > originalLines.length || modLine > modifiedLines.length) {
        break;
      }
      if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {
        break;
      }
      if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {
        break;
      }
    }
    if (extendToTop > 0) {
      originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));
      modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));
    }
    let extendToBottom;
    for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {
      const origLine = move.original.endLineNumberExclusive + extendToBottom;
      const modLine = move.modified.endLineNumberExclusive + extendToBottom;
      if (origLine > originalLines.length || modLine > modifiedLines.length) {
        break;
      }
      if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {
        break;
      }
      if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {
        break;
      }
    }
    if (extendToBottom > 0) {
      originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));
      modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));
    }
    if (extendToTop > 0 || extendToBottom > 0) {
      moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));
    }
  }
  return moves;
}
function areLinesSimilar(line1, line2, timeout) {
  if (line1.trim() === line2.trim()) {
    return true;
  }
  if (line1.length > 300 && line2.length > 300) {
    return false;
  }
  const myersDiffingAlgorithm = new MyersDiffAlgorithm();
  const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new OffsetRange(0, 1), false), new LinesSliceCharSequence([line2], new OffsetRange(0, 1), false), timeout);
  let commonNonSpaceCharCount = 0;
  const inverted = SequenceDiff.invert(result.diffs, line1.length);
  for (const seq2 of inverted) {
    seq2.seq1Range.forEach((idx) => {
      if (!isSpace(line1.charCodeAt(idx))) {
        commonNonSpaceCharCount++;
      }
    });
  }
  function countNonWsChars(str) {
    let count = 0;
    for (let i = 0; i < line1.length; i++) {
      if (!isSpace(str.charCodeAt(i))) {
        count++;
      }
    }
    return count;
  }
  const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);
  const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;
  return r;
}
function joinCloseConsecutiveMoves(moves) {
  if (moves.length === 0) {
    return moves;
  }
  moves.sort(compareBy((m) => m.original.startLineNumber, numberComparator));
  const result = [moves[0]];
  for (let i = 1; i < moves.length; i++) {
    const last = result[result.length - 1];
    const current = moves[i];
    const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;
    const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;
    const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;
    if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {
      result[result.length - 1] = last.join(current);
      continue;
    }
    result.push(current);
  }
  return result;
}
function removeMovesInSameDiff(changes, moves) {
  const changesMonotonous = new MonotonousArray(changes);
  moves = moves.filter((m) => {
    const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous((c) => c.original.startLineNumber < m.original.endLineNumberExclusive) || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));
    const diffBeforeEndOfMoveModified = findLastMonotonous(changes, (c) => c.modified.startLineNumber < m.modified.endLineNumberExclusive);
    const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;
    return differentDiffs;
  });
  return moves;
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js
function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
  let result = sequenceDiffs;
  result = joinSequenceDiffsByShifting(sequence1, sequence2, result);
  result = joinSequenceDiffsByShifting(sequence1, sequence2, result);
  result = shiftSequenceDiffs(sequence1, sequence2, result);
  return result;
}
function joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {
  if (sequenceDiffs.length === 0) {
    return sequenceDiffs;
  }
  const result = [];
  result.push(sequenceDiffs[0]);
  for (let i = 1; i < sequenceDiffs.length; i++) {
    const prevResult = result[result.length - 1];
    let cur = sequenceDiffs[i];
    if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
      const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;
      let d;
      for (d = 1; d <= length; d++) {
        if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) || sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {
          break;
        }
      }
      d--;
      if (d === length) {
        result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));
        continue;
      }
      cur = cur.delta(-d);
    }
    result.push(cur);
  }
  const result2 = [];
  for (let i = 0; i < result.length - 1; i++) {
    const nextResult = result[i + 1];
    let cur = result[i];
    if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
      const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;
      let d;
      for (d = 0; d < length; d++) {
        if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) || !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {
          break;
        }
      }
      if (d === length) {
        result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));
        continue;
      }
      if (d > 0) {
        cur = cur.delta(d);
      }
    }
    result2.push(cur);
  }
  if (result.length > 0) {
    result2.push(result[result.length - 1]);
  }
  return result2;
}
function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
  if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {
    return sequenceDiffs;
  }
  for (let i = 0; i < sequenceDiffs.length; i++) {
    const prevDiff = i > 0 ? sequenceDiffs[i - 1] : void 0;
    const diff = sequenceDiffs[i];
    const nextDiff = i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : void 0;
    const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);
    const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);
    if (diff.seq1Range.isEmpty) {
      sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);
    } else if (diff.seq2Range.isEmpty) {
      sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();
    }
  }
  return sequenceDiffs;
}
function shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {
  const maxShiftLimit = 100;
  let deltaBefore = 1;
  while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start && diff.seq2Range.start - deltaBefore >= seq2ValidRange.start && sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {
    deltaBefore++;
  }
  deltaBefore--;
  let deltaAfter = 0;
  while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive && diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive && sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {
    deltaAfter++;
  }
  if (deltaBefore === 0 && deltaAfter === 0) {
    return diff;
  }
  let bestDelta = 0;
  let bestScore = -1;
  for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {
    const seq2OffsetStart = diff.seq2Range.start + delta;
    const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;
    const seq1Offset = diff.seq1Range.start + delta;
    const score2 = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);
    if (score2 > bestScore) {
      bestScore = score2;
      bestDelta = delta;
    }
  }
  return diff.delta(bestDelta);
}
function removeShortMatches(sequence1, sequence2, sequenceDiffs) {
  const result = [];
  for (const s of sequenceDiffs) {
    const last = result[result.length - 1];
    if (!last) {
      result.push(s);
      continue;
    }
    if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {
      result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));
    } else {
      result.push(s);
    }
  }
  return result;
}
function extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {
  const equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);
  const additional = [];
  let lastPoint = new OffsetPair(0, 0);
  function scanWord(pair, equalMapping) {
    if (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {
      return;
    }
    const w1 = sequence1.findWordContaining(pair.offset1);
    const w2 = sequence2.findWordContaining(pair.offset2);
    if (!w1 || !w2) {
      return;
    }
    let w = new SequenceDiff(w1, w2);
    const equalPart = w.intersect(equalMapping);
    let equalChars1 = equalPart.seq1Range.length;
    let equalChars2 = equalPart.seq2Range.length;
    while (equalMappings.length > 0) {
      const next = equalMappings[0];
      const intersects = next.seq1Range.intersects(w1) || next.seq2Range.intersects(w2);
      if (!intersects) {
        break;
      }
      const v1 = sequence1.findWordContaining(next.seq1Range.start);
      const v2 = sequence2.findWordContaining(next.seq2Range.start);
      const v = new SequenceDiff(v1, v2);
      const equalPart2 = v.intersect(next);
      equalChars1 += equalPart2.seq1Range.length;
      equalChars2 += equalPart2.seq2Range.length;
      w = w.join(v);
      if (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {
        equalMappings.shift();
      } else {
        break;
      }
    }
    if (equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {
      additional.push(w);
    }
    lastPoint = w.getEndExclusives();
  }
  while (equalMappings.length > 0) {
    const next = equalMappings.shift();
    if (next.seq1Range.isEmpty) {
      continue;
    }
    scanWord(next.getStarts(), next);
    scanWord(next.getEndExclusives().delta(-1), next);
  }
  const merged = mergeSequenceDiffs(sequenceDiffs, additional);
  return merged;
}
function mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {
  const result = [];
  while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {
    const sd1 = sequenceDiffs1[0];
    const sd2 = sequenceDiffs2[0];
    let next;
    if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {
      next = sequenceDiffs1.shift();
    } else {
      next = sequenceDiffs2.shift();
    }
    if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {
      result[result.length - 1] = result[result.length - 1].join(next);
    } else {
      result.push(next);
    }
  }
  return result;
}
function removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {
  let diffs = sequenceDiffs;
  if (diffs.length === 0) {
    return diffs;
  }
  let counter = 0;
  let shouldRepeat;
  do {
    shouldRepeat = false;
    const result = [
      diffs[0]
    ];
    for (let i = 1; i < diffs.length; i++) {
      let shouldJoinDiffs = function(before, after) {
        const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
        const unchangedText = sequence1.getText(unchangedRange);
        const unchangedTextWithoutWs = unchangedText.replace(/\s/g, "");
        if (unchangedTextWithoutWs.length <= 4 && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {
          return true;
        }
        return false;
      };
      const cur = diffs[i];
      const lastResult = result[result.length - 1];
      const shouldJoin = shouldJoinDiffs(lastResult, cur);
      if (shouldJoin) {
        shouldRepeat = true;
        result[result.length - 1] = result[result.length - 1].join(cur);
      } else {
        result.push(cur);
      }
    }
    diffs = result;
  } while (counter++ < 10 && shouldRepeat);
  return diffs;
}
function removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {
  let diffs = sequenceDiffs;
  if (diffs.length === 0) {
    return diffs;
  }
  let counter = 0;
  let shouldRepeat;
  do {
    shouldRepeat = false;
    const result = [
      diffs[0]
    ];
    for (let i = 1; i < diffs.length; i++) {
      let shouldJoinDiffs = function(before, after) {
        const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
        const unchangedLineCount = sequence1.countLinesIn(unchangedRange);
        if (unchangedLineCount > 5 || unchangedRange.length > 500) {
          return false;
        }
        const unchangedText = sequence1.getText(unchangedRange).trim();
        if (unchangedText.length > 20 || unchangedText.split(/\r\n|\r|\n/).length > 1) {
          return false;
        }
        const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);
        const beforeSeq1Length = before.seq1Range.length;
        const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);
        const beforeSeq2Length = before.seq2Range.length;
        const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);
        const afterSeq1Length = after.seq1Range.length;
        const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);
        const afterSeq2Length = after.seq2Range.length;
        const max = 2 * 40 + 50;
        function cap(v) {
          return Math.min(v, max);
        }
        if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5) + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > (max ** 1.5) ** 1.5 * 1.3) {
          return true;
        }
        return false;
      };
      const cur = diffs[i];
      const lastResult = result[result.length - 1];
      const shouldJoin = shouldJoinDiffs(lastResult, cur);
      if (shouldJoin) {
        shouldRepeat = true;
        result[result.length - 1] = result[result.length - 1].join(cur);
      } else {
        result.push(cur);
      }
    }
    diffs = result;
  } while (counter++ < 10 && shouldRepeat);
  const newDiffs = [];
  forEachWithNeighbors(diffs, (prev, cur, next) => {
    let newDiff = cur;
    function shouldMarkAsChanged(text) {
      return text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;
    }
    const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);
    const prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));
    if (shouldMarkAsChanged(prefix)) {
      newDiff = newDiff.deltaStart(-prefix.length);
    }
    const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));
    if (shouldMarkAsChanged(suffix)) {
      newDiff = newDiff.deltaEnd(suffix.length);
    }
    const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);
    const result = newDiff.intersect(availableSpace);
    if (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {
      newDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);
    } else {
      newDiffs.push(result);
    }
  });
  return newDiffs;
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js
var LineSequence2 = class {
  constructor(trimmedHash, lines) {
    this.trimmedHash = trimmedHash;
    this.lines = lines;
  }
  getElement(offset) {
    return this.trimmedHash[offset];
  }
  get length() {
    return this.trimmedHash.length;
  }
  getBoundaryScore(length) {
    const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);
    const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);
    return 1e3 - (indentationBefore + indentationAfter);
  }
  getText(range) {
    return this.lines.slice(range.start, range.endExclusive).join("\n");
  }
  isStronglyEqual(offset1, offset2) {
    return this.lines[offset1] === this.lines[offset2];
  }
};
function getIndentation(str) {
  let i = 0;
  while (i < str.length && (str.charCodeAt(i) === 32 || str.charCodeAt(i) === 9)) {
    i++;
  }
  return i;
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js
var DefaultLinesDiffComputer = class {
  constructor() {
    this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();
    this.myersDiffingAlgorithm = new MyersDiffAlgorithm();
  }
  computeDiff(originalLines, modifiedLines, options) {
    if (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a2, b) => a2 === b)) {
      return new LinesDiff([], [], false);
    }
    if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {
      return new LinesDiff([
        new DetailedLineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [
          new RangeMapping(new Range(1, 1, originalLines.length, originalLines[0].length + 1), new Range(1, 1, modifiedLines.length, modifiedLines[0].length + 1))
        ])
      ], [], false);
    }
    const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);
    const considerWhitespaceChanges = !options.ignoreTrimWhitespace;
    const perfectHashes = /* @__PURE__ */ new Map();
    function getOrCreateHash(text) {
      let hash = perfectHashes.get(text);
      if (hash === void 0) {
        hash = perfectHashes.size;
        perfectHashes.set(text, hash);
      }
      return hash;
    }
    const originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));
    const modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));
    const sequence1 = new LineSequence2(originalLinesHashes, originalLines);
    const sequence2 = new LineSequence2(modifiedLinesHashes, modifiedLines);
    const lineAlignmentResult = (() => {
      if (sequence1.length + sequence2.length < 1700) {
        return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2] ? modifiedLines[offset2].length === 0 ? 0.1 : 1 + Math.log(1 + modifiedLines[offset2].length) : 0.99);
      }
      return this.myersDiffingAlgorithm.compute(sequence1, sequence2);
    })();
    let lineAlignments = lineAlignmentResult.diffs;
    let hitTimeout = lineAlignmentResult.hitTimeout;
    lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);
    lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);
    const alignments = [];
    const scanForWhitespaceChanges = (equalLinesCount) => {
      if (!considerWhitespaceChanges) {
        return;
      }
      for (let i = 0; i < equalLinesCount; i++) {
        const seq1Offset = seq1LastStart + i;
        const seq2Offset = seq2LastStart + i;
        if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {
          const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);
          for (const a2 of characterDiffs.mappings) {
            alignments.push(a2);
          }
          if (characterDiffs.hitTimeout) {
            hitTimeout = true;
          }
        }
      }
    };
    let seq1LastStart = 0;
    let seq2LastStart = 0;
    for (const diff of lineAlignments) {
      assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);
      const equalLinesCount = diff.seq1Range.start - seq1LastStart;
      scanForWhitespaceChanges(equalLinesCount);
      seq1LastStart = diff.seq1Range.endExclusive;
      seq2LastStart = diff.seq2Range.endExclusive;
      const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);
      if (characterDiffs.hitTimeout) {
        hitTimeout = true;
      }
      for (const a2 of characterDiffs.mappings) {
        alignments.push(a2);
      }
    }
    scanForWhitespaceChanges(originalLines.length - seq1LastStart);
    const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);
    let moves = [];
    if (options.computeMoves) {
      moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);
    }
    assertFn(() => {
      function validatePosition(pos, lines) {
        if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {
          return false;
        }
        const line = lines[pos.lineNumber - 1];
        if (pos.column < 1 || pos.column > line.length + 1) {
          return false;
        }
        return true;
      }
      function validateRange(range, lines) {
        if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {
          return false;
        }
        if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {
          return false;
        }
        return true;
      }
      for (const c of changes) {
        if (!c.innerChanges) {
          return false;
        }
        for (const ic of c.innerChanges) {
          const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) && validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);
          if (!valid) {
            return false;
          }
        }
        if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {
          return false;
        }
      }
      return true;
    });
    return new LinesDiff(changes, moves, hitTimeout);
  }
  computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {
    const moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);
    const movesWithDiffs = moves.map((m) => {
      const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout, considerWhitespaceChanges);
      const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);
      return new MovedText(m, mappings);
    });
    return movesWithDiffs;
  }
  refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {
    const slice1 = new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);
    const slice2 = new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);
    const diffResult = slice1.length + slice2.length < 500 ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout) : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);
    let diffs = diffResult.diffs;
    diffs = optimizeSequenceDiffs(slice1, slice2, diffs);
    diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);
    diffs = removeShortMatches(slice1, slice2, diffs);
    diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);
    const result = diffs.map((d) => new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));
    return {
      mappings: result,
      hitTimeout: diffResult.hitTimeout
    };
  }
};
function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {
  const changes = [];
  for (const g of groupAdjacentBy(alignments.map((a2) => getLineRangeMapping(a2, originalLines, modifiedLines)), (a1, a2) => a1.original.overlapOrTouch(a2.original) || a1.modified.overlapOrTouch(a2.modified))) {
    const first = g[0];
    const last = g[g.length - 1];
    changes.push(new DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map((a2) => a2.innerChanges[0])));
  }
  assertFn(() => {
    if (!dontAssertStartLine) {
      if (changes.length > 0 && changes[0].original.startLineNumber !== changes[0].modified.startLineNumber) {
        return false;
      }
    }
    return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
    m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);
  });
  return changes;
}
function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {
  let lineStartDelta = 0;
  let lineEndDelta = 0;
  if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1 && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {
    lineEndDelta = -1;
  }
  if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {
    lineStartDelta = 1;
  }
  const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);
  const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);
  return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js
var linesDiffComputers = {
  getLegacy: () => new LegacyLinesDiffComputer(),
  getDefault: () => new DefaultLinesDiffComputer()
};

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/base/common/color.js
function roundFloat(number, decimalPoints) {
  const decimal = Math.pow(10, decimalPoints);
  return Math.round(number * decimal) / decimal;
}
var RGBA = class {
  constructor(r, g, b, a2 = 1) {
    this._rgbaBrand = void 0;
    this.r = Math.min(255, Math.max(0, r)) | 0;
    this.g = Math.min(255, Math.max(0, g)) | 0;
    this.b = Math.min(255, Math.max(0, b)) | 0;
    this.a = roundFloat(Math.max(Math.min(1, a2), 0), 3);
  }
  static equals(a2, b) {
    return a2.r === b.r && a2.g === b.g && a2.b === b.b && a2.a === b.a;
  }
};
var HSLA = class _HSLA {
  constructor(h, s, l, a2) {
    this._hslaBrand = void 0;
    this.h = Math.max(Math.min(360, h), 0) | 0;
    this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
    this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);
    this.a = roundFloat(Math.max(Math.min(1, a2), 0), 3);
  }
  static equals(a2, b) {
    return a2.h === b.h && a2.s === b.s && a2.l === b.l && a2.a === b.a;
  }
  /**
   * Converts an RGB color value to HSL. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes r, g, and b are contained in the set [0, 255] and
   * returns h in the set [0, 360], s, and l in the set [0, 1].
   */
  static fromRGBA(rgba) {
    const r = rgba.r / 255;
    const g = rgba.g / 255;
    const b = rgba.b / 255;
    const a2 = rgba.a;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h = 0;
    let s = 0;
    const l = (min + max) / 2;
    const chroma = max - min;
    if (chroma > 0) {
      s = Math.min(l <= 0.5 ? chroma / (2 * l) : chroma / (2 - 2 * l), 1);
      switch (max) {
        case r:
          h = (g - b) / chroma + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / chroma + 2;
          break;
        case b:
          h = (r - g) / chroma + 4;
          break;
      }
      h *= 60;
      h = Math.round(h);
    }
    return new _HSLA(h, s, l, a2);
  }
  static _hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }
    if (t > 1) {
      t -= 1;
    }
    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
      return q;
    }
    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
  }
  /**
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   */
  static toRGBA(hsla) {
    const h = hsla.h / 360;
    const { s, l, a: a2 } = hsla;
    let r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = _HSLA._hue2rgb(p, q, h + 1 / 3);
      g = _HSLA._hue2rgb(p, q, h);
      b = _HSLA._hue2rgb(p, q, h - 1 / 3);
    }
    return new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a2);
  }
};
var HSVA = class _HSVA {
  constructor(h, s, v, a2) {
    this._hsvaBrand = void 0;
    this.h = Math.max(Math.min(360, h), 0) | 0;
    this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
    this.v = roundFloat(Math.max(Math.min(1, v), 0), 3);
    this.a = roundFloat(Math.max(Math.min(1, a2), 0), 3);
  }
  static equals(a2, b) {
    return a2.h === b.h && a2.s === b.s && a2.v === b.v && a2.a === b.a;
  }
  // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
  static fromRGBA(rgba) {
    const r = rgba.r / 255;
    const g = rgba.g / 255;
    const b = rgba.b / 255;
    const cmax = Math.max(r, g, b);
    const cmin = Math.min(r, g, b);
    const delta = cmax - cmin;
    const s = cmax === 0 ? 0 : delta / cmax;
    let m;
    if (delta === 0) {
      m = 0;
    } else if (cmax === r) {
      m = ((g - b) / delta % 6 + 6) % 6;
    } else if (cmax === g) {
      m = (b - r) / delta + 2;
    } else {
      m = (r - g) / delta + 4;
    }
    return new _HSVA(Math.round(m * 60), s, cmax, rgba.a);
  }
  // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
  static toRGBA(hsva) {
    const { h, s, v, a: a2 } = hsva;
    const c = v * s;
    const x = c * (1 - Math.abs(h / 60 % 2 - 1));
    const m = v - c;
    let [r, g, b] = [0, 0, 0];
    if (h < 60) {
      r = c;
      g = x;
    } else if (h < 120) {
      r = x;
      g = c;
    } else if (h < 180) {
      g = c;
      b = x;
    } else if (h < 240) {
      g = x;
      b = c;
    } else if (h < 300) {
      r = x;
      b = c;
    } else if (h <= 360) {
      r = c;
      b = x;
    }
    r = Math.round((r + m) * 255);
    g = Math.round((g + m) * 255);
    b = Math.round((b + m) * 255);
    return new RGBA(r, g, b, a2);
  }
};
var Color = class _Color {
  static fromHex(hex) {
    return _Color.Format.CSS.parseHex(hex) || _Color.red;
  }
  static equals(a2, b) {
    if (!a2 && !b) {
      return true;
    }
    if (!a2 || !b) {
      return false;
    }
    return a2.equals(b);
  }
  get hsla() {
    if (this._hsla) {
      return this._hsla;
    } else {
      return HSLA.fromRGBA(this.rgba);
    }
  }
  get hsva() {
    if (this._hsva) {
      return this._hsva;
    }
    return HSVA.fromRGBA(this.rgba);
  }
  constructor(arg) {
    if (!arg) {
      throw new Error("Color needs a value");
    } else if (arg instanceof RGBA) {
      this.rgba = arg;
    } else if (arg instanceof HSLA) {
      this._hsla = arg;
      this.rgba = HSLA.toRGBA(arg);
    } else if (arg instanceof HSVA) {
      this._hsva = arg;
      this.rgba = HSVA.toRGBA(arg);
    } else {
      throw new Error("Invalid color ctor argument");
    }
  }
  equals(other) {
    return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);
  }
  /**
   * http://www.w3.org/TR/WCAG20/#relativeluminancedef
   * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
   */
  getRelativeLuminance() {
    const R = _Color._relativeLuminanceForComponent(this.rgba.r);
    const G = _Color._relativeLuminanceForComponent(this.rgba.g);
    const B = _Color._relativeLuminanceForComponent(this.rgba.b);
    const luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;
    return roundFloat(luminance, 4);
  }
  static _relativeLuminanceForComponent(color) {
    const c = color / 255;
    return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  }
  /**
   *	http://24ways.org/2010/calculating-color-contrast
   *  Return 'true' if lighter color otherwise 'false'
   */
  isLighter() {
    const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3;
    return yiq >= 128;
  }
  isLighterThan(another) {
    const lum1 = this.getRelativeLuminance();
    const lum2 = another.getRelativeLuminance();
    return lum1 > lum2;
  }
  isDarkerThan(another) {
    const lum1 = this.getRelativeLuminance();
    const lum2 = another.getRelativeLuminance();
    return lum1 < lum2;
  }
  lighten(factor) {
    return new _Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor, this.hsla.a));
  }
  darken(factor) {
    return new _Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor, this.hsla.a));
  }
  transparent(factor) {
    const { r, g, b, a: a2 } = this.rgba;
    return new _Color(new RGBA(r, g, b, a2 * factor));
  }
  isTransparent() {
    return this.rgba.a === 0;
  }
  isOpaque() {
    return this.rgba.a === 1;
  }
  opposite() {
    return new _Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
  }
  makeOpaque(opaqueBackground) {
    if (this.isOpaque() || opaqueBackground.rgba.a !== 1) {
      return this;
    }
    const { r, g, b, a: a2 } = this.rgba;
    return new _Color(new RGBA(opaqueBackground.rgba.r - a2 * (opaqueBackground.rgba.r - r), opaqueBackground.rgba.g - a2 * (opaqueBackground.rgba.g - g), opaqueBackground.rgba.b - a2 * (opaqueBackground.rgba.b - b), 1));
  }
  toString() {
    if (!this._toString) {
      this._toString = _Color.Format.CSS.format(this);
    }
    return this._toString;
  }
  static getLighterColor(of, relative2, factor) {
    if (of.isLighterThan(relative2)) {
      return of;
    }
    factor = factor ? factor : 0.5;
    const lum1 = of.getRelativeLuminance();
    const lum2 = relative2.getRelativeLuminance();
    factor = factor * (lum2 - lum1) / lum2;
    return of.lighten(factor);
  }
  static getDarkerColor(of, relative2, factor) {
    if (of.isDarkerThan(relative2)) {
      return of;
    }
    factor = factor ? factor : 0.5;
    const lum1 = of.getRelativeLuminance();
    const lum2 = relative2.getRelativeLuminance();
    factor = factor * (lum1 - lum2) / lum1;
    return of.darken(factor);
  }
};
Color.white = new Color(new RGBA(255, 255, 255, 1));
Color.black = new Color(new RGBA(0, 0, 0, 1));
Color.red = new Color(new RGBA(255, 0, 0, 1));
Color.blue = new Color(new RGBA(0, 0, 255, 1));
Color.green = new Color(new RGBA(0, 255, 0, 1));
Color.cyan = new Color(new RGBA(0, 255, 255, 1));
Color.lightgrey = new Color(new RGBA(211, 211, 211, 1));
Color.transparent = new Color(new RGBA(0, 0, 0, 0));
(function(Color3) {
  let Format;
  (function(Format2) {
    let CSS;
    (function(CSS2) {
      function formatRGB(color) {
        if (color.rgba.a === 1) {
          return `rgb(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b})`;
        }
        return Color3.Format.CSS.formatRGBA(color);
      }
      CSS2.formatRGB = formatRGB;
      function formatRGBA(color) {
        return `rgba(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b}, ${+color.rgba.a.toFixed(2)})`;
      }
      CSS2.formatRGBA = formatRGBA;
      function formatHSL(color) {
        if (color.hsla.a === 1) {
          return `hsl(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%)`;
        }
        return Color3.Format.CSS.formatHSLA(color);
      }
      CSS2.formatHSL = formatHSL;
      function formatHSLA(color) {
        return `hsla(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%, ${color.hsla.a.toFixed(2)})`;
      }
      CSS2.formatHSLA = formatHSLA;
      function _toTwoDigitHex(n) {
        const r = n.toString(16);
        return r.length !== 2 ? "0" + r : r;
      }
      function formatHex(color) {
        return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}`;
      }
      CSS2.formatHex = formatHex;
      function formatHexA(color, compact = false) {
        if (compact && color.rgba.a === 1) {
          return Color3.Format.CSS.formatHex(color);
        }
        return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}${_toTwoDigitHex(Math.round(color.rgba.a * 255))}`;
      }
      CSS2.formatHexA = formatHexA;
      function format3(color) {
        if (color.isOpaque()) {
          return Color3.Format.CSS.formatHex(color);
        }
        return Color3.Format.CSS.formatRGBA(color);
      }
      CSS2.format = format3;
      function parseHex(hex) {
        const length = hex.length;
        if (length === 0) {
          return null;
        }
        if (hex.charCodeAt(0) !== 35) {
          return null;
        }
        if (length === 7) {
          const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
          const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
          const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
          return new Color3(new RGBA(r, g, b, 1));
        }
        if (length === 9) {
          const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
          const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
          const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
          const a2 = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));
          return new Color3(new RGBA(r, g, b, a2 / 255));
        }
        if (length === 4) {
          const r = _parseHexDigit(hex.charCodeAt(1));
          const g = _parseHexDigit(hex.charCodeAt(2));
          const b = _parseHexDigit(hex.charCodeAt(3));
          return new Color3(new RGBA(16 * r + r, 16 * g + g, 16 * b + b));
        }
        if (length === 5) {
          const r = _parseHexDigit(hex.charCodeAt(1));
          const g = _parseHexDigit(hex.charCodeAt(2));
          const b = _parseHexDigit(hex.charCodeAt(3));
          const a2 = _parseHexDigit(hex.charCodeAt(4));
          return new Color3(new RGBA(16 * r + r, 16 * g + g, 16 * b + b, (16 * a2 + a2) / 255));
        }
        return null;
      }
      CSS2.parseHex = parseHex;
      function _parseHexDigit(charCode) {
        switch (charCode) {
          case 48:
            return 0;
          case 49:
            return 1;
          case 50:
            return 2;
          case 51:
            return 3;
          case 52:
            return 4;
          case 53:
            return 5;
          case 54:
            return 6;
          case 55:
            return 7;
          case 56:
            return 8;
          case 57:
            return 9;
          case 97:
            return 10;
          case 65:
            return 10;
          case 98:
            return 11;
          case 66:
            return 11;
          case 99:
            return 12;
          case 67:
            return 12;
          case 100:
            return 13;
          case 68:
            return 13;
          case 101:
            return 14;
          case 69:
            return 14;
          case 102:
            return 15;
          case 70:
            return 15;
        }
        return 0;
      }
    })(CSS = Format2.CSS || (Format2.CSS = {}));
  })(Format = Color3.Format || (Color3.Format = {}));
})(Color || (Color = {}));

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js
function _parseCaptureGroups(captureGroups) {
  const values = [];
  for (const captureGroup of captureGroups) {
    const parsedNumber = Number(captureGroup);
    if (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\s/g, "") !== "") {
      values.push(parsedNumber);
    }
  }
  return values;
}
function _toIColor(r, g, b, a2) {
  return {
    red: r / 255,
    blue: b / 255,
    green: g / 255,
    alpha: a2
  };
}
function _findRange(model, match) {
  const index = match.index;
  const length = match[0].length;
  if (!index) {
    return;
  }
  const startPosition = model.positionAt(index);
  const range = {
    startLineNumber: startPosition.lineNumber,
    startColumn: startPosition.column,
    endLineNumber: startPosition.lineNumber,
    endColumn: startPosition.column + length
  };
  return range;
}
function _findHexColorInformation(range, hexValue) {
  if (!range) {
    return;
  }
  const parsedHexColor = Color.Format.CSS.parseHex(hexValue);
  if (!parsedHexColor) {
    return;
  }
  return {
    range,
    color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)
  };
}
function _findRGBColorInformation(range, matches, isAlpha) {
  if (!range || matches.length !== 1) {
    return;
  }
  const match = matches[0];
  const captureGroups = match.values();
  const parsedRegex = _parseCaptureGroups(captureGroups);
  return {
    range,
    color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)
  };
}
function _findHSLColorInformation(range, matches, isAlpha) {
  if (!range || matches.length !== 1) {
    return;
  }
  const match = matches[0];
  const captureGroups = match.values();
  const parsedRegex = _parseCaptureGroups(captureGroups);
  const colorEquivalent = new Color(new HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));
  return {
    range,
    color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)
  };
}
function _findMatches(model, regex) {
  if (typeof model === "string") {
    return [...model.matchAll(regex)];
  } else {
    return model.findMatches(regex);
  }
}
function computeColors(model) {
  const result = [];
  const initialValidationRegex = /\b(rgb|rgba|hsl|hsla)(\([0-9\s,.\%]*\))|(#)([A-Fa-f0-9]{3})\b|(#)([A-Fa-f0-9]{4})\b|(#)([A-Fa-f0-9]{6})\b|(#)([A-Fa-f0-9]{8})\b/gm;
  const initialValidationMatches = _findMatches(model, initialValidationRegex);
  if (initialValidationMatches.length > 0) {
    for (const initialMatch of initialValidationMatches) {
      const initialCaptureGroups = initialMatch.filter((captureGroup) => captureGroup !== void 0);
      const colorScheme = initialCaptureGroups[1];
      const colorParameters = initialCaptureGroups[2];
      if (!colorParameters) {
        continue;
      }
      let colorInformation;
      if (colorScheme === "rgb") {
        const regexParameters = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*\)$/gm;
        colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);
      } else if (colorScheme === "rgba") {
        const regexParameters = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
        colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);
      } else if (colorScheme === "hsl") {
        const regexParameters = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*\)$/gm;
        colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);
      } else if (colorScheme === "hsla") {
        const regexParameters = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
        colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);
      } else if (colorScheme === "#") {
        colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);
      }
      if (colorInformation) {
        result.push(colorInformation);
      }
    }
  }
  return result;
}
function computeDefaultDocumentColors(model) {
  if (!model || typeof model.getValue !== "function" || typeof model.positionAt !== "function") {
    return [];
  }
  return computeColors(model);
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js
var MirrorModel = class extends MirrorTextModel {
  get uri() {
    return this._uri;
  }
  get eol() {
    return this._eol;
  }
  getValue() {
    return this.getText();
  }
  findMatches(regex) {
    const matches = [];
    for (let i = 0; i < this._lines.length; i++) {
      const line = this._lines[i];
      const offsetToAdd = this.offsetAt(new Position(i + 1, 1));
      const iteratorOverMatches = line.matchAll(regex);
      for (const match of iteratorOverMatches) {
        if (match.index || match.index === 0) {
          match.index = match.index + offsetToAdd;
        }
        matches.push(match);
      }
    }
    return matches;
  }
  getLinesContent() {
    return this._lines.slice(0);
  }
  getLineCount() {
    return this._lines.length;
  }
  getLineContent(lineNumber) {
    return this._lines[lineNumber - 1];
  }
  getWordAtPosition(position, wordDefinition) {
    const wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);
    if (wordAtText) {
      return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);
    }
    return null;
  }
  words(wordDefinition) {
    const lines = this._lines;
    const wordenize = this._wordenize.bind(this);
    let lineNumber = 0;
    let lineText = "";
    let wordRangesIdx = 0;
    let wordRanges = [];
    return {
      *[Symbol.iterator]() {
        while (true) {
          if (wordRangesIdx < wordRanges.length) {
            const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);
            wordRangesIdx += 1;
            yield value;
          } else {
            if (lineNumber < lines.length) {
              lineText = lines[lineNumber];
              wordRanges = wordenize(lineText, wordDefinition);
              wordRangesIdx = 0;
              lineNumber += 1;
            } else {
              break;
            }
          }
        }
      }
    };
  }
  getLineWords(lineNumber, wordDefinition) {
    const content = this._lines[lineNumber - 1];
    const ranges = this._wordenize(content, wordDefinition);
    const words = [];
    for (const range of ranges) {
      words.push({
        word: content.substring(range.start, range.end),
        startColumn: range.start + 1,
        endColumn: range.end + 1
      });
    }
    return words;
  }
  _wordenize(content, wordDefinition) {
    const result = [];
    let match;
    wordDefinition.lastIndex = 0;
    while (match = wordDefinition.exec(content)) {
      if (match[0].length === 0) {
        break;
      }
      result.push({ start: match.index, end: match.index + match[0].length });
    }
    return result;
  }
  getValueInRange(range) {
    range = this._validateRange(range);
    if (range.startLineNumber === range.endLineNumber) {
      return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);
    }
    const lineEnding = this._eol;
    const startLineIndex = range.startLineNumber - 1;
    const endLineIndex = range.endLineNumber - 1;
    const resultLines = [];
    resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));
    for (let i = startLineIndex + 1; i < endLineIndex; i++) {
      resultLines.push(this._lines[i]);
    }
    resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));
    return resultLines.join(lineEnding);
  }
  offsetAt(position) {
    position = this._validatePosition(position);
    this._ensureLineStarts();
    return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);
  }
  positionAt(offset) {
    offset = Math.floor(offset);
    offset = Math.max(0, offset);
    this._ensureLineStarts();
    const out = this._lineStarts.getIndexOf(offset);
    const lineLength = this._lines[out.index].length;
    return {
      lineNumber: 1 + out.index,
      column: 1 + Math.min(out.remainder, lineLength)
    };
  }
  _validateRange(range) {
    const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });
    const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });
    if (start.lineNumber !== range.startLineNumber || start.column !== range.startColumn || end.lineNumber !== range.endLineNumber || end.column !== range.endColumn) {
      return {
        startLineNumber: start.lineNumber,
        startColumn: start.column,
        endLineNumber: end.lineNumber,
        endColumn: end.column
      };
    }
    return range;
  }
  _validatePosition(position) {
    if (!Position.isIPosition(position)) {
      throw new Error("bad position");
    }
    let { lineNumber, column } = position;
    let hasChanged = false;
    if (lineNumber < 1) {
      lineNumber = 1;
      column = 1;
      hasChanged = true;
    } else if (lineNumber > this._lines.length) {
      lineNumber = this._lines.length;
      column = this._lines[lineNumber - 1].length + 1;
      hasChanged = true;
    } else {
      const maxCharacter = this._lines[lineNumber - 1].length + 1;
      if (column < 1) {
        column = 1;
        hasChanged = true;
      } else if (column > maxCharacter) {
        column = maxCharacter;
        hasChanged = true;
      }
    }
    if (!hasChanged) {
      return position;
    } else {
      return { lineNumber, column };
    }
  }
};
var EditorSimpleWorker = class _EditorSimpleWorker {
  constructor(host, foreignModuleFactory) {
    this._host = host;
    this._models = /* @__PURE__ */ Object.create(null);
    this._foreignModuleFactory = foreignModuleFactory;
    this._foreignModule = null;
  }
  dispose() {
    this._models = /* @__PURE__ */ Object.create(null);
  }
  _getModel(uri) {
    return this._models[uri];
  }
  _getModels() {
    const all = [];
    Object.keys(this._models).forEach((key) => all.push(this._models[key]));
    return all;
  }
  acceptNewModel(data) {
    this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);
  }
  acceptModelChanged(strURL, e) {
    if (!this._models[strURL]) {
      return;
    }
    const model = this._models[strURL];
    model.onEvents(e);
  }
  acceptRemovedModel(strURL) {
    if (!this._models[strURL]) {
      return;
    }
    delete this._models[strURL];
  }
  async computeUnicodeHighlights(url, options, range) {
    const model = this._getModel(url);
    if (!model) {
      return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
    }
    return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);
  }
  // ---- BEGIN diff --------------------------------------------------------------------------
  async computeDiff(originalUrl, modifiedUrl, options, algorithm) {
    const original = this._getModel(originalUrl);
    const modified = this._getModel(modifiedUrl);
    if (!original || !modified) {
      return null;
    }
    const result = _EditorSimpleWorker.computeDiff(original, modified, options, algorithm);
    return result;
  }
  static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {
    const diffAlgorithm = algorithm === "advanced" ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();
    const originalLines = originalTextModel.getLinesContent();
    const modifiedLines = modifiedTextModel.getLinesContent();
    const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);
    const identical = result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel);
    function getLineChanges(changes) {
      return changes.map((m) => {
        var _a4;
        return [m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, (_a4 = m.innerChanges) === null || _a4 === void 0 ? void 0 : _a4.map((m2) => [
          m2.originalRange.startLineNumber,
          m2.originalRange.startColumn,
          m2.originalRange.endLineNumber,
          m2.originalRange.endColumn,
          m2.modifiedRange.startLineNumber,
          m2.modifiedRange.startColumn,
          m2.modifiedRange.endLineNumber,
          m2.modifiedRange.endColumn
        ])];
      });
    }
    return {
      identical,
      quitEarly: result.hitTimeout,
      changes: getLineChanges(result.changes),
      moves: result.moves.map((m) => [
        m.lineRangeMapping.original.startLineNumber,
        m.lineRangeMapping.original.endLineNumberExclusive,
        m.lineRangeMapping.modified.startLineNumber,
        m.lineRangeMapping.modified.endLineNumberExclusive,
        getLineChanges(m.changes)
      ])
    };
  }
  static _modelsAreIdentical(original, modified) {
    const originalLineCount = original.getLineCount();
    const modifiedLineCount = modified.getLineCount();
    if (originalLineCount !== modifiedLineCount) {
      return false;
    }
    for (let line = 1; line <= originalLineCount; line++) {
      const originalLine = original.getLineContent(line);
      const modifiedLine = modified.getLineContent(line);
      if (originalLine !== modifiedLine) {
        return false;
      }
    }
    return true;
  }
  async computeMoreMinimalEdits(modelUrl, edits, pretty) {
    const model = this._getModel(modelUrl);
    if (!model) {
      return edits;
    }
    const result = [];
    let lastEol = void 0;
    edits = edits.slice(0).sort((a2, b) => {
      if (a2.range && b.range) {
        return Range.compareRangesUsingStarts(a2.range, b.range);
      }
      const aRng = a2.range ? 0 : 1;
      const bRng = b.range ? 0 : 1;
      return aRng - bRng;
    });
    let writeIndex = 0;
    for (let readIndex = 1; readIndex < edits.length; readIndex++) {
      if (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {
        edits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));
        edits[writeIndex].text += edits[readIndex].text;
      } else {
        writeIndex++;
        edits[writeIndex] = edits[readIndex];
      }
    }
    edits.length = writeIndex + 1;
    for (let { range, text, eol } of edits) {
      if (typeof eol === "number") {
        lastEol = eol;
      }
      if (Range.isEmpty(range) && !text) {
        continue;
      }
      const original = model.getValueInRange(range);
      text = text.replace(/\r\n|\n|\r/g, model.eol);
      if (original === text) {
        continue;
      }
      if (Math.max(text.length, original.length) > _EditorSimpleWorker._diffLimit) {
        result.push({ range, text });
        continue;
      }
      const changes = stringDiff(original, text, pretty);
      const editOffset = model.offsetAt(Range.lift(range).getStartPosition());
      for (const change of changes) {
        const start = model.positionAt(editOffset + change.originalStart);
        const end = model.positionAt(editOffset + change.originalStart + change.originalLength);
        const newEdit = {
          text: text.substr(change.modifiedStart, change.modifiedLength),
          range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
        };
        if (model.getValueInRange(newEdit.range) !== newEdit.text) {
          result.push(newEdit);
        }
      }
    }
    if (typeof lastEol === "number") {
      result.push({ eol: lastEol, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
    }
    return result;
  }
  // ---- END minimal edits ---------------------------------------------------------------
  async computeLinks(modelUrl) {
    const model = this._getModel(modelUrl);
    if (!model) {
      return null;
    }
    return computeLinks(model);
  }
  // --- BEGIN default document colors -----------------------------------------------------------
  async computeDefaultDocumentColors(modelUrl) {
    const model = this._getModel(modelUrl);
    if (!model) {
      return null;
    }
    return computeDefaultDocumentColors(model);
  }
  async textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {
    const sw = new StopWatch();
    const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
    const seen = /* @__PURE__ */ new Set();
    outer: for (const url of modelUrls) {
      const model = this._getModel(url);
      if (!model) {
        continue;
      }
      for (const word of model.words(wordDefRegExp)) {
        if (word === leadingWord || !isNaN(Number(word))) {
          continue;
        }
        seen.add(word);
        if (seen.size > _EditorSimpleWorker._suggestionsLimit) {
          break outer;
        }
      }
    }
    return { words: Array.from(seen), duration: sw.elapsed() };
  }
  // ---- END suggest --------------------------------------------------------------------------
  //#region -- word ranges --
  async computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {
    const model = this._getModel(modelUrl);
    if (!model) {
      return /* @__PURE__ */ Object.create(null);
    }
    const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
    const result = /* @__PURE__ */ Object.create(null);
    for (let line = range.startLineNumber; line < range.endLineNumber; line++) {
      const words = model.getLineWords(line, wordDefRegExp);
      for (const word of words) {
        if (!isNaN(Number(word.word))) {
          continue;
        }
        let array = result[word.word];
        if (!array) {
          array = [];
          result[word.word] = array;
        }
        array.push({
          startLineNumber: line,
          startColumn: word.startColumn,
          endLineNumber: line,
          endColumn: word.endColumn
        });
      }
    }
    return result;
  }
  //#endregion
  async navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {
    const model = this._getModel(modelUrl);
    if (!model) {
      return null;
    }
    const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
    if (range.startColumn === range.endColumn) {
      range = {
        startLineNumber: range.startLineNumber,
        startColumn: range.startColumn,
        endLineNumber: range.endLineNumber,
        endColumn: range.endColumn + 1
      };
    }
    const selectionText = model.getValueInRange(range);
    const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);
    if (!wordRange) {
      return null;
    }
    const word = model.getValueInRange(wordRange);
    const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);
    return result;
  }
  // ---- BEGIN foreign module support --------------------------------------------------------------------------
  loadForeignModule(moduleId, createData, foreignHostMethods) {
    const proxyMethodRequest = (method, args) => {
      return this._host.fhr(method, args);
    };
    const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);
    const ctx = {
      host: foreignHost,
      getMirrorModels: () => {
        return this._getModels();
      }
    };
    if (this._foreignModuleFactory) {
      this._foreignModule = this._foreignModuleFactory(ctx, createData);
      return Promise.resolve(getAllMethodNames(this._foreignModule));
    }
    return Promise.reject(new Error(`Unexpected usage`));
  }
  // foreign method request
  fmr(method, args) {
    if (!this._foreignModule || typeof this._foreignModule[method] !== "function") {
      return Promise.reject(new Error("Missing requestHandler or method: " + method));
    }
    try {
      return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));
    } catch (e) {
      return Promise.reject(e);
    }
  }
};
EditorSimpleWorker._diffLimit = 1e5;
EditorSimpleWorker._suggestionsLimit = 1e4;
if (typeof importScripts === "function") {
  globalThis.monaco = createMonacoBaseAPI();
}

// node_modules/.pnpm/monaco-editor@0.47.0/node_modules/monaco-editor/esm/vs/editor/editor.worker.js
var initialized = false;
function initialize(foreignModule) {
  if (initialized) {
    return;
  }
  initialized = true;
  const simpleWorker = new SimpleWorkerServer((msg) => {
    globalThis.postMessage(msg);
  }, (host) => new EditorSimpleWorker(host, foreignModule));
  globalThis.onmessage = (e) => {
    simpleWorker.onmessage(e.data);
  };
}
globalThis.onmessage = (e) => {
  if (!initialized) {
    initialize(null);
  }
};

// node_modules/.pnpm/monaco-worker-manager@2.0.1_monaco-editor@0.47.0/node_modules/monaco-worker-manager/worker.js
function initialize2(fn) {
  self.onmessage = () => {
    initialize((ctx, createData) => Object.create(fn(ctx, createData)));
  };
}

// node_modules/.pnpm/vscode-languageserver-textdocument@1.0.11/node_modules/vscode-languageserver-textdocument/lib/esm/main.js
var FullTextDocument = class _FullTextDocument {
  constructor(uri, languageId, version, content) {
    this._uri = uri;
    this._languageId = languageId;
    this._version = version;
    this._content = content;
    this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(range) {
    if (range) {
      const start = this.offsetAt(range.start);
      const end = this.offsetAt(range.end);
      return this._content.substring(start, end);
    }
    return this._content;
  }
  update(changes, version) {
    for (let change of changes) {
      if (_FullTextDocument.isIncremental(change)) {
        const range = getWellformedRange(change.range);
        const startOffset = this.offsetAt(range.start);
        const endOffset = this.offsetAt(range.end);
        this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
        const startLine = Math.max(range.start.line, 0);
        const endLine = Math.max(range.end.line, 0);
        let lineOffsets = this._lineOffsets;
        const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
        if (endLine - startLine === addedLineOffsets.length) {
          for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
            lineOffsets[i + startLine + 1] = addedLineOffsets[i];
          }
        } else {
          if (addedLineOffsets.length < 1e4) {
            lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
          } else {
            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
          }
        }
        const diff = change.text.length - (endOffset - startOffset);
        if (diff !== 0) {
          for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
            lineOffsets[i] = lineOffsets[i] + diff;
          }
        }
      } else if (_FullTextDocument.isFull(change)) {
        this._content = change.text;
        this._lineOffsets = void 0;
      } else {
        throw new Error("Unknown change event received");
      }
    }
    this._version = version;
  }
  getLineOffsets() {
    if (this._lineOffsets === void 0) {
      this._lineOffsets = computeLineOffsets(this._content, true);
    }
    return this._lineOffsets;
  }
  positionAt(offset) {
    offset = Math.max(Math.min(offset, this._content.length), 0);
    let lineOffsets = this.getLineOffsets();
    let low = 0, high = lineOffsets.length;
    if (high === 0) {
      return { line: 0, character: offset };
    }
    while (low < high) {
      let mid = Math.floor((low + high) / 2);
      if (lineOffsets[mid] > offset) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    let line = low - 1;
    return { line, character: offset - lineOffsets[line] };
  }
  offsetAt(position) {
    let lineOffsets = this.getLineOffsets();
    if (position.line >= lineOffsets.length) {
      return this._content.length;
    } else if (position.line < 0) {
      return 0;
    }
    let lineOffset = lineOffsets[position.line];
    let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
  static isIncremental(event) {
    let candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
  }
  static isFull(event) {
    let candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
  }
};
var TextDocument;
(function(TextDocument3) {
  function create(uri, languageId, version, content) {
    return new FullTextDocument(uri, languageId, version, content);
  }
  TextDocument3.create = create;
  function update(document2, changes, version) {
    if (document2 instanceof FullTextDocument) {
      document2.update(changes, version);
      return document2;
    } else {
      throw new Error("TextDocument.update: document must be created by TextDocument.create");
    }
  }
  TextDocument3.update = update;
  function applyEdits(document2, edits) {
    let text = document2.getText();
    let sortedEdits = mergeSort(edits.map(getWellformedEdit), (a2, b) => {
      let diff = a2.range.start.line - b.range.start.line;
      if (diff === 0) {
        return a2.range.start.character - b.range.start.character;
      }
      return diff;
    });
    let lastModifiedOffset = 0;
    const spans = [];
    for (const e of sortedEdits) {
      let startOffset = document2.offsetAt(e.range.start);
      if (startOffset < lastModifiedOffset) {
        throw new Error("Overlapping edit");
      } else if (startOffset > lastModifiedOffset) {
        spans.push(text.substring(lastModifiedOffset, startOffset));
      }
      if (e.newText.length) {
        spans.push(e.newText);
      }
      lastModifiedOffset = document2.offsetAt(e.range.end);
    }
    spans.push(text.substr(lastModifiedOffset));
    return spans.join("");
  }
  TextDocument3.applyEdits = applyEdits;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare2) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort(left, compare2);
  mergeSort(right, compare2);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    let ret = compare2(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
  const result = isAtLineStart ? [textOffset] : [];
  for (let i = 0; i < text.length; i++) {
    let ch = text.charCodeAt(i);
    if (ch === 13 || ch === 10) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function getWellformedRange(range) {
  const start = range.start;
  const end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function getWellformedEdit(textEdit) {
  const range = getWellformedRange(textEdit.range);
  if (range !== textEdit.range) {
    return { newText: textEdit.newText, range };
  }
  return textEdit;
}

// node_modules/.pnpm/jsonc-parser@3.2.0/node_modules/jsonc-parser/lib/esm/impl/scanner.js
function createScanner(text, ignoreTrivia = false) {
  const len = text.length;
  let pos = 0, value = "", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;
  function scanHexDigits(count, exact) {
    let digits = 0;
    let value2 = 0;
    while (digits < count || !exact) {
      let ch = text.charCodeAt(pos);
      if (ch >= 48 && ch <= 57) {
        value2 = value2 * 16 + ch - 48;
      } else if (ch >= 65 && ch <= 70) {
        value2 = value2 * 16 + ch - 65 + 10;
      } else if (ch >= 97 && ch <= 102) {
        value2 = value2 * 16 + ch - 97 + 10;
      } else {
        break;
      }
      pos++;
      digits++;
    }
    if (digits < count) {
      value2 = -1;
    }
    return value2;
  }
  function setPosition(newPosition) {
    pos = newPosition;
    value = "";
    tokenOffset = 0;
    token = 16;
    scanError = 0;
  }
  function scanNumber() {
    let start = pos;
    if (text.charCodeAt(pos) === 48) {
      pos++;
    } else {
      pos++;
      while (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
      }
    }
    if (pos < text.length && text.charCodeAt(pos) === 46) {
      pos++;
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
      } else {
        scanError = 3;
        return text.substring(start, pos);
      }
    }
    let end = pos;
    if (pos < text.length && (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101)) {
      pos++;
      if (pos < text.length && text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45) {
        pos++;
      }
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
        end = pos;
      } else {
        scanError = 3;
      }
    }
    return text.substring(start, end);
  }
  function scanString() {
    let result = "", start = pos;
    while (true) {
      if (pos >= len) {
        result += text.substring(start, pos);
        scanError = 2;
        break;
      }
      const ch = text.charCodeAt(pos);
      if (ch === 34) {
        result += text.substring(start, pos);
        pos++;
        break;
      }
      if (ch === 92) {
        result += text.substring(start, pos);
        pos++;
        if (pos >= len) {
          scanError = 2;
          break;
        }
        const ch2 = text.charCodeAt(pos++);
        switch (ch2) {
          case 34:
            result += '"';
            break;
          case 92:
            result += "\\";
            break;
          case 47:
            result += "/";
            break;
          case 98:
            result += "\b";
            break;
          case 102:
            result += "\f";
            break;
          case 110:
            result += "\n";
            break;
          case 114:
            result += "\r";
            break;
          case 116:
            result += "	";
            break;
          case 117:
            const ch3 = scanHexDigits(4, true);
            if (ch3 >= 0) {
              result += String.fromCharCode(ch3);
            } else {
              scanError = 4;
            }
            break;
          default:
            scanError = 5;
        }
        start = pos;
        continue;
      }
      if (ch >= 0 && ch <= 31) {
        if (isLineBreak(ch)) {
          result += text.substring(start, pos);
          scanError = 2;
          break;
        } else {
          scanError = 6;
        }
      }
      pos++;
    }
    return result;
  }
  function scanNext() {
    value = "";
    scanError = 0;
    tokenOffset = pos;
    lineStartOffset = lineNumber;
    prevTokenLineStartOffset = tokenLineStartOffset;
    if (pos >= len) {
      tokenOffset = len;
      return token = 17;
    }
    let code = text.charCodeAt(pos);
    if (isWhiteSpace(code)) {
      do {
        pos++;
        value += String.fromCharCode(code);
        code = text.charCodeAt(pos);
      } while (isWhiteSpace(code));
      return token = 15;
    }
    if (isLineBreak(code)) {
      pos++;
      value += String.fromCharCode(code);
      if (code === 13 && text.charCodeAt(pos) === 10) {
        pos++;
        value += "\n";
      }
      lineNumber++;
      tokenLineStartOffset = pos;
      return token = 14;
    }
    switch (code) {
      // tokens: []{}:,
      case 123:
        pos++;
        return token = 1;
      case 125:
        pos++;
        return token = 2;
      case 91:
        pos++;
        return token = 3;
      case 93:
        pos++;
        return token = 4;
      case 58:
        pos++;
        return token = 6;
      case 44:
        pos++;
        return token = 5;
      // strings
      case 34:
        pos++;
        value = scanString();
        return token = 10;
      // comments
      case 47:
        const start = pos - 1;
        if (text.charCodeAt(pos + 1) === 47) {
          pos += 2;
          while (pos < len) {
            if (isLineBreak(text.charCodeAt(pos))) {
              break;
            }
            pos++;
          }
          value = text.substring(start, pos);
          return token = 12;
        }
        if (text.charCodeAt(pos + 1) === 42) {
          pos += 2;
          const safeLength = len - 1;
          let commentClosed = false;
          while (pos < safeLength) {
            const ch = text.charCodeAt(pos);
            if (ch === 42 && text.charCodeAt(pos + 1) === 47) {
              pos += 2;
              commentClosed = true;
              break;
            }
            pos++;
            if (isLineBreak(ch)) {
              if (ch === 13 && text.charCodeAt(pos) === 10) {
                pos++;
              }
              lineNumber++;
              tokenLineStartOffset = pos;
            }
          }
          if (!commentClosed) {
            pos++;
            scanError = 1;
          }
          value = text.substring(start, pos);
          return token = 13;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
      // numbers
      case 45:
        value += String.fromCharCode(code);
        pos++;
        if (pos === len || !isDigit(text.charCodeAt(pos))) {
          return token = 16;
        }
      // found a minus, followed by a number so
      // we fall through to proceed with scanning
      // numbers
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        value += scanNumber();
        return token = 11;
      // literals and unknown symbols
      default:
        while (pos < len && isUnknownContentCharacter(code)) {
          pos++;
          code = text.charCodeAt(pos);
        }
        if (tokenOffset !== pos) {
          value = text.substring(tokenOffset, pos);
          switch (value) {
            case "true":
              return token = 8;
            case "false":
              return token = 9;
            case "null":
              return token = 7;
          }
          return token = 16;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
    }
  }
  function isUnknownContentCharacter(code) {
    if (isWhiteSpace(code) || isLineBreak(code)) {
      return false;
    }
    switch (code) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  function scanNextNonTrivia() {
    let result;
    do {
      result = scanNext();
    } while (result >= 12 && result <= 15);
    return result;
  }
  return {
    setPosition,
    getPosition: () => pos,
    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
    getToken: () => token,
    getTokenValue: () => value,
    getTokenOffset: () => tokenOffset,
    getTokenLength: () => pos - tokenOffset,
    getTokenStartLine: () => lineStartOffset,
    getTokenStartCharacter: () => tokenOffset - prevTokenLineStartOffset,
    getTokenError: () => scanError
  };
}
function isWhiteSpace(ch) {
  return ch === 32 || ch === 9;
}
function isLineBreak(ch) {
  return ch === 10 || ch === 13;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}
var CharacterCodes;
(function(CharacterCodes2) {
  CharacterCodes2[CharacterCodes2["lineFeed"] = 10] = "lineFeed";
  CharacterCodes2[CharacterCodes2["carriageReturn"] = 13] = "carriageReturn";
  CharacterCodes2[CharacterCodes2["space"] = 32] = "space";
  CharacterCodes2[CharacterCodes2["_0"] = 48] = "_0";
  CharacterCodes2[CharacterCodes2["_1"] = 49] = "_1";
  CharacterCodes2[CharacterCodes2["_2"] = 50] = "_2";
  CharacterCodes2[CharacterCodes2["_3"] = 51] = "_3";
  CharacterCodes2[CharacterCodes2["_4"] = 52] = "_4";
  CharacterCodes2[CharacterCodes2["_5"] = 53] = "_5";
  CharacterCodes2[CharacterCodes2["_6"] = 54] = "_6";
  CharacterCodes2[CharacterCodes2["_7"] = 55] = "_7";
  CharacterCodes2[CharacterCodes2["_8"] = 56] = "_8";
  CharacterCodes2[CharacterCodes2["_9"] = 57] = "_9";
  CharacterCodes2[CharacterCodes2["a"] = 97] = "a";
  CharacterCodes2[CharacterCodes2["b"] = 98] = "b";
  CharacterCodes2[CharacterCodes2["c"] = 99] = "c";
  CharacterCodes2[CharacterCodes2["d"] = 100] = "d";
  CharacterCodes2[CharacterCodes2["e"] = 101] = "e";
  CharacterCodes2[CharacterCodes2["f"] = 102] = "f";
  CharacterCodes2[CharacterCodes2["g"] = 103] = "g";
  CharacterCodes2[CharacterCodes2["h"] = 104] = "h";
  CharacterCodes2[CharacterCodes2["i"] = 105] = "i";
  CharacterCodes2[CharacterCodes2["j"] = 106] = "j";
  CharacterCodes2[CharacterCodes2["k"] = 107] = "k";
  CharacterCodes2[CharacterCodes2["l"] = 108] = "l";
  CharacterCodes2[CharacterCodes2["m"] = 109] = "m";
  CharacterCodes2[CharacterCodes2["n"] = 110] = "n";
  CharacterCodes2[CharacterCodes2["o"] = 111] = "o";
  CharacterCodes2[CharacterCodes2["p"] = 112] = "p";
  CharacterCodes2[CharacterCodes2["q"] = 113] = "q";
  CharacterCodes2[CharacterCodes2["r"] = 114] = "r";
  CharacterCodes2[CharacterCodes2["s"] = 115] = "s";
  CharacterCodes2[CharacterCodes2["t"] = 116] = "t";
  CharacterCodes2[CharacterCodes2["u"] = 117] = "u";
  CharacterCodes2[CharacterCodes2["v"] = 118] = "v";
  CharacterCodes2[CharacterCodes2["w"] = 119] = "w";
  CharacterCodes2[CharacterCodes2["x"] = 120] = "x";
  CharacterCodes2[CharacterCodes2["y"] = 121] = "y";
  CharacterCodes2[CharacterCodes2["z"] = 122] = "z";
  CharacterCodes2[CharacterCodes2["A"] = 65] = "A";
  CharacterCodes2[CharacterCodes2["B"] = 66] = "B";
  CharacterCodes2[CharacterCodes2["C"] = 67] = "C";
  CharacterCodes2[CharacterCodes2["D"] = 68] = "D";
  CharacterCodes2[CharacterCodes2["E"] = 69] = "E";
  CharacterCodes2[CharacterCodes2["F"] = 70] = "F";
  CharacterCodes2[CharacterCodes2["G"] = 71] = "G";
  CharacterCodes2[CharacterCodes2["H"] = 72] = "H";
  CharacterCodes2[CharacterCodes2["I"] = 73] = "I";
  CharacterCodes2[CharacterCodes2["J"] = 74] = "J";
  CharacterCodes2[CharacterCodes2["K"] = 75] = "K";
  CharacterCodes2[CharacterCodes2["L"] = 76] = "L";
  CharacterCodes2[CharacterCodes2["M"] = 77] = "M";
  CharacterCodes2[CharacterCodes2["N"] = 78] = "N";
  CharacterCodes2[CharacterCodes2["O"] = 79] = "O";
  CharacterCodes2[CharacterCodes2["P"] = 80] = "P";
  CharacterCodes2[CharacterCodes2["Q"] = 81] = "Q";
  CharacterCodes2[CharacterCodes2["R"] = 82] = "R";
  CharacterCodes2[CharacterCodes2["S"] = 83] = "S";
  CharacterCodes2[CharacterCodes2["T"] = 84] = "T";
  CharacterCodes2[CharacterCodes2["U"] = 85] = "U";
  CharacterCodes2[CharacterCodes2["V"] = 86] = "V";
  CharacterCodes2[CharacterCodes2["W"] = 87] = "W";
  CharacterCodes2[CharacterCodes2["X"] = 88] = "X";
  CharacterCodes2[CharacterCodes2["Y"] = 89] = "Y";
  CharacterCodes2[CharacterCodes2["Z"] = 90] = "Z";
  CharacterCodes2[CharacterCodes2["asterisk"] = 42] = "asterisk";
  CharacterCodes2[CharacterCodes2["backslash"] = 92] = "backslash";
  CharacterCodes2[CharacterCodes2["closeBrace"] = 125] = "closeBrace";
  CharacterCodes2[CharacterCodes2["closeBracket"] = 93] = "closeBracket";
  CharacterCodes2[CharacterCodes2["colon"] = 58] = "colon";
  CharacterCodes2[CharacterCodes2["comma"] = 44] = "comma";
  CharacterCodes2[CharacterCodes2["dot"] = 46] = "dot";
  CharacterCodes2[CharacterCodes2["doubleQuote"] = 34] = "doubleQuote";
  CharacterCodes2[CharacterCodes2["minus"] = 45] = "minus";
  CharacterCodes2[CharacterCodes2["openBrace"] = 123] = "openBrace";
  CharacterCodes2[CharacterCodes2["openBracket"] = 91] = "openBracket";
  CharacterCodes2[CharacterCodes2["plus"] = 43] = "plus";
  CharacterCodes2[CharacterCodes2["slash"] = 47] = "slash";
  CharacterCodes2[CharacterCodes2["formFeed"] = 12] = "formFeed";
  CharacterCodes2[CharacterCodes2["tab"] = 9] = "tab";
})(CharacterCodes || (CharacterCodes = {}));

// node_modules/.pnpm/jsonc-parser@3.2.0/node_modules/jsonc-parser/lib/esm/impl/parser.js
var ParseOptions;
(function(ParseOptions2) {
  ParseOptions2.DEFAULT = {
    allowTrailingComma: false
  };
})(ParseOptions || (ParseOptions = {}));
function parse(text, errors = [], options = ParseOptions.DEFAULT) {
  let currentProperty = null;
  let currentParent = [];
  const previousParents = [];
  function onValue(value) {
    if (Array.isArray(currentParent)) {
      currentParent.push(value);
    } else if (currentProperty !== null) {
      currentParent[currentProperty] = value;
    }
  }
  const visitor = {
    onObjectBegin: () => {
      const object = {};
      onValue(object);
      previousParents.push(currentParent);
      currentParent = object;
      currentProperty = null;
    },
    onObjectProperty: (name) => {
      currentProperty = name;
    },
    onObjectEnd: () => {
      currentParent = previousParents.pop();
    },
    onArrayBegin: () => {
      const array = [];
      onValue(array);
      previousParents.push(currentParent);
      currentParent = array;
      currentProperty = null;
    },
    onArrayEnd: () => {
      currentParent = previousParents.pop();
    },
    onLiteralValue: onValue,
    onError: (error, offset, length) => {
      errors.push({ error, offset, length });
    }
  };
  visit(text, visitor, options);
  return currentParent[0];
}
function getNodeValue(node) {
  switch (node.type) {
    case "array":
      return node.children.map(getNodeValue);
    case "object":
      const obj = /* @__PURE__ */ Object.create(null);
      for (let prop of node.children) {
        const valueNode = prop.children[1];
        if (valueNode) {
          obj[prop.children[0].value] = getNodeValue(valueNode);
        }
      }
      return obj;
    case "null":
    case "string":
    case "number":
    case "boolean":
      return node.value;
    default:
      return void 0;
  }
}
function contains(node, offset, includeRightBound = false) {
  return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;
}
function findNodeAtOffset(node, offset, includeRightBound = false) {
  if (contains(node, offset, includeRightBound)) {
    const children = node.children;
    if (Array.isArray(children)) {
      for (let i = 0; i < children.length && children[i].offset <= offset; i++) {
        const item = findNodeAtOffset(children[i], offset, includeRightBound);
        if (item) {
          return item;
        }
      }
    }
    return node;
  }
  return void 0;
}
function visit(text, visitor, options = ParseOptions.DEFAULT) {
  const _scanner = createScanner(text, false);
  const _jsonPath = [];
  function toNoArgVisit(visitFunction) {
    return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;
  }
  function toNoArgVisitWithPath(visitFunction) {
    return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;
  }
  function toOneArgVisit(visitFunction) {
    return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;
  }
  function toOneArgVisitWithPath(visitFunction) {
    return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;
  }
  const onObjectBegin = toNoArgVisitWithPath(visitor.onObjectBegin), onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisitWithPath(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
  const disallowComments = options && options.disallowComments;
  const allowTrailingComma = options && options.allowTrailingComma;
  function scanNext() {
    while (true) {
      const token = _scanner.scan();
      switch (_scanner.getTokenError()) {
        case 4:
          handleError(
            14
            /* ParseErrorCode.InvalidUnicode */
          );
          break;
        case 5:
          handleError(
            15
            /* ParseErrorCode.InvalidEscapeCharacter */
          );
          break;
        case 3:
          handleError(
            13
            /* ParseErrorCode.UnexpectedEndOfNumber */
          );
          break;
        case 1:
          if (!disallowComments) {
            handleError(
              11
              /* ParseErrorCode.UnexpectedEndOfComment */
            );
          }
          break;
        case 2:
          handleError(
            12
            /* ParseErrorCode.UnexpectedEndOfString */
          );
          break;
        case 6:
          handleError(
            16
            /* ParseErrorCode.InvalidCharacter */
          );
          break;
      }
      switch (token) {
        case 12:
        case 13:
          if (disallowComments) {
            handleError(
              10
              /* ParseErrorCode.InvalidCommentToken */
            );
          } else {
            onComment();
          }
          break;
        case 16:
          handleError(
            1
            /* ParseErrorCode.InvalidSymbol */
          );
          break;
        case 15:
        case 14:
          break;
        default:
          return token;
      }
    }
  }
  function handleError(error, skipUntilAfter = [], skipUntil = []) {
    onError(error);
    if (skipUntilAfter.length + skipUntil.length > 0) {
      let token = _scanner.getToken();
      while (token !== 17) {
        if (skipUntilAfter.indexOf(token) !== -1) {
          scanNext();
          break;
        } else if (skipUntil.indexOf(token) !== -1) {
          break;
        }
        token = scanNext();
      }
    }
  }
  function parseString(isValue) {
    const value = _scanner.getTokenValue();
    if (isValue) {
      onLiteralValue(value);
    } else {
      onObjectProperty(value);
      _jsonPath.push(value);
    }
    scanNext();
    return true;
  }
  function parseLiteral() {
    switch (_scanner.getToken()) {
      case 11:
        const tokenValue = _scanner.getTokenValue();
        let value = Number(tokenValue);
        if (isNaN(value)) {
          handleError(
            2
            /* ParseErrorCode.InvalidNumberFormat */
          );
          value = 0;
        }
        onLiteralValue(value);
        break;
      case 7:
        onLiteralValue(null);
        break;
      case 8:
        onLiteralValue(true);
        break;
      case 9:
        onLiteralValue(false);
        break;
      default:
        return false;
    }
    scanNext();
    return true;
  }
  function parseProperty() {
    if (_scanner.getToken() !== 10) {
      handleError(3, [], [
        2,
        5
        /* SyntaxKind.CommaToken */
      ]);
      return false;
    }
    parseString(false);
    if (_scanner.getToken() === 6) {
      onSeparator(":");
      scanNext();
      if (!parseValue()) {
        handleError(4, [], [
          2,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
    } else {
      handleError(5, [], [
        2,
        5
        /* SyntaxKind.CommaToken */
      ]);
    }
    _jsonPath.pop();
    return true;
  }
  function parseObject() {
    onObjectBegin();
    scanNext();
    let needsComma = false;
    while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 2 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseProperty()) {
        handleError(4, [], [
          2,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
      needsComma = true;
    }
    onObjectEnd();
    if (_scanner.getToken() !== 2) {
      handleError(7, [
        2
        /* SyntaxKind.CloseBraceToken */
      ], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseArray() {
    onArrayBegin();
    scanNext();
    let isFirstElement = true;
    let needsComma = false;
    while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 4 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (isFirstElement) {
        _jsonPath.push(0);
        isFirstElement = false;
      } else {
        _jsonPath[_jsonPath.length - 1]++;
      }
      if (!parseValue()) {
        handleError(4, [], [
          4,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
      needsComma = true;
    }
    onArrayEnd();
    if (!isFirstElement) {
      _jsonPath.pop();
    }
    if (_scanner.getToken() !== 4) {
      handleError(8, [
        4
        /* SyntaxKind.CloseBracketToken */
      ], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseValue() {
    switch (_scanner.getToken()) {
      case 3:
        return parseArray();
      case 1:
        return parseObject();
      case 10:
        return parseString(true);
      default:
        return parseLiteral();
    }
  }
  scanNext();
  if (_scanner.getToken() === 17) {
    if (options.allowEmptyContent) {
      return true;
    }
    handleError(4, [], []);
    return false;
  }
  if (!parseValue()) {
    handleError(4, [], []);
    return false;
  }
  if (_scanner.getToken() !== 17) {
    handleError(9, [], []);
  }
  return true;
}

// node_modules/.pnpm/jsonc-parser@3.2.0/node_modules/jsonc-parser/lib/esm/main.js
var ScanError;
(function(ScanError2) {
  ScanError2[ScanError2["None"] = 0] = "None";
  ScanError2[ScanError2["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
  ScanError2[ScanError2["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
  ScanError2[ScanError2["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
  ScanError2[ScanError2["InvalidUnicode"] = 4] = "InvalidUnicode";
  ScanError2[ScanError2["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
  ScanError2[ScanError2["InvalidCharacter"] = 6] = "InvalidCharacter";
})(ScanError || (ScanError = {}));
var SyntaxKind;
(function(SyntaxKind2) {
  SyntaxKind2[SyntaxKind2["OpenBraceToken"] = 1] = "OpenBraceToken";
  SyntaxKind2[SyntaxKind2["CloseBraceToken"] = 2] = "CloseBraceToken";
  SyntaxKind2[SyntaxKind2["OpenBracketToken"] = 3] = "OpenBracketToken";
  SyntaxKind2[SyntaxKind2["CloseBracketToken"] = 4] = "CloseBracketToken";
  SyntaxKind2[SyntaxKind2["CommaToken"] = 5] = "CommaToken";
  SyntaxKind2[SyntaxKind2["ColonToken"] = 6] = "ColonToken";
  SyntaxKind2[SyntaxKind2["NullKeyword"] = 7] = "NullKeyword";
  SyntaxKind2[SyntaxKind2["TrueKeyword"] = 8] = "TrueKeyword";
  SyntaxKind2[SyntaxKind2["FalseKeyword"] = 9] = "FalseKeyword";
  SyntaxKind2[SyntaxKind2["StringLiteral"] = 10] = "StringLiteral";
  SyntaxKind2[SyntaxKind2["NumericLiteral"] = 11] = "NumericLiteral";
  SyntaxKind2[SyntaxKind2["LineCommentTrivia"] = 12] = "LineCommentTrivia";
  SyntaxKind2[SyntaxKind2["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
  SyntaxKind2[SyntaxKind2["LineBreakTrivia"] = 14] = "LineBreakTrivia";
  SyntaxKind2[SyntaxKind2["Trivia"] = 15] = "Trivia";
  SyntaxKind2[SyntaxKind2["Unknown"] = 16] = "Unknown";
  SyntaxKind2[SyntaxKind2["EOF"] = 17] = "EOF";
})(SyntaxKind || (SyntaxKind = {}));
var parse2 = parse;
var findNodeAtOffset2 = findNodeAtOffset;
var getNodeValue2 = getNodeValue;
var ParseErrorCode;
(function(ParseErrorCode2) {
  ParseErrorCode2[ParseErrorCode2["InvalidSymbol"] = 1] = "InvalidSymbol";
  ParseErrorCode2[ParseErrorCode2["InvalidNumberFormat"] = 2] = "InvalidNumberFormat";
  ParseErrorCode2[ParseErrorCode2["PropertyNameExpected"] = 3] = "PropertyNameExpected";
  ParseErrorCode2[ParseErrorCode2["ValueExpected"] = 4] = "ValueExpected";
  ParseErrorCode2[ParseErrorCode2["ColonExpected"] = 5] = "ColonExpected";
  ParseErrorCode2[ParseErrorCode2["CommaExpected"] = 6] = "CommaExpected";
  ParseErrorCode2[ParseErrorCode2["CloseBraceExpected"] = 7] = "CloseBraceExpected";
  ParseErrorCode2[ParseErrorCode2["CloseBracketExpected"] = 8] = "CloseBracketExpected";
  ParseErrorCode2[ParseErrorCode2["EndOfFileExpected"] = 9] = "EndOfFileExpected";
  ParseErrorCode2[ParseErrorCode2["InvalidCommentToken"] = 10] = "InvalidCommentToken";
  ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfComment"] = 11] = "UnexpectedEndOfComment";
  ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfString"] = 12] = "UnexpectedEndOfString";
  ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfNumber"] = 13] = "UnexpectedEndOfNumber";
  ParseErrorCode2[ParseErrorCode2["InvalidUnicode"] = 14] = "InvalidUnicode";
  ParseErrorCode2[ParseErrorCode2["InvalidEscapeCharacter"] = 15] = "InvalidEscapeCharacter";
  ParseErrorCode2[ParseErrorCode2["InvalidCharacter"] = 16] = "InvalidCharacter";
})(ParseErrorCode || (ParseErrorCode = {}));

// node_modules/.pnpm/vscode-uri@3.0.8/node_modules/vscode-uri/lib/esm/index.mjs
var LIB;
(() => {
  "use strict";
  var t = { 470: (t2) => {
    function e2(t3) {
      if ("string" != typeof t3) throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
    }
    function r2(t3, e3) {
      for (var r3, n3 = "", i = 0, o = -1, s = 0, h = 0; h <= t3.length; ++h) {
        if (h < t3.length) r3 = t3.charCodeAt(h);
        else {
          if (47 === r3) break;
          r3 = 47;
        }
        if (47 === r3) {
          if (o === h - 1 || 1 === s) ;
          else if (o !== h - 1 && 2 === s) {
            if (n3.length < 2 || 2 !== i || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
              if (n3.length > 2) {
                var a2 = n3.lastIndexOf("/");
                if (a2 !== n3.length - 1) {
                  -1 === a2 ? (n3 = "", i = 0) : i = (n3 = n3.slice(0, a2)).length - 1 - n3.lastIndexOf("/"), o = h, s = 0;
                  continue;
                }
              } else if (2 === n3.length || 1 === n3.length) {
                n3 = "", i = 0, o = h, s = 0;
                continue;
              }
            }
            e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", i = 2);
          } else n3.length > 0 ? n3 += "/" + t3.slice(o + 1, h) : n3 = t3.slice(o + 1, h), i = h - o - 1;
          o = h, s = 0;
        } else 46 === r3 && -1 !== s ? ++s : s = -1;
      }
      return n3;
    }
    var n2 = { resolve: function() {
      for (var t3, n3 = "", i = false, o = arguments.length - 1; o >= -1 && !i; o--) {
        var s;
        o >= 0 ? s = arguments[o] : (void 0 === t3 && (t3 = process.cwd()), s = t3), e2(s), 0 !== s.length && (n3 = s + "/" + n3, i = 47 === s.charCodeAt(0));
      }
      return n3 = r2(n3, !i), i ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
    }, normalize: function(t3) {
      if (e2(t3), 0 === t3.length) return ".";
      var n3 = 47 === t3.charCodeAt(0), i = 47 === t3.charCodeAt(t3.length - 1);
      return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && i && (t3 += "/"), n3 ? "/" + t3 : t3;
    }, isAbsolute: function(t3) {
      return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
    }, join: function() {
      if (0 === arguments.length) return ".";
      for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
        var i = arguments[r3];
        e2(i), i.length > 0 && (void 0 === t3 ? t3 = i : t3 += "/" + i);
      }
      return void 0 === t3 ? "." : n2.normalize(t3);
    }, relative: function(t3, r3) {
      if (e2(t3), e2(r3), t3 === r3) return "";
      if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3))) return "";
      for (var i = 1; i < t3.length && 47 === t3.charCodeAt(i); ++i) ;
      for (var o = t3.length, s = o - i, h = 1; h < r3.length && 47 === r3.charCodeAt(h); ++h) ;
      for (var a2 = r3.length - h, c = s < a2 ? s : a2, f2 = -1, u = 0; u <= c; ++u) {
        if (u === c) {
          if (a2 > c) {
            if (47 === r3.charCodeAt(h + u)) return r3.slice(h + u + 1);
            if (0 === u) return r3.slice(h + u);
          } else s > c && (47 === t3.charCodeAt(i + u) ? f2 = u : 0 === u && (f2 = 0));
          break;
        }
        var l = t3.charCodeAt(i + u);
        if (l !== r3.charCodeAt(h + u)) break;
        47 === l && (f2 = u);
      }
      var g = "";
      for (u = i + f2 + 1; u <= o; ++u) u !== o && 47 !== t3.charCodeAt(u) || (0 === g.length ? g += ".." : g += "/..");
      return g.length > 0 ? g + r3.slice(h + f2) : (h += f2, 47 === r3.charCodeAt(h) && ++h, r3.slice(h));
    }, _makeLong: function(t3) {
      return t3;
    }, dirname: function(t3) {
      if (e2(t3), 0 === t3.length) return ".";
      for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i = -1, o = true, s = t3.length - 1; s >= 1; --s) if (47 === (r3 = t3.charCodeAt(s))) {
        if (!o) {
          i = s;
          break;
        }
      } else o = false;
      return -1 === i ? n3 ? "/" : "." : n3 && 1 === i ? "//" : t3.slice(0, i);
    }, basename: function(t3, r3) {
      if (void 0 !== r3 && "string" != typeof r3) throw new TypeError('"ext" argument must be a string');
      e2(t3);
      var n3, i = 0, o = -1, s = true;
      if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
        if (r3.length === t3.length && r3 === t3) return "";
        var h = r3.length - 1, a2 = -1;
        for (n3 = t3.length - 1; n3 >= 0; --n3) {
          var c = t3.charCodeAt(n3);
          if (47 === c) {
            if (!s) {
              i = n3 + 1;
              break;
            }
          } else -1 === a2 && (s = false, a2 = n3 + 1), h >= 0 && (c === r3.charCodeAt(h) ? -1 == --h && (o = n3) : (h = -1, o = a2));
        }
        return i === o ? o = a2 : -1 === o && (o = t3.length), t3.slice(i, o);
      }
      for (n3 = t3.length - 1; n3 >= 0; --n3) if (47 === t3.charCodeAt(n3)) {
        if (!s) {
          i = n3 + 1;
          break;
        }
      } else -1 === o && (s = false, o = n3 + 1);
      return -1 === o ? "" : t3.slice(i, o);
    }, extname: function(t3) {
      e2(t3);
      for (var r3 = -1, n3 = 0, i = -1, o = true, s = 0, h = t3.length - 1; h >= 0; --h) {
        var a2 = t3.charCodeAt(h);
        if (47 !== a2) -1 === i && (o = false, i = h + 1), 46 === a2 ? -1 === r3 ? r3 = h : 1 !== s && (s = 1) : -1 !== r3 && (s = -1);
        else if (!o) {
          n3 = h + 1;
          break;
        }
      }
      return -1 === r3 || -1 === i || 0 === s || 1 === s && r3 === i - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, i);
    }, format: function(t3) {
      if (null === t3 || "object" != typeof t3) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
      return (function(t4, e3) {
        var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
        return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
      })(0, t3);
    }, parse: function(t3) {
      e2(t3);
      var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
      if (0 === t3.length) return r3;
      var n3, i = t3.charCodeAt(0), o = 47 === i;
      o ? (r3.root = "/", n3 = 1) : n3 = 0;
      for (var s = -1, h = 0, a2 = -1, c = true, f2 = t3.length - 1, u = 0; f2 >= n3; --f2) if (47 !== (i = t3.charCodeAt(f2))) -1 === a2 && (c = false, a2 = f2 + 1), 46 === i ? -1 === s ? s = f2 : 1 !== u && (u = 1) : -1 !== s && (u = -1);
      else if (!c) {
        h = f2 + 1;
        break;
      }
      return -1 === s || -1 === a2 || 0 === u || 1 === u && s === a2 - 1 && s === h + 1 ? -1 !== a2 && (r3.base = r3.name = 0 === h && o ? t3.slice(1, a2) : t3.slice(h, a2)) : (0 === h && o ? (r3.name = t3.slice(1, s), r3.base = t3.slice(1, a2)) : (r3.name = t3.slice(h, s), r3.base = t3.slice(h, a2)), r3.ext = t3.slice(s, a2)), h > 0 ? r3.dir = t3.slice(0, h - 1) : o && (r3.dir = "/"), r3;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    n2.posix = n2, t2.exports = n2;
  } }, e = {};
  function r(n2) {
    var i = e[n2];
    if (void 0 !== i) return i.exports;
    var o = e[n2] = { exports: {} };
    return t[n2](o, o.exports, r), o.exports;
  }
  r.d = (t2, e2) => {
    for (var n2 in e2) r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
  }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
  };
  var n = {};
  (() => {
    let t2;
    if (r.r(n), r.d(n, { URI: () => f2, Utils: () => P }), "object" == typeof process) t2 = "win32" === process.platform;
    else if ("object" == typeof navigator) {
      let e3 = navigator.userAgent;
      t2 = e3.indexOf("Windows") >= 0;
    }
    const e2 = /^\w[\w\d+.-]*$/, i = /^\//, o = /^\/\//;
    function s(t3, r2) {
      if (!t3.scheme && r2) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t3.authority}", path: "${t3.path}", query: "${t3.query}", fragment: "${t3.fragment}"}`);
      if (t3.scheme && !e2.test(t3.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
      if (t3.path) {
        if (t3.authority) {
          if (!i.test(t3.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
        } else if (o.test(t3.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
    const h = "", a2 = "/", c = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    class f2 {
      static isUri(t3) {
        return t3 instanceof f2 || !!t3 && "string" == typeof t3.authority && "string" == typeof t3.fragment && "string" == typeof t3.path && "string" == typeof t3.query && "string" == typeof t3.scheme && "string" == typeof t3.fsPath && "function" == typeof t3.with && "function" == typeof t3.toString;
      }
      scheme;
      authority;
      path;
      query;
      fragment;
      constructor(t3, e3, r2, n2, i2, o2 = false) {
        "object" == typeof t3 ? (this.scheme = t3.scheme || h, this.authority = t3.authority || h, this.path = t3.path || h, this.query = t3.query || h, this.fragment = t3.fragment || h) : (this.scheme = /* @__PURE__ */ (function(t4, e4) {
          return t4 || e4 ? t4 : "file";
        })(t3, o2), this.authority = e3 || h, this.path = (function(t4, e4) {
          switch (t4) {
            case "https":
            case "http":
            case "file":
              e4 ? e4[0] !== a2 && (e4 = a2 + e4) : e4 = a2;
          }
          return e4;
        })(this.scheme, r2 || h), this.query = n2 || h, this.fragment = i2 || h, s(this, o2));
      }
      get fsPath() {
        return m(this, false);
      }
      with(t3) {
        if (!t3) return this;
        let { scheme: e3, authority: r2, path: n2, query: i2, fragment: o2 } = t3;
        return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = h), void 0 === r2 ? r2 = this.authority : null === r2 && (r2 = h), void 0 === n2 ? n2 = this.path : null === n2 && (n2 = h), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = h), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = h), e3 === this.scheme && r2 === this.authority && n2 === this.path && i2 === this.query && o2 === this.fragment ? this : new l(e3, r2, n2, i2, o2);
      }
      static parse(t3, e3 = false) {
        const r2 = c.exec(t3);
        return r2 ? new l(r2[2] || h, C(r2[4] || h), C(r2[5] || h), C(r2[7] || h), C(r2[9] || h), e3) : new l(h, h, h, h, h);
      }
      static file(e3) {
        let r2 = h;
        if (t2 && (e3 = e3.replace(/\\/g, a2)), e3[0] === a2 && e3[1] === a2) {
          const t3 = e3.indexOf(a2, 2);
          -1 === t3 ? (r2 = e3.substring(2), e3 = a2) : (r2 = e3.substring(2, t3), e3 = e3.substring(t3) || a2);
        }
        return new l("file", r2, e3, h, h);
      }
      static from(t3) {
        const e3 = new l(t3.scheme, t3.authority, t3.path, t3.query, t3.fragment);
        return s(e3, true), e3;
      }
      toString(t3 = false) {
        return y(this, t3);
      }
      toJSON() {
        return this;
      }
      static revive(t3) {
        if (t3) {
          if (t3 instanceof f2) return t3;
          {
            const e3 = new l(t3);
            return e3._formatted = t3.external, e3._fsPath = t3._sep === u ? t3.fsPath : null, e3;
          }
        }
        return t3;
      }
    }
    const u = t2 ? 1 : void 0;
    class l extends f2 {
      _formatted = null;
      _fsPath = null;
      get fsPath() {
        return this._fsPath || (this._fsPath = m(this, false)), this._fsPath;
      }
      toString(t3 = false) {
        return t3 ? y(this, true) : (this._formatted || (this._formatted = y(this, false)), this._formatted);
      }
      toJSON() {
        const t3 = { $mid: 1 };
        return this._fsPath && (t3.fsPath = this._fsPath, t3._sep = u), this._formatted && (t3.external = this._formatted), this.path && (t3.path = this.path), this.scheme && (t3.scheme = this.scheme), this.authority && (t3.authority = this.authority), this.query && (t3.query = this.query), this.fragment && (t3.fragment = this.fragment), t3;
      }
    }
    const g = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
    function d(t3, e3, r2) {
      let n2, i2 = -1;
      for (let o2 = 0; o2 < t3.length; o2++) {
        const s2 = t3.charCodeAt(o2);
        if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e3 && 47 === s2 || r2 && 91 === s2 || r2 && 93 === s2 || r2 && 58 === s2) -1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), void 0 !== n2 && (n2 += t3.charAt(o2));
        else {
          void 0 === n2 && (n2 = t3.substr(0, o2));
          const e4 = g[s2];
          void 0 !== e4 ? (-1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), n2 += e4) : -1 === i2 && (i2 = o2);
        }
      }
      return -1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2))), void 0 !== n2 ? n2 : t3;
    }
    function p(t3) {
      let e3;
      for (let r2 = 0; r2 < t3.length; r2++) {
        const n2 = t3.charCodeAt(r2);
        35 === n2 || 63 === n2 ? (void 0 === e3 && (e3 = t3.substr(0, r2)), e3 += g[n2]) : void 0 !== e3 && (e3 += t3[r2]);
      }
      return void 0 !== e3 ? e3 : t3;
    }
    function m(e3, r2) {
      let n2;
      return n2 = e3.authority && e3.path.length > 1 && "file" === e3.scheme ? `//${e3.authority}${e3.path}` : 47 === e3.path.charCodeAt(0) && (e3.path.charCodeAt(1) >= 65 && e3.path.charCodeAt(1) <= 90 || e3.path.charCodeAt(1) >= 97 && e3.path.charCodeAt(1) <= 122) && 58 === e3.path.charCodeAt(2) ? r2 ? e3.path.substr(1) : e3.path[1].toLowerCase() + e3.path.substr(2) : e3.path, t2 && (n2 = n2.replace(/\//g, "\\")), n2;
    }
    function y(t3, e3) {
      const r2 = e3 ? p : d;
      let n2 = "", { scheme: i2, authority: o2, path: s2, query: h2, fragment: c2 } = t3;
      if (i2 && (n2 += i2, n2 += ":"), (o2 || "file" === i2) && (n2 += a2, n2 += a2), o2) {
        let t4 = o2.indexOf("@");
        if (-1 !== t4) {
          const e4 = o2.substr(0, t4);
          o2 = o2.substr(t4 + 1), t4 = e4.lastIndexOf(":"), -1 === t4 ? n2 += r2(e4, false, false) : (n2 += r2(e4.substr(0, t4), false, false), n2 += ":", n2 += r2(e4.substr(t4 + 1), false, true)), n2 += "@";
        }
        o2 = o2.toLowerCase(), t4 = o2.lastIndexOf(":"), -1 === t4 ? n2 += r2(o2, false, true) : (n2 += r2(o2.substr(0, t4), false, true), n2 += o2.substr(t4));
      }
      if (s2) {
        if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {
          const t4 = s2.charCodeAt(1);
          t4 >= 65 && t4 <= 90 && (s2 = `/${String.fromCharCode(t4 + 32)}:${s2.substr(3)}`);
        } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {
          const t4 = s2.charCodeAt(0);
          t4 >= 65 && t4 <= 90 && (s2 = `${String.fromCharCode(t4 + 32)}:${s2.substr(2)}`);
        }
        n2 += r2(s2, true, false);
      }
      return h2 && (n2 += "?", n2 += r2(h2, false, false)), c2 && (n2 += "#", n2 += e3 ? c2 : d(c2, false, false)), n2;
    }
    function v(t3) {
      try {
        return decodeURIComponent(t3);
      } catch {
        return t3.length > 3 ? t3.substr(0, 3) + v(t3.substr(3)) : t3;
      }
    }
    const b = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
    function C(t3) {
      return t3.match(b) ? t3.replace(b, ((t4) => v(t4))) : t3;
    }
    var A2 = r(470);
    const w = A2.posix || A2, x = "/";
    var P;
    !(function(t3) {
      t3.joinPath = function(t4, ...e3) {
        return t4.with({ path: w.join(t4.path, ...e3) });
      }, t3.resolvePath = function(t4, ...e3) {
        let r2 = t4.path, n2 = false;
        r2[0] !== x && (r2 = x + r2, n2 = true);
        let i2 = w.resolve(r2, ...e3);
        return n2 && i2[0] === x && !t4.authority && (i2 = i2.substring(1)), t4.with({ path: i2 });
      }, t3.dirname = function(t4) {
        if (0 === t4.path.length || t4.path === x) return t4;
        let e3 = w.dirname(t4.path);
        return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = ""), t4.with({ path: e3 });
      }, t3.basename = function(t4) {
        return w.basename(t4.path);
      }, t3.extname = function(t4) {
        return w.extname(t4.path);
      };
    })(P || (P = {}));
  })(), LIB = n;
})();
var { URI: URI2, Utils } = LIB;

// node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/esm/main.js
var DocumentUri;
(function(DocumentUri2) {
  function is(value) {
    return typeof value === "string";
  }
  DocumentUri2.is = is;
})(DocumentUri || (DocumentUri = {}));
var URI3;
(function(URI4) {
  function is(value) {
    return typeof value === "string";
  }
  URI4.is = is;
})(URI3 || (URI3 = {}));
var integer;
(function(integer2) {
  integer2.MIN_VALUE = -2147483648;
  integer2.MAX_VALUE = 2147483647;
  function is(value) {
    return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
  }
  integer2.is = is;
})(integer || (integer = {}));
var uinteger;
(function(uinteger2) {
  uinteger2.MIN_VALUE = 0;
  uinteger2.MAX_VALUE = 2147483647;
  function is(value) {
    return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
  }
  uinteger2.is = is;
})(uinteger || (uinteger = {}));
var Position2;
(function(Position3) {
  function create(line, character) {
    if (line === Number.MAX_VALUE) {
      line = uinteger.MAX_VALUE;
    }
    if (character === Number.MAX_VALUE) {
      character = uinteger.MAX_VALUE;
    }
    return { line, character };
  }
  Position3.create = create;
  function is(value) {
    let candidate = value;
    return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
  }
  Position3.is = is;
})(Position2 || (Position2 = {}));
var Range2;
(function(Range3) {
  function create(one, two, three, four) {
    if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
      return { start: Position2.create(one, two), end: Position2.create(three, four) };
    } else if (Position2.is(one) && Position2.is(two)) {
      return { start: one, end: two };
    } else {
      throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);
    }
  }
  Range3.create = create;
  function is(value) {
    let candidate = value;
    return Is.objectLiteral(candidate) && Position2.is(candidate.start) && Position2.is(candidate.end);
  }
  Range3.is = is;
})(Range2 || (Range2 = {}));
var Location;
(function(Location2) {
  function create(uri, range) {
    return { uri, range };
  }
  Location2.create = create;
  function is(value) {
    let candidate = value;
    return Is.objectLiteral(candidate) && Range2.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
  }
  Location2.is = is;
})(Location || (Location = {}));
var LocationLink;
(function(LocationLink2) {
  function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
    return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
  }
  LocationLink2.create = create;
  function is(value) {
    let candidate = value;
    return Is.objectLiteral(candidate) && Range2.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range2.is(candidate.targetSelectionRange) && (Range2.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
  }
  LocationLink2.is = is;
})(LocationLink || (LocationLink = {}));
var Color2;
(function(Color3) {
  function create(red, green, blue, alpha) {
    return {
      red,
      green,
      blue,
      alpha
    };
  }
  Color3.create = create;
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
  }
  Color3.is = is;
})(Color2 || (Color2 = {}));
var ColorInformation;
(function(ColorInformation2) {
  function create(range, color) {
    return {
      range,
      color
    };
  }
  ColorInformation2.create = create;
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && Range2.is(candidate.range) && Color2.is(candidate.color);
  }
  ColorInformation2.is = is;
})(ColorInformation || (ColorInformation = {}));
var ColorPresentation;
(function(ColorPresentation2) {
  function create(label, textEdit, additionalTextEdits) {
    return {
      label,
      textEdit,
      additionalTextEdits
    };
  }
  ColorPresentation2.create = create;
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
  }
  ColorPresentation2.is = is;
})(ColorPresentation || (ColorPresentation = {}));
var FoldingRangeKind2;
(function(FoldingRangeKind3) {
  FoldingRangeKind3.Comment = "comment";
  FoldingRangeKind3.Imports = "imports";
  FoldingRangeKind3.Region = "region";
})(FoldingRangeKind2 || (FoldingRangeKind2 = {}));
var FoldingRange;
(function(FoldingRange2) {
  function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
    const result = {
      startLine,
      endLine
    };
    if (Is.defined(startCharacter)) {
      result.startCharacter = startCharacter;
    }
    if (Is.defined(endCharacter)) {
      result.endCharacter = endCharacter;
    }
    if (Is.defined(kind)) {
      result.kind = kind;
    }
    if (Is.defined(collapsedText)) {
      result.collapsedText = collapsedText;
    }
    return result;
  }
  FoldingRange2.create = create;
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
  }
  FoldingRange2.is = is;
})(FoldingRange || (FoldingRange = {}));
var DiagnosticRelatedInformation;
(function(DiagnosticRelatedInformation2) {
  function create(location, message) {
    return {
      location,
      message
    };
  }
  DiagnosticRelatedInformation2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
  }
  DiagnosticRelatedInformation2.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
var DiagnosticSeverity;
(function(DiagnosticSeverity2) {
  DiagnosticSeverity2.Error = 1;
  DiagnosticSeverity2.Warning = 2;
  DiagnosticSeverity2.Information = 3;
  DiagnosticSeverity2.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
var DiagnosticTag;
(function(DiagnosticTag2) {
  DiagnosticTag2.Unnecessary = 1;
  DiagnosticTag2.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
var CodeDescription;
(function(CodeDescription2) {
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && Is.string(candidate.href);
  }
  CodeDescription2.is = is;
})(CodeDescription || (CodeDescription = {}));
var Diagnostic;
(function(Diagnostic2) {
  function create(range, message, severity, code, source, relatedInformation) {
    let result = { range, message };
    if (Is.defined(severity)) {
      result.severity = severity;
    }
    if (Is.defined(code)) {
      result.code = code;
    }
    if (Is.defined(source)) {
      result.source = source;
    }
    if (Is.defined(relatedInformation)) {
      result.relatedInformation = relatedInformation;
    }
    return result;
  }
  Diagnostic2.create = create;
  function is(value) {
    var _a4;
    let candidate = value;
    return Is.defined(candidate) && Range2.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a4 = candidate.codeDescription) === null || _a4 === void 0 ? void 0 : _a4.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
  }
  Diagnostic2.is = is;
})(Diagnostic || (Diagnostic = {}));
var Command2;
(function(Command3) {
  function create(title, command, ...args) {
    let result = { title, command };
    if (Is.defined(args) && args.length > 0) {
      result.arguments = args;
    }
    return result;
  }
  Command3.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
  }
  Command3.is = is;
})(Command2 || (Command2 = {}));
var TextEdit;
(function(TextEdit2) {
  function replace(range, newText) {
    return { range, newText };
  }
  TextEdit2.replace = replace;
  function insert(position, newText) {
    return { range: { start: position, end: position }, newText };
  }
  TextEdit2.insert = insert;
  function del(range) {
    return { range, newText: "" };
  }
  TextEdit2.del = del;
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range2.is(candidate.range);
  }
  TextEdit2.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function(ChangeAnnotation2) {
  function create(label, needsConfirmation, description) {
    const result = { label };
    if (needsConfirmation !== void 0) {
      result.needsConfirmation = needsConfirmation;
    }
    if (description !== void 0) {
      result.description = description;
    }
    return result;
  }
  ChangeAnnotation2.create = create;
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
  }
  ChangeAnnotation2.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function(ChangeAnnotationIdentifier2) {
  function is(value) {
    const candidate = value;
    return Is.string(candidate);
  }
  ChangeAnnotationIdentifier2.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function(AnnotatedTextEdit2) {
  function replace(range, newText, annotation) {
    return { range, newText, annotationId: annotation };
  }
  AnnotatedTextEdit2.replace = replace;
  function insert(position, newText, annotation) {
    return { range: { start: position, end: position }, newText, annotationId: annotation };
  }
  AnnotatedTextEdit2.insert = insert;
  function del(range, annotation) {
    return { range, newText: "", annotationId: annotation };
  }
  AnnotatedTextEdit2.del = del;
  function is(value) {
    const candidate = value;
    return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  AnnotatedTextEdit2.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
var TextDocumentEdit;
(function(TextDocumentEdit2) {
  function create(textDocument, edits) {
    return { textDocument, edits };
  }
  TextDocumentEdit2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
  }
  TextDocumentEdit2.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function(CreateFile2) {
  function create(uri, options, annotation) {
    let result = {
      kind: "create",
      uri
    };
    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
      result.options = options;
    }
    if (annotation !== void 0) {
      result.annotationId = annotation;
    }
    return result;
  }
  CreateFile2.create = create;
  function is(value) {
    let candidate = value;
    return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  CreateFile2.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function(RenameFile2) {
  function create(oldUri, newUri, options, annotation) {
    let result = {
      kind: "rename",
      oldUri,
      newUri
    };
    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
      result.options = options;
    }
    if (annotation !== void 0) {
      result.annotationId = annotation;
    }
    return result;
  }
  RenameFile2.create = create;
  function is(value) {
    let candidate = value;
    return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  RenameFile2.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function(DeleteFile2) {
  function create(uri, options, annotation) {
    let result = {
      kind: "delete",
      uri
    };
    if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
      result.options = options;
    }
    if (annotation !== void 0) {
      result.annotationId = annotation;
    }
    return result;
  }
  DeleteFile2.create = create;
  function is(value) {
    let candidate = value;
    return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  DeleteFile2.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function(WorkspaceEdit2) {
  function is(value) {
    let candidate = value;
    return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every((change) => {
      if (Is.string(change.kind)) {
        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
      } else {
        return TextDocumentEdit.is(change);
      }
    }));
  }
  WorkspaceEdit2.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextDocumentIdentifier;
(function(TextDocumentIdentifier2) {
  function create(uri) {
    return { uri };
  }
  TextDocumentIdentifier2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri);
  }
  TextDocumentIdentifier2.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
var VersionedTextDocumentIdentifier;
(function(VersionedTextDocumentIdentifier2) {
  function create(uri, version) {
    return { uri, version };
  }
  VersionedTextDocumentIdentifier2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
  }
  VersionedTextDocumentIdentifier2.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
var OptionalVersionedTextDocumentIdentifier;
(function(OptionalVersionedTextDocumentIdentifier2) {
  function create(uri, version) {
    return { uri, version };
  }
  OptionalVersionedTextDocumentIdentifier2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
  }
  OptionalVersionedTextDocumentIdentifier2.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
var TextDocumentItem;
(function(TextDocumentItem2) {
  function create(uri, languageId, version, text) {
    return { uri, languageId, version, text };
  }
  TextDocumentItem2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
  }
  TextDocumentItem2.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
var MarkupKind;
(function(MarkupKind2) {
  MarkupKind2.PlainText = "plaintext";
  MarkupKind2.Markdown = "markdown";
  function is(value) {
    const candidate = value;
    return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
  }
  MarkupKind2.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function(MarkupContent2) {
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
  }
  MarkupContent2.is = is;
})(MarkupContent || (MarkupContent = {}));
var CompletionItemKind2;
(function(CompletionItemKind3) {
  CompletionItemKind3.Text = 1;
  CompletionItemKind3.Method = 2;
  CompletionItemKind3.Function = 3;
  CompletionItemKind3.Constructor = 4;
  CompletionItemKind3.Field = 5;
  CompletionItemKind3.Variable = 6;
  CompletionItemKind3.Class = 7;
  CompletionItemKind3.Interface = 8;
  CompletionItemKind3.Module = 9;
  CompletionItemKind3.Property = 10;
  CompletionItemKind3.Unit = 11;
  CompletionItemKind3.Value = 12;
  CompletionItemKind3.Enum = 13;
  CompletionItemKind3.Keyword = 14;
  CompletionItemKind3.Snippet = 15;
  CompletionItemKind3.Color = 16;
  CompletionItemKind3.File = 17;
  CompletionItemKind3.Reference = 18;
  CompletionItemKind3.Folder = 19;
  CompletionItemKind3.EnumMember = 20;
  CompletionItemKind3.Constant = 21;
  CompletionItemKind3.Struct = 22;
  CompletionItemKind3.Event = 23;
  CompletionItemKind3.Operator = 24;
  CompletionItemKind3.TypeParameter = 25;
})(CompletionItemKind2 || (CompletionItemKind2 = {}));
var InsertTextFormat;
(function(InsertTextFormat2) {
  InsertTextFormat2.PlainText = 1;
  InsertTextFormat2.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
var CompletionItemTag2;
(function(CompletionItemTag3) {
  CompletionItemTag3.Deprecated = 1;
})(CompletionItemTag2 || (CompletionItemTag2 = {}));
var InsertReplaceEdit;
(function(InsertReplaceEdit2) {
  function create(newText, insert, replace) {
    return { newText, insert, replace };
  }
  InsertReplaceEdit2.create = create;
  function is(value) {
    const candidate = value;
    return candidate && Is.string(candidate.newText) && Range2.is(candidate.insert) && Range2.is(candidate.replace);
  }
  InsertReplaceEdit2.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
var InsertTextMode;
(function(InsertTextMode2) {
  InsertTextMode2.asIs = 1;
  InsertTextMode2.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
var CompletionItemLabelDetails;
(function(CompletionItemLabelDetails2) {
  function is(value) {
    const candidate = value;
    return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
  }
  CompletionItemLabelDetails2.is = is;
})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
var CompletionItem;
(function(CompletionItem2) {
  function create(label) {
    return { label };
  }
  CompletionItem2.create = create;
})(CompletionItem || (CompletionItem = {}));
var CompletionList;
(function(CompletionList2) {
  function create(items, isIncomplete) {
    return { items: items ? items : [], isIncomplete: !!isIncomplete };
  }
  CompletionList2.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function(MarkedString2) {
  function fromPlainText(plainText) {
    return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
  }
  MarkedString2.fromPlainText = fromPlainText;
  function is(value) {
    const candidate = value;
    return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
  }
  MarkedString2.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function(Hover2) {
  function is(value) {
    let candidate = value;
    return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range2.is(value.range));
  }
  Hover2.is = is;
})(Hover || (Hover = {}));
var ParameterInformation;
(function(ParameterInformation2) {
  function create(label, documentation) {
    return documentation ? { label, documentation } : { label };
  }
  ParameterInformation2.create = create;
})(ParameterInformation || (ParameterInformation = {}));
var SignatureInformation;
(function(SignatureInformation2) {
  function create(label, documentation, ...parameters) {
    let result = { label };
    if (Is.defined(documentation)) {
      result.documentation = documentation;
    }
    if (Is.defined(parameters)) {
      result.parameters = parameters;
    } else {
      result.parameters = [];
    }
    return result;
  }
  SignatureInformation2.create = create;
})(SignatureInformation || (SignatureInformation = {}));
var DocumentHighlightKind3;
(function(DocumentHighlightKind4) {
  DocumentHighlightKind4.Text = 1;
  DocumentHighlightKind4.Read = 2;
  DocumentHighlightKind4.Write = 3;
})(DocumentHighlightKind3 || (DocumentHighlightKind3 = {}));
var DocumentHighlight;
(function(DocumentHighlight2) {
  function create(range, kind) {
    let result = { range };
    if (Is.number(kind)) {
      result.kind = kind;
    }
    return result;
  }
  DocumentHighlight2.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
var SymbolKind2;
(function(SymbolKind3) {
  SymbolKind3.File = 1;
  SymbolKind3.Module = 2;
  SymbolKind3.Namespace = 3;
  SymbolKind3.Package = 4;
  SymbolKind3.Class = 5;
  SymbolKind3.Method = 6;
  SymbolKind3.Property = 7;
  SymbolKind3.Field = 8;
  SymbolKind3.Constructor = 9;
  SymbolKind3.Enum = 10;
  SymbolKind3.Interface = 11;
  SymbolKind3.Function = 12;
  SymbolKind3.Variable = 13;
  SymbolKind3.Constant = 14;
  SymbolKind3.String = 15;
  SymbolKind3.Number = 16;
  SymbolKind3.Boolean = 17;
  SymbolKind3.Array = 18;
  SymbolKind3.Object = 19;
  SymbolKind3.Key = 20;
  SymbolKind3.Null = 21;
  SymbolKind3.EnumMember = 22;
  SymbolKind3.Struct = 23;
  SymbolKind3.Event = 24;
  SymbolKind3.Operator = 25;
  SymbolKind3.TypeParameter = 26;
})(SymbolKind2 || (SymbolKind2 = {}));
var SymbolTag2;
(function(SymbolTag3) {
  SymbolTag3.Deprecated = 1;
})(SymbolTag2 || (SymbolTag2 = {}));
var SymbolInformation;
(function(SymbolInformation2) {
  function create(name, kind, range, uri, containerName) {
    let result = {
      name,
      kind,
      location: { uri, range }
    };
    if (containerName) {
      result.containerName = containerName;
    }
    return result;
  }
  SymbolInformation2.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var WorkspaceSymbol;
(function(WorkspaceSymbol2) {
  function create(name, kind, uri, range) {
    return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
  }
  WorkspaceSymbol2.create = create;
})(WorkspaceSymbol || (WorkspaceSymbol = {}));
var DocumentSymbol;
(function(DocumentSymbol2) {
  function create(name, detail, kind, range, selectionRange, children) {
    let result = {
      name,
      detail,
      kind,
      range,
      selectionRange
    };
    if (children !== void 0) {
      result.children = children;
    }
    return result;
  }
  DocumentSymbol2.create = create;
  function is(value) {
    let candidate = value;
    return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range2.is(candidate.range) && Range2.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
  }
  DocumentSymbol2.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
var CodeActionKind;
(function(CodeActionKind2) {
  CodeActionKind2.Empty = "";
  CodeActionKind2.QuickFix = "quickfix";
  CodeActionKind2.Refactor = "refactor";
  CodeActionKind2.RefactorExtract = "refactor.extract";
  CodeActionKind2.RefactorInline = "refactor.inline";
  CodeActionKind2.RefactorRewrite = "refactor.rewrite";
  CodeActionKind2.Source = "source";
  CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
  CodeActionKind2.SourceFixAll = "source.fixAll";
})(CodeActionKind || (CodeActionKind = {}));
var CodeActionTriggerKind;
(function(CodeActionTriggerKind2) {
  CodeActionTriggerKind2.Invoked = 1;
  CodeActionTriggerKind2.Automatic = 2;
})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
var CodeActionContext;
(function(CodeActionContext2) {
  function create(diagnostics, only, triggerKind) {
    let result = { diagnostics };
    if (only !== void 0 && only !== null) {
      result.only = only;
    }
    if (triggerKind !== void 0 && triggerKind !== null) {
      result.triggerKind = triggerKind;
    }
    return result;
  }
  CodeActionContext2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
  }
  CodeActionContext2.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function(CodeAction2) {
  function create(title, kindOrCommandOrEdit, kind) {
    let result = { title };
    let checkKind = true;
    if (typeof kindOrCommandOrEdit === "string") {
      checkKind = false;
      result.kind = kindOrCommandOrEdit;
    } else if (Command2.is(kindOrCommandOrEdit)) {
      result.command = kindOrCommandOrEdit;
    } else {
      result.edit = kindOrCommandOrEdit;
    }
    if (checkKind && kind !== void 0) {
      result.kind = kind;
    }
    return result;
  }
  CodeAction2.create = create;
  function is(value) {
    let candidate = value;
    return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command2.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
  }
  CodeAction2.is = is;
})(CodeAction || (CodeAction = {}));
var CodeLens;
(function(CodeLens2) {
  function create(range, data) {
    let result = { range };
    if (Is.defined(data)) {
      result.data = data;
    }
    return result;
  }
  CodeLens2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Range2.is(candidate.range) && (Is.undefined(candidate.command) || Command2.is(candidate.command));
  }
  CodeLens2.is = is;
})(CodeLens || (CodeLens = {}));
var FormattingOptions;
(function(FormattingOptions2) {
  function create(tabSize, insertSpaces) {
    return { tabSize, insertSpaces };
  }
  FormattingOptions2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
  }
  FormattingOptions2.is = is;
})(FormattingOptions || (FormattingOptions = {}));
var DocumentLink;
(function(DocumentLink2) {
  function create(range, target, data) {
    return { range, target, data };
  }
  DocumentLink2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Range2.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
  }
  DocumentLink2.is = is;
})(DocumentLink || (DocumentLink = {}));
var SelectionRange;
(function(SelectionRange2) {
  function create(range, parent) {
    return { range, parent };
  }
  SelectionRange2.create = create;
  function is(value) {
    let candidate = value;
    return Is.objectLiteral(candidate) && Range2.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
  }
  SelectionRange2.is = is;
})(SelectionRange || (SelectionRange = {}));
var SemanticTokenTypes;
(function(SemanticTokenTypes2) {
  SemanticTokenTypes2["namespace"] = "namespace";
  SemanticTokenTypes2["type"] = "type";
  SemanticTokenTypes2["class"] = "class";
  SemanticTokenTypes2["enum"] = "enum";
  SemanticTokenTypes2["interface"] = "interface";
  SemanticTokenTypes2["struct"] = "struct";
  SemanticTokenTypes2["typeParameter"] = "typeParameter";
  SemanticTokenTypes2["parameter"] = "parameter";
  SemanticTokenTypes2["variable"] = "variable";
  SemanticTokenTypes2["property"] = "property";
  SemanticTokenTypes2["enumMember"] = "enumMember";
  SemanticTokenTypes2["event"] = "event";
  SemanticTokenTypes2["function"] = "function";
  SemanticTokenTypes2["method"] = "method";
  SemanticTokenTypes2["macro"] = "macro";
  SemanticTokenTypes2["keyword"] = "keyword";
  SemanticTokenTypes2["modifier"] = "modifier";
  SemanticTokenTypes2["comment"] = "comment";
  SemanticTokenTypes2["string"] = "string";
  SemanticTokenTypes2["number"] = "number";
  SemanticTokenTypes2["regexp"] = "regexp";
  SemanticTokenTypes2["operator"] = "operator";
  SemanticTokenTypes2["decorator"] = "decorator";
})(SemanticTokenTypes || (SemanticTokenTypes = {}));
var SemanticTokenModifiers;
(function(SemanticTokenModifiers2) {
  SemanticTokenModifiers2["declaration"] = "declaration";
  SemanticTokenModifiers2["definition"] = "definition";
  SemanticTokenModifiers2["readonly"] = "readonly";
  SemanticTokenModifiers2["static"] = "static";
  SemanticTokenModifiers2["deprecated"] = "deprecated";
  SemanticTokenModifiers2["abstract"] = "abstract";
  SemanticTokenModifiers2["async"] = "async";
  SemanticTokenModifiers2["modification"] = "modification";
  SemanticTokenModifiers2["documentation"] = "documentation";
  SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
var SemanticTokens;
(function(SemanticTokens2) {
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
  }
  SemanticTokens2.is = is;
})(SemanticTokens || (SemanticTokens = {}));
var InlineValueText;
(function(InlineValueText2) {
  function create(range, text) {
    return { range, text };
  }
  InlineValueText2.create = create;
  function is(value) {
    const candidate = value;
    return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && Is.string(candidate.text);
  }
  InlineValueText2.is = is;
})(InlineValueText || (InlineValueText = {}));
var InlineValueVariableLookup;
(function(InlineValueVariableLookup2) {
  function create(range, variableName, caseSensitiveLookup) {
    return { range, variableName, caseSensitiveLookup };
  }
  InlineValueVariableLookup2.create = create;
  function is(value) {
    const candidate = value;
    return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
  }
  InlineValueVariableLookup2.is = is;
})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
var InlineValueEvaluatableExpression;
(function(InlineValueEvaluatableExpression2) {
  function create(range, expression) {
    return { range, expression };
  }
  InlineValueEvaluatableExpression2.create = create;
  function is(value) {
    const candidate = value;
    return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
  }
  InlineValueEvaluatableExpression2.is = is;
})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
var InlineValueContext;
(function(InlineValueContext2) {
  function create(frameId, stoppedLocation) {
    return { frameId, stoppedLocation };
  }
  InlineValueContext2.create = create;
  function is(value) {
    const candidate = value;
    return Is.defined(candidate) && Range2.is(value.stoppedLocation);
  }
  InlineValueContext2.is = is;
})(InlineValueContext || (InlineValueContext = {}));
var InlayHintKind3;
(function(InlayHintKind4) {
  InlayHintKind4.Type = 1;
  InlayHintKind4.Parameter = 2;
  function is(value) {
    return value === 1 || value === 2;
  }
  InlayHintKind4.is = is;
})(InlayHintKind3 || (InlayHintKind3 = {}));
var InlayHintLabelPart;
(function(InlayHintLabelPart2) {
  function create(value) {
    return { value };
  }
  InlayHintLabelPart2.create = create;
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command2.is(candidate.command));
  }
  InlayHintLabelPart2.is = is;
})(InlayHintLabelPart || (InlayHintLabelPart = {}));
var InlayHint;
(function(InlayHint2) {
  function create(position, label, kind) {
    const result = { position, label };
    if (kind !== void 0) {
      result.kind = kind;
    }
    return result;
  }
  InlayHint2.create = create;
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && Position2.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind3.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
  }
  InlayHint2.is = is;
})(InlayHint || (InlayHint = {}));
var StringValue;
(function(StringValue2) {
  function createSnippet(value) {
    return { kind: "snippet", value };
  }
  StringValue2.createSnippet = createSnippet;
})(StringValue || (StringValue = {}));
var InlineCompletionItem;
(function(InlineCompletionItem2) {
  function create(insertText, filterText, range, command) {
    return { insertText, filterText, range, command };
  }
  InlineCompletionItem2.create = create;
})(InlineCompletionItem || (InlineCompletionItem = {}));
var InlineCompletionList;
(function(InlineCompletionList2) {
  function create(items) {
    return { items };
  }
  InlineCompletionList2.create = create;
})(InlineCompletionList || (InlineCompletionList = {}));
var InlineCompletionTriggerKind3;
(function(InlineCompletionTriggerKind4) {
  InlineCompletionTriggerKind4.Invoked = 0;
  InlineCompletionTriggerKind4.Automatic = 1;
})(InlineCompletionTriggerKind3 || (InlineCompletionTriggerKind3 = {}));
var SelectedCompletionInfo;
(function(SelectedCompletionInfo2) {
  function create(range, text) {
    return { range, text };
  }
  SelectedCompletionInfo2.create = create;
})(SelectedCompletionInfo || (SelectedCompletionInfo = {}));
var InlineCompletionContext;
(function(InlineCompletionContext2) {
  function create(triggerKind, selectedCompletionInfo) {
    return { triggerKind, selectedCompletionInfo };
  }
  InlineCompletionContext2.create = create;
})(InlineCompletionContext || (InlineCompletionContext = {}));
var WorkspaceFolder;
(function(WorkspaceFolder2) {
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && URI3.is(candidate.uri) && Is.string(candidate.name);
  }
  WorkspaceFolder2.is = is;
})(WorkspaceFolder || (WorkspaceFolder = {}));
var TextDocument2;
(function(TextDocument3) {
  function create(uri, languageId, version, content) {
    return new FullTextDocument2(uri, languageId, version, content);
  }
  TextDocument3.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
  }
  TextDocument3.is = is;
  function applyEdits(document2, edits) {
    let text = document2.getText();
    let sortedEdits = mergeSort2(edits, (a2, b) => {
      let diff = a2.range.start.line - b.range.start.line;
      if (diff === 0) {
        return a2.range.start.character - b.range.start.character;
      }
      return diff;
    });
    let lastModifiedOffset = text.length;
    for (let i = sortedEdits.length - 1; i >= 0; i--) {
      let e = sortedEdits[i];
      let startOffset = document2.offsetAt(e.range.start);
      let endOffset = document2.offsetAt(e.range.end);
      if (endOffset <= lastModifiedOffset) {
        text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
      } else {
        throw new Error("Overlapping edit");
      }
      lastModifiedOffset = startOffset;
    }
    return text;
  }
  TextDocument3.applyEdits = applyEdits;
  function mergeSort2(data, compare2) {
    if (data.length <= 1) {
      return data;
    }
    const p = data.length / 2 | 0;
    const left = data.slice(0, p);
    const right = data.slice(p);
    mergeSort2(left, compare2);
    mergeSort2(right, compare2);
    let leftIdx = 0;
    let rightIdx = 0;
    let i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
      let ret = compare2(left[leftIdx], right[rightIdx]);
      if (ret <= 0) {
        data[i++] = left[leftIdx++];
      } else {
        data[i++] = right[rightIdx++];
      }
    }
    while (leftIdx < left.length) {
      data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
      data[i++] = right[rightIdx++];
    }
    return data;
  }
})(TextDocument2 || (TextDocument2 = {}));
var FullTextDocument2 = class {
  constructor(uri, languageId, version, content) {
    this._uri = uri;
    this._languageId = languageId;
    this._version = version;
    this._content = content;
    this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(range) {
    if (range) {
      let start = this.offsetAt(range.start);
      let end = this.offsetAt(range.end);
      return this._content.substring(start, end);
    }
    return this._content;
  }
  update(event, version) {
    this._content = event.text;
    this._version = version;
    this._lineOffsets = void 0;
  }
  getLineOffsets() {
    if (this._lineOffsets === void 0) {
      let lineOffsets = [];
      let text = this._content;
      let isLineStart = true;
      for (let i = 0; i < text.length; i++) {
        if (isLineStart) {
          lineOffsets.push(i);
          isLineStart = false;
        }
        let ch = text.charAt(i);
        isLineStart = ch === "\r" || ch === "\n";
        if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
          i++;
        }
      }
      if (isLineStart && text.length > 0) {
        lineOffsets.push(text.length);
      }
      this._lineOffsets = lineOffsets;
    }
    return this._lineOffsets;
  }
  positionAt(offset) {
    offset = Math.max(Math.min(offset, this._content.length), 0);
    let lineOffsets = this.getLineOffsets();
    let low = 0, high = lineOffsets.length;
    if (high === 0) {
      return Position2.create(0, offset);
    }
    while (low < high) {
      let mid = Math.floor((low + high) / 2);
      if (lineOffsets[mid] > offset) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    let line = low - 1;
    return Position2.create(line, offset - lineOffsets[line]);
  }
  offsetAt(position) {
    let lineOffsets = this.getLineOffsets();
    if (position.line >= lineOffsets.length) {
      return this._content.length;
    } else if (position.line < 0) {
      return 0;
    }
    let lineOffset = lineOffsets[position.line];
    let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
};
var Is;
(function(Is2) {
  const toString = Object.prototype.toString;
  function defined(value) {
    return typeof value !== "undefined";
  }
  Is2.defined = defined;
  function undefined2(value) {
    return typeof value === "undefined";
  }
  Is2.undefined = undefined2;
  function boolean(value) {
    return value === true || value === false;
  }
  Is2.boolean = boolean;
  function string2(value) {
    return toString.call(value) === "[object String]";
  }
  Is2.string = string2;
  function number(value) {
    return toString.call(value) === "[object Number]";
  }
  Is2.number = number;
  function numberRange(value, min, max) {
    return toString.call(value) === "[object Number]" && min <= value && value <= max;
  }
  Is2.numberRange = numberRange;
  function integer2(value) {
    return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
  }
  Is2.integer = integer2;
  function uinteger2(value) {
    return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
  }
  Is2.uinteger = uinteger2;
  function func(value) {
    return toString.call(value) === "[object Function]";
  }
  Is2.func = func;
  function objectLiteral(value) {
    return value !== null && typeof value === "object";
  }
  Is2.objectLiteral = objectLiteral;
  function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
  }
  Is2.typedArray = typedArray;
})(Is || (Is = {}));

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/identity.js
var ALIAS = /* @__PURE__ */ Symbol.for("yaml.alias");
var DOC = /* @__PURE__ */ Symbol.for("yaml.document");
var MAP = /* @__PURE__ */ Symbol.for("yaml.map");
var PAIR = /* @__PURE__ */ Symbol.for("yaml.pair");
var SCALAR = /* @__PURE__ */ Symbol.for("yaml.scalar");
var SEQ = /* @__PURE__ */ Symbol.for("yaml.seq");
var NODE_TYPE = /* @__PURE__ */ Symbol.for("yaml.node.type");
var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/visit.js
var BREAK = /* @__PURE__ */ Symbol("break visit");
var SKIP = /* @__PURE__ */ Symbol("skip children");
var REMOVE = /* @__PURE__ */ Symbol("remove node");
function visit2(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
visit2.BREAK = BREAK;
visit2.SKIP = SKIP;
visit2.REMOVE = REMOVE;
function visit_(key, node, visitor, path5) {
  const ctrl = callVisitor(key, node, visitor, path5);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path5, ctrl);
    return visit_(key, ctrl, visitor, path5);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path5 = Object.freeze(path5.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = visit_(i, node.items[i], visitor, path5);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path5 = Object.freeze(path5.concat(node));
      const ck = visit_("key", node.key, visitor, path5);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path5);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    await visitAsync_(null, node, visitor_, Object.freeze([]));
}
visitAsync.BREAK = BREAK;
visitAsync.SKIP = SKIP;
visitAsync.REMOVE = REMOVE;
async function visitAsync_(key, node, visitor, path5) {
  const ctrl = await callVisitor(key, node, visitor, path5);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path5, ctrl);
    return visitAsync_(key, ctrl, visitor, path5);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path5 = Object.freeze(path5.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = await visitAsync_(i, node.items[i], visitor, path5);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path5 = Object.freeze(path5.concat(node));
      const ck = await visitAsync_("key", node.key, visitor, path5);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = await visitAsync_("value", node.value, visitor, path5);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path5) {
  if (typeof visitor === "function")
    return visitor(key, node, path5);
  if (isMap(node))
    return visitor.Map?.(key, node, path5);
  if (isSeq(node))
    return visitor.Seq?.(key, node, path5);
  if (isPair(node))
    return visitor.Pair?.(key, node, path5);
  if (isScalar(node))
    return visitor.Scalar?.(key, node, path5);
  if (isAlias(node))
    return visitor.Alias?.(key, node, path5);
  return void 0;
}
function replaceNode(key, path5, node) {
  const parent = path5[path5.length - 1];
  if (isCollection(parent)) {
    parent.items[key] = node;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node;
    else
      parent.value = node;
  } else if (isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/doc/directives.js
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
var Directives = class _Directives {
  constructor(yaml, tags) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, _Directives.defaultTags, tags);
  }
  clone() {
    const copy = new _Directives(this.yaml, this.tags);
    copy.docStart = this.docStart;
    return copy;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new _Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: _Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, _Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, _Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version] = parts;
        if (version === "1.1" || version === "1.2") {
          this.yaml.version = version;
          return true;
        } else {
          const isValid = /^\d+\.\d+$/.test(version);
          onError(6, `Unsupported YAML version ${version}`, isValid);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix) {
      try {
        return prefix + decodeURIComponent(suffix);
      } catch (error) {
        onError(String(error));
        return null;
      }
    }
    if (handle === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix))
        return handle + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags = {};
      visit2(doc.contents, (_key, node) => {
        if (isNode(node) && node.tag)
          tags[node.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit2(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name = `${prefix}${i}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/toJS.js
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !ctx?.keep)
    return Number(value);
  return value;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/Node.js
var NodeBase = class {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** A plain JavaScript representation of this node. */
  toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    if (!isDocument(doc))
      throw new TypeError("A document argument is required");
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc,
      keep: true,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this, "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/Alias.js
var Alias = class extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc) {
    let found = void 0;
    visit2(doc, {
      Node: (_key, node) => {
        if (node === this)
          return visit2.BREAK;
        if (node.anchor === this.source)
          found = node;
      }
    });
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source = this.resolve(doc);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    let data = anchors.get(source);
    if (!data) {
      toJS(source, null, ctx);
      data = anchors.get(source);
    }
    if (!data || data.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount(doc, source, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
};
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count)
        count = c;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
var Scalar = class extends NodeBase {
  constructor(value) {
    super(SCALAR);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/doc/createNode.js
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  if (tagName) {
    const match = tags.filter((t) => t.tag === tagName);
    const tagObj = match.find((t) => !t.format) ?? match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => t.identify?.(value) && !t.format);
}
function createNode(value, tagName, ctx) {
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      if (!ref.anchor)
        ref.anchor = onAnchor(value);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName?.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  else if (!tagObj.default)
    node.tag = tagObj.tag;
  if (ref)
    ref.node = node;
  return node;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path5, value) {
  let v = value;
  for (let i = path5.length - 1; i >= 0; --i) {
    const k = path5[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a2 = [];
      a2[k] = v;
      v = a2;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath = (path5) => path5 == null || typeof path5 === "object" && !!path5[Symbol.iterator]().next().done;
var Collection = class extends NodeBase {
  constructor(type, schema4) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema4,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema4) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema4)
      copy.schema = schema4;
    copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema4) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path5, value) {
    if (isEmptyPath(path5))
      this.add(value);
    else {
      const [key, ...rest] = path5;
      const node = this.get(key, true);
      if (isCollection(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path5) {
    const [key, ...rest] = path5;
    if (rest.length === 0)
      return this.delete(key);
    const node = this.get(key, true);
    if (isCollection(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path5, keepScalar) {
    const [key, ...rest] = path5;
    const node = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node) ? node.value : node;
    else
      return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n = node.value;
      return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path5) {
    const [key, ...rest] = path5;
    if (rest.length === 0)
      return this.has(key);
    const node = this.get(key, true);
    return isCollection(node) ? node.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path5, value) {
    const [key, ...rest] = path5;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (isCollection(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/stringify/stringifyComment.js
var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/stringify/foldFlowLines.js
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  if (lineWidth < minContentWidth)
    minContentWidth = 0;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i, indent.length);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i, indent.length);
      end = i + indent.length + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i, indent) {
  let end = i;
  let start = i + 1;
  let ch = text[start];
  while (ch === " " || ch === "	") {
    if (i < start + indent) {
      ch = text[++i];
    } else {
      do {
        ch = text[++i];
      } while (ch && ch !== "\n");
      end = i;
      start = i + 1;
      ch = text[start];
    }
  }
  return end;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/stringify/stringifyString.js
var getFoldOptions = (ctx, isBlock2) => ({
  indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str += json.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str += json.slice(start, i);
            const code = json.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json.slice(start, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
var blockEndNewlines;
try {
  blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
} catch {
  blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (!literal) {
    const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
    let literalFallback = false;
    const foldOptions = getFoldOptions(ctx, true);
    if (blockQuote !== "folded" && type !== Scalar.BLOCK_FOLDED) {
      foldOptions.onOverflow = () => {
        literalFallback = true;
      };
    }
    const body = foldFlowLines(`${start}${foldedValue}${end}`, indent, FOLD_BLOCK, foldOptions);
    if (!literalFallback)
      return `>${header}
${indent}${body}`;
  }
  value = value.replace(/\n+/g, `$&${indent}`);
  return `|${header}
${indent}${start}${value}${end}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || compat?.some(test))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  if (item.tag) {
    const match = tags.filter((t) => t.tag === item.tag);
    if (match.length > 0)
      return match.find((t) => t.format === item.format) ?? match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    let match = tags.filter((t) => t.identify?.(obj));
    if (match.length > 1) {
      const testMatch = match.filter((t) => t.test);
      if (testMatch.length > 0)
        match = testMatch;
    }
    tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name = obj?.constructor?.name ?? typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify(item, ctx, onComment, onChompKeep) {
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if (ctx.resolvedAliases?.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key) || !isNode(key) && typeof key === "object") {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (keyComment || vsb || vcb) {
    ws = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws === "\n")
        ws = "\n\n";
    } else {
      ws += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws = "";
  }
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/log.js
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    console.warn(warning);
  }
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/merge.js
var MERGE_KEY = "<<";
var merge = {
  identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {
    addToJSMap: addMergeToJSMap
  }),
  stringify: () => MERGE_KEY
};
var isMergeKey = (ctx, key) => (merge.identify(key) || isScalar(key) && (!key.type || key.type === Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default);
function addMergeToJSMap(ctx, map2, value) {
  value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (isSeq(value))
    for (const it of value.items)
      mergeValue(ctx, map2, it);
  else if (Array.isArray(value))
    for (const it of value)
      mergeValue(ctx, map2, it);
  else
    mergeValue(ctx, map2, value);
}
function mergeValue(ctx, map2, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
function addPairToJSMap(ctx, map2, { key, value }) {
  if (isNode(key) && key.addToJSMap)
    key.addToJSMap(ctx, map2, value);
  else if (isMergeKey(ctx, key))
    addMergeToJSMap(ctx, map2, value);
  else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && ctx?.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key, value, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value, void 0, ctx);
  return new Pair(k, v);
}
var Pair = class _Pair {
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema4) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema4);
    if (isNode(value))
      value = value.clone(schema4);
    return new _Pair(key, value);
  }
  toJSON(_, ctx) {
    const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return ctx?.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection(collection, ctx, options) {
  const flow = ctx.inFlow ?? collection.flow;
  const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify4(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik?.comment) {
        comment = ik.comment;
      }
    }
    if (comment)
      reqNewline = true;
    let str = stringify(item, itemCtx, () => comment = null);
    if (i < items.length - 1)
      str += ",";
    if (comment)
      str += lineComment(str, itemIndent, commentString(comment));
    if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
      reqNewline = true;
    lines.push(str);
    linesAtValue = lines.length;
  }
  const { start, end } = flowChars;
  if (lines.length === 0) {
    return start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
    }
    if (reqNewline) {
      let str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      return `${str}
${indent}${end}`;
    } else {
      return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
  }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key) {
  const k = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
var YAMLMap = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(schema4) {
    super(MAP, schema4);
    this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(schema4, obj, ctx) {
    const { keepUndefined, replacer } = ctx;
    const map2 = new this(schema4);
    const add = (key, value) => {
      if (typeof replacer === "function")
        value = replacer.call(obj, key, value);
      else if (Array.isArray(replacer) && !replacer.includes(key))
        return;
      if (value !== void 0 || keepUndefined)
        map2.items.push(createPair(key, value, ctx));
    };
    if (obj instanceof Map) {
      for (const [key, value] of obj)
        add(key, value);
    } else if (obj && typeof obj === "object") {
      for (const key of Object.keys(obj))
        add(key, obj[key]);
    }
    if (typeof schema4.sortMapEntries === "function") {
      map2.items.sort(schema4.sortMapEntries);
    }
    return map2;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair?.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = this.schema?.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const it = findPair(this.items, key);
    const node = it?.value;
    return (!keepScalar && isScalar(node) ? node.value : node) ?? void 0;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_, ctx, Type) {
    const map2 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    if (ctx?.onCreate)
      ctx.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx, map2, item);
    return map2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/common/map.js
var map = {
  collection: "map",
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode: (schema4, obj, ctx) => YAMLMap.from(schema4, obj, ctx)
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/nodes/YAMLSeq.js
var YAMLSeq = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(schema4) {
    super(SEQ, schema4);
    this.items = [];
  }
  add(value) {
    this.items.push(value);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar(it) ? it.value : it;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_, ctx) {
    const seq2 = [];
    if (ctx?.onCreate)
      ctx.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
  static from(schema4, obj, ctx) {
    const { replacer } = ctx;
    const seq2 = new this(schema4);
    if (obj && Symbol.iterator in Object(obj)) {
      let i = 0;
      for (let it of obj) {
        if (typeof replacer === "function") {
          const key = obj instanceof Set ? it : String(i++);
          it = replacer.call(obj, key, it);
        }
        seq2.items.push(createNode(it, void 0, ctx));
      }
    }
    return seq2;
  }
};
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/common/seq.js
var seq = {
  collection: "seq",
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  },
  createNode: (schema4, obj, ctx) => YAMLSeq.from(schema4, obj, ctx)
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/common/string.js
var string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/common/null.js
var nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber({ format: format3, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = JSON.stringify(value);
  if (!format3 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/core/int.js
var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intOct = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
  stringify: (node) => intStringify(node, 8, "0o")
};
var int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node) => intStringify(node, 16, "0x")
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/core/schema.js
var schema = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float
];

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON = ({ value }) => JSON.stringify(value);
var jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify2,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
var schema2 = [map, seq].concat(jsonScalars, jsonError);

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary = {
  identify: (value) => value instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src, onError) {
    if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i)
        buffer[i] = str.charCodeAt(i);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
    if (!value)
      return "";
    const buf = value;
    let str;
    if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type)
      type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n = Math.ceil(str.length / lineWidth);
      const lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
  }
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs(seq2, onError) {
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = pair.value ?? pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        }
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap = class _YAMLOMap extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = _YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_, ctx) {
    if (!ctx)
      return super.toJSON(_);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx?.onCreate)
      ctx.onCreate(map2);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map2.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key, value);
    }
    return map2;
  }
  static from(schema4, iterable, ctx) {
    const pairs2 = createPairs(schema4, iterable, ctx);
    const omap2 = new this();
    omap2.items = pairs2.items;
    return omap2;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode: (schema4, iterable, ctx) => YAMLOMap.from(schema4, iterable, ctx)
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
var falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f2 = str.substring(dot + 1).replace(/_/g, "");
      if (f2[f2.length - 1] === "0")
        node.minFractionDigits = f2.length;
    }
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
var intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve2(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intBin = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
  stringify: (node) => intStringify2(node, 2, "0b")
};
var intOct2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
  stringify: (node) => intStringify2(node, 8, "0")
};
var int2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
  stringify: (node) => intStringify2(node, 16, "0x")
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet = class _YAMLSet extends YAMLMap {
  constructor(schema4) {
    super(schema4);
    this.tag = _YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
  static from(schema4, iterable, ctx) {
    const { replacer } = ctx;
    const set2 = new this(schema4);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set2.items.push(createPair(value, null, ctx));
      }
    return set2;
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  createNode: (schema4, iterable, ctx) => YAMLSet.from(schema4, iterable, ctx),
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  }
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n) => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n) => n;
  if (typeof value === "bigint")
    num = (n) => BigInt(n);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
var intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30)
        d *= 60;
      date -= 6e4 * d;
    }
    return new Date(date);
  },
  stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3 = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct2,
  int2,
  intHex2,
  floatNaN2,
  floatExp2,
  float2,
  binary,
  merge,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/tags.js
var schemas = /* @__PURE__ */ new Map([
  ["core", schema],
  ["failsafe", [map, seq, string]],
  ["json", schema2],
  ["yaml11", schema3],
  ["yaml-1.1", schema3]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float,
  floatExp,
  floatNaN,
  floatTime,
  int,
  intHex,
  intOct,
  intTime,
  map,
  merge,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:merge": merge,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName, addMergeTag) {
  const schemaTags = schemas.get(schemaName);
  if (schemaTags && !customTags) {
    return addMergeTag && !schemaTags.includes(merge) ? schemaTags.concat(merge) : schemaTags.slice();
  }
  let tags = schemaTags;
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  if (addMergeTag)
    tags = tags.concat(merge);
  return tags.reduce((tags2, tag) => {
    const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
    if (!tagObj) {
      const tagName = JSON.stringify(tag);
      const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
    }
    if (!tags2.includes(tagObj))
      tags2.push(tagObj);
    return tags2;
  }, []);
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey = (a2, b) => a2.key < b.key ? -1 : a2.key > b.key ? 1 : 0;
var Schema = class _Schema {
  constructor({ compat, customTags, merge: merge2, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.name = typeof schema4 === "string" && schema4 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name, merge2);
    this.toStringOptions = toStringDefaults ?? null;
    Object.defineProperty(this, MAP, { value: map });
    Object.defineProperty(this, SCALAR, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument(doc, options) {
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify(doc.contents, ctx));
  }
  if (doc.directives?.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/doc/Document.js
var Document = class _Document {
  constructor(value, replacer, options) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      stringKeys: false,
      uniqueKeys: true,
      version: "1.2"
    }, options);
    this.options = opt;
    let { version } = opt;
    if (options?._directives) {
      this.directives = options._directives.atDocument();
      if (this.directives.yaml.explicit)
        version = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version });
    this.setSchema(version, options);
    this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy = Object.create(_Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** Adds a value to the document. */
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  /** Adds a value to the document. */
  addIn(path5, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path5, value);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchorNames(this);
      node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer, options) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      anchorPrefix || "a"
    );
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects ?? true,
      keepUndefined: keepUndefined ?? false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag, ctx);
    if (flow && isCollection(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key, value, options = {}) {
    const k = this.createNode(key, null, options);
    const v = this.createNode(value, null, options);
    return new Pair(k, v);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path5) {
    if (isEmptyPath(path5)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path5) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path5, keepScalar) {
    if (isEmptyPath(path5))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path5, keepScalar) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key) {
    return isCollection(this.contents) ? this.contents.has(key) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path5) {
    if (isEmptyPath(path5))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path5) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path5, value) {
    if (isEmptyPath(path5)) {
      this.contents = value;
    } else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path5), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path5, value);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version, options = {}) {
    if (typeof version === "number")
      version = String(version);
    let opt;
    switch (version) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version;
        else
          this.directives = new Directives({ version });
        opt = { resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options.schema instanceof Object)
      this.schema = options.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this.contents, jsonArg ?? "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  /** A YAML representation of the document. */
  toString(options = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options);
  }
};
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/errors.js
var YAMLError = class extends Error {
  constructor(name, pos, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
};
var YAMLParseError = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLParseError", pos, code, message);
  }
};
var YAMLWarning = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLWarning", pos, code, message);
  }
};
var prettifyError = (src, lc) => (error) => {
  if (error.pos[0] === -1)
    return;
  error.linePos = error.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error.linePos[0];
  error.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end = error.linePos[1];
    if (end && end.line === line && end.col > col) {
      count = Math.max(1, Math.min(end.col - col, 80 - ci));
    }
    const pointer = " ".repeat(ci) + "^".repeat(count);
    error.message += `:

${lineStr}
${pointer}
`;
  }
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let tab = null;
  let anchor = null;
  let tag = null;
  let newlineAfterProp = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    if (tab) {
      if (atNewline && token.type !== "comment" && token.type !== "newline") {
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      }
      tab = null;
    }
    switch (token.type) {
      case "space":
        if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) {
          tab = token;
        }
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else if (!found || indicator !== "seq-item-ind")
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          newlineAfterProp = token;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
        found = token;
        atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      // else fallthrough
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  }
  if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
    onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    anchor,
    tag,
    newlineAfterProp,
    end,
    start: start ?? end
  };
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck(indent, fc, onError) {
  if (fc?.type === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a2, b) => a2 === b || isScalar(a2) && isScalar(b) && a2.value === b.value;
  return items.some((pair) => isEqual(pair.key, search));
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/resolve-block-map.js
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag) {
  const NodeClass = tag?.nodeClass ?? YAMLMap;
  const map2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start, key, sep: sep2, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key ?? sep2?.[0],
      offset,
      onError,
      parentIndent: bm.indent,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep2) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.newlineAfterProp || containsNewline(key)) {
        onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (keyProps.found?.indent !== bm.indent) {
      onError(offset, "BAD_INDENT", startColMsg);
    }
    ctx.atKey = true;
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    ctx.atKey = false;
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep2 ?? [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      parentIndent: bm.indent,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if (value?.type === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep2, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map2.range = [bm.offset, offset, commentEnd ?? offset];
  return map2;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError, tag) {
  const NodeClass = tag?.nodeClass ?? YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = bs.offset;
  let commentEnd = null;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      parentIndent: bs.indent,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset, commentEnd ?? offset];
  return seq2;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd(end, offset, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep2 = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep2 + cb;
          sep2 = "";
          break;
        }
        case "newline":
          if (comment)
            sep2 += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment, offset };
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag) {
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = tag?.nodeClass ?? (isMap2 ? YAMLMap : YAMLSeq);
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key, sep: sep2, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key ?? sep2?.[0],
      offset,
      onError,
      parentIndent: fc.indent,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep2 && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop: for (const st of start) {
          switch (st.type) {
            case "comma":
            case "space":
              break;
            case "comment":
              prevItemComment = st.source.substring(1);
              break loop;
            default:
              break loop;
          }
        }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = prev.value ?? prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep2 && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep2, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      ctx.atKey = true;
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      ctx.atKey = false;
      const valueProps = resolveProps(sep2 ?? [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep2)
            for (const st of sep2) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep2, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        const endRange = (valueNode ?? keyNode).range;
        map2.range = [keyNode.range[0], endRange[1], endRange[2]];
        coll.items.push(map2);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/compose-collection.js
function resolveCollection(CN2, ctx, token, onError, tagName, tag) {
  const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag) : resolveFlowCollection(CN2, ctx, token, onError, tag);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
function composeCollection(CN2, ctx, token, props, onError) {
  const tagToken = props.tag;
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (token.type === "block-seq") {
    const { anchor, newlineAfterProp: nl } = props;
    const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
    if (lastProp && (!nl || nl.offset < lastProp.offset)) {
      const message = "Missing newline after block sequence props";
      onError(lastProp, "MISSING_CHAR", message);
    }
  }
  const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq") {
    return resolveCollection(CN2, ctx, token, onError, tagName);
  }
  let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      if (kt) {
        onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
      } else {
        onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag);
  const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag?.format)
    node.format = tag.format;
  return node;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar(ctx, scalar, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines2(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      if (trimIndent === 0 && !ctx.atRoot) {
        const message = "Block scalar values in collections must be indented";
        onError(offset, "BAD_INDENT", message);
      }
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent)
      chompStart = i + 1;
  }
  let value = "";
  let sep2 = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep2 + indent.slice(trimIndent) + content;
      sep2 = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep2 === " ")
        sep2 = "\n";
      else if (!prevMoreIndented && sep2 === "\n")
        sep2 = "\n\n";
      value += sep2 + indent.slice(trimIndent) + content;
      sep2 = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep2 === "\n")
        value += "\n";
      else
        sep2 = "\n";
    } else {
      value += sep2 + content;
      sep2 = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error === -1)
        error = offset + i;
    }
  }
  if (error !== -1)
    onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      // fallthrough
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      /* istanbul ignore next should not happen */
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length };
}
function splitLines2(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m = first.match(/^( *)/);
  const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    /* istanbul ignore next should not happen */
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    /* istanbul ignore next should not happen */
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep2 = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep2 === "\n")
        res += sep2;
      else
        sep2 = "\n";
    } else {
      res += sep2 + match[1];
      sep2 = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep2 + (match?.[1] ?? "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === "\r" && source[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i);
      res += fold;
      i = offset;
    } else if (ch === "\\") {
      let next = source[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "\r" && source[i + 1] === "\n") {
        next = source[++i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i + 1, length, onError);
        i += length;
      } else {
        const raw = source.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source[i + 1];
      while (next === " " || next === "	")
        next = source[++i + 1];
      if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
        res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
var escapeCodes = {
  "0": "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: "\n",
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "\x85",
  // Unicode next line
  _: "\xA0",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset, length, onError) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(ctx, token, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  let tag;
  if (ctx.options.stringKeys && ctx.atKey) {
    tag = ctx.schema[SCALAR];
  } else if (tagName)
    tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
  else if (token.type === "scalar")
    tag = findScalarTagByTest(ctx, value, token, onError);
  else
    tag = ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag of schema4.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if (tag.test?.test(value))
      return tag;
  const kt = schema4.knownTags[tagName];
  if (kt && !kt.collection) {
    schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ atKey, directives, schema: schema4 }, value, token, onError) {
  const tag = schema4.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = schema4.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema4[SCALAR];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i];
      while (st?.type === "space") {
        offset += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/compose-node.js
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const atKey = ctx.atKey;
  const { spaceBefore, comment, anchor, tag } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, props, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message);
      node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (atKey && ctx.options.stringKeys && (!isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
    const msg = "With stringKeys, all keys must be strings";
    onError(tag ?? token, "NON_STRING_KEY", msg);
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    node.comment = comment;
    node.range[2] = end;
  }
  return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options);
  const doc = new Document(void 0, opts);
  const ctx = {
    atKey: false,
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value ?? end?.[0],
    offset,
    onError,
    parentIndent: 0,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset, contentEnd, re.offset];
  return doc;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset, source } = src;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (prelude[i + 1]?.[0] !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
var Composer = class {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code, message, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message));
      else
        this.errors.push(new YAMLParseError(pos, code, message));
    };
    this.directives = new Directives({ version: options.version || "1.2" });
    this.options = options;
  }
  decorate(doc, afterDoc) {
    const { comment, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
      } else if (afterEmptyLine || doc.directives.docStart || !dc) {
        doc.commentBefore = comment;
      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment}
${cb}` : comment;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment}
${cb}` : comment;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  /** Advance the composer by one CST token. */
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.docStart)
          this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error);
        else
          this.doc.errors.push(error);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ _directives: this.directives }, this.options);
      const doc = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/parse/cst.js
var cst_exports = {};
__export(cst_exports, {
  BOM: () => BOM,
  DOCUMENT: () => DOCUMENT,
  FLOW_END: () => FLOW_END,
  SCALAR: () => SCALAR2,
  createScalarToken: () => createScalarToken,
  isCollection: () => isCollection2,
  isScalar: () => isScalar2,
  prettyToken: () => prettyToken,
  resolveAsScalar: () => resolveAsScalar,
  setScalarValue: () => setScalarValue,
  stringify: () => stringify2,
  tokenType: () => tokenType,
  visit: () => visit3
});

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/parse/cst-scalar.js
function resolveAsScalar(token, strict = true, onError) {
  if (token) {
    const _onError = (pos, code, message) => {
      const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError)
        onError(offset, code, message);
      else
        throw new YAMLParseError([offset, offset + 1], code, message);
    };
    switch (token.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(token, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar({ options: { strict } }, token, _onError);
    }
  }
  return null;
}
function createScalarToken(value, context) {
  const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
  const source = stringifyString({ type, value }, {
    implicitKey,
    indent: indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = context.end ?? [
    { type: "newline", offset: -1, indent, source: "\n" }
  ];
  switch (source[0]) {
    case "|":
    case ">": {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, end))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      return { type: "block-scalar", offset, indent, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset, indent, source, end };
    case "'":
      return { type: "single-quoted-scalar", offset, indent, source, end };
    default:
      return { type: "scalar", offset, indent, source, end };
  }
}
function setScalarValue(token, value, context = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
  let indent = "indent" in token ? token.indent : null;
  if (afterKey && typeof indent === "number")
    indent += 2;
  if (!type)
    switch (token.type) {
      case "single-quoted-scalar":
        type = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type = "PLAIN";
    }
  const source = stringifyString({ type, value }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source[0]) {
    case "|":
    case ">":
      setBlockScalarValue(token, source);
      break;
    case '"':
      setFlowScalarValue(token, source, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(token, source, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(token, source, "scalar");
  }
}
function setBlockScalarValue(token, source) {
  const he = source.indexOf("\n");
  const head = source.substring(0, he);
  const body = source.substring(he + 1) + "\n";
  if (token.type === "block-scalar") {
    const header = token.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head;
    token.source = body;
  } else {
    const { offset } = token;
    const indent = "indent" in token ? token.indent : -1;
    const props = [
      { type: "block-scalar-header", offset, indent, source: head }
    ];
    if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
      props.push({ type: "newline", offset: -1, indent, source: "\n" });
    for (const key of Object.keys(token))
      if (key !== "type" && key !== "offset")
        delete token[key];
    Object.assign(token, { type: "block-scalar", indent, props, source: body });
  }
}
function addEndtoBlockProps(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
function setFlowScalarValue(token, source, type) {
  switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token.type = type;
      token.source = source;
      break;
    case "block-scalar": {
      const end = token.props.slice(1);
      let oa = source.length;
      if (token.props[0].type === "block-scalar-header")
        oa -= token.props[0].source.length;
      for (const tok of end)
        tok.offset += oa;
      delete token.props;
      Object.assign(token, { type, source, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset = token.offset + source.length;
      const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
      delete token.items;
      Object.assign(token, { type, source, end: [nl] });
      break;
    }
    default: {
      const indent = "indent" in token ? token.indent : -1;
      const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type, indent, source, end });
    }
  }
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/parse/cst-stringify.js
var stringify2 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
function stringifyToken(token) {
  switch (token.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token.props)
        res += stringifyToken(tok);
      return res + token.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token.items)
        res += stringifyItem(item);
      return res;
    }
    case "flow-collection": {
      let res = token.start.source;
      for (const item of token.items)
        res += stringifyItem(item);
      for (const st of token.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem(token);
      if (token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token.source;
      if ("end" in token && token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
  }
}
function stringifyItem({ start, key, sep: sep2, value }) {
  let res = "";
  for (const st of start)
    res += st.source;
  if (key)
    res += stringifyToken(key);
  if (sep2)
    for (const st of sep2)
      res += st.source;
  if (value)
    res += stringifyToken(value);
  return res;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/parse/cst-visit.js
var BREAK2 = /* @__PURE__ */ Symbol("break visit");
var SKIP2 = /* @__PURE__ */ Symbol("skip children");
var REMOVE2 = /* @__PURE__ */ Symbol("remove item");
function visit3(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit(Object.freeze([]), cst, visitor);
}
visit3.BREAK = BREAK2;
visit3.SKIP = SKIP2;
visit3.REMOVE = REMOVE2;
visit3.itemAtPath = (cst, path5) => {
  let item = cst;
  for (const [field, index] of path5) {
    const tok = item?.[field];
    if (tok && "items" in tok) {
      item = tok.items[index];
    } else
      return void 0;
  }
  return item;
};
visit3.parentCollection = (cst, path5) => {
  const parent = visit3.itemAtPath(cst, path5.slice(0, -1));
  const field = path5[path5.length - 1][0];
  const coll = parent?.[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit(path5, item, visitor) {
  let ctrl = visitor(item, path5);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit(Object.freeze(path5.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path5);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path5) : ctrl;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/parse/cst.js
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR2 = "";
var isCollection2 = (token) => !!token && "items" in token;
var isScalar2 = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
function prettyToken(token) {
  switch (token) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR2:
      return "<SCALAR>";
    default:
      return JSON.stringify(token);
  }
}
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits = new Set("0123456789ABCDEFabcdef");
var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
var flowIndicatorChars = new Set(",[]{}");
var invalidAnchorChars = new Set(" ,[]{}\n\r	");
var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
var Lexer = class {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(source, incomplete = false) {
    if (source) {
      if (typeof source !== "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = this.next ?? "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i + 1] === "\n";
    return false;
  }
  charAt(n) {
    return this.buffer[this.pos + n];
  }
  continueScalar(offset) {
    let ch = this.buffer[offset];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset];
      if (ch === "\r") {
        const next = this.buffer[indent + offset + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset, 3);
      if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
        return -1;
    }
    return offset;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n) {
    return this.pos + n <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n) {
    return this.buffer.substr(this.pos, n);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      let cs = line.indexOf("#");
      while (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	") {
          dirEnd = cs - 1;
          break;
        } else {
          cs = line.indexOf("#", cs + 1);
        }
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s = this.peek(3);
      if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return s === "---" ? "doc" : "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (line[n]) {
      case "#":
        yield* this.pushCount(line.length - n);
      // fallthrough
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n += yield* this.parseBlockScalarHeader();
        n += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n = 0;
    while (line[n] === ",") {
      n += yield* this.pushCount(1);
      n += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n += yield* this.pushIndicators();
    switch (line[n]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      // fallthrough
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n = 0;
        while (this.buffer[end - 1 - n] === "\\")
          n += 1;
        if (n % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
      switch (ch) {
        case " ":
          indent += 1;
          break;
        case "\n":
          nl = i2;
          indent = 0;
          break;
        case "\r": {
          const next = this.buffer[i2 + 1];
          if (!next && !this.atEnd)
            return this.setNext("block-scalar");
          if (next === "\n")
            break;
        }
        // fallthrough
        default:
          break loop;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else {
        this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      }
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    let i = nl + 1;
    ch = this.buffer[i];
    while (ch === " ")
      ch = this.buffer[++i];
    if (ch === "	") {
      while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
        ch = this.buffer[++i];
      nl = i - 1;
    } else if (!this.blockScalarKeep) {
      do {
        let i2 = nl - 1;
        let ch2 = this.buffer[i2];
        if (ch2 === "\r")
          ch2 = this.buffer[--i2];
        const lastChar = i2;
        while (ch2 === " ")
          ch2 = this.buffer[--i2];
        if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
          nl = i2;
        else
          break;
      } while (true);
    }
    yield SCALAR2;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ":") {
        const next = this.buffer[i + 1];
        if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
          break;
        end = i;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i += 1;
            ch = "\n";
            next = this.buffer[i + 1];
          } else
            end = i;
        }
        if (next === "#" || inFlow && flowIndicatorChars.has(next))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i + 1);
          if (cs === -1)
            break;
          i = Math.max(i, cs - 2);
        }
      } else {
        if (inFlow && flowIndicatorChars.has(ch))
          break;
        end = i;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR2;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n) {
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos += n;
      return n;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      // this is an error
      case "?":
      // this is an error outside flow collections
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.has(ch))
          ch = this.buffer[++i];
        else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === " " || allowTabs && ch === "	");
    const n = i - this.pos;
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos = i;
    }
    return n;
  }
  *pushUntil(test) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test(ch))
      ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter = class {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset) => this.lineStarts.push(offset);
    this.linePos = (offset) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset - start + 1 };
    };
  }
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/parse/parser.js
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return it.sep ?? it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    /* istanbul ignore next should not happen */
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop: while (--i >= 0) {
    switch (prev[i].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break loop;
    }
  }
  while (prev[++i]?.type === "space") {
  }
  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser = class {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n) {
    return this.stack[this.stack.length - n];
  }
  *pop(error) {
    const token = error ?? this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top ? top.indent : 0;
      } else if (token.type === "flow-collection" && top.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top.type) {
        case "document":
          top.value = token;
          break;
        case "block-scalar":
          top.props.push(token);
          break;
        case "block-map": {
          const it = top.items[top.items.length - 1];
          if (it.value) {
            top.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !it.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top.items[top.items.length - 1];
          if (it.value)
            top.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top.items[top.items.length - 1];
          if (!it || it.value)
            top.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        /* istanbul ignore next should not happen */
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last = token.items[token.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top.type === "document")
            top.end = last.start;
          else
            top.items.push({ start: last.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep2;
      if (scalar.end) {
        sep2 = scalar.end;
        sep2.push(this.sourceToken);
        delete scalar.end;
      } else
        sep2 = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep: sep2 }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      /* istanbul ignore next should not happen */
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    const it = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if (last?.type === "comment")
            end?.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          it.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it.value) {
          map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end = prev?.value?.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atMapIndent = !this.onKeyLine && this.indent === map2.indent;
      const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
      let start = [];
      if (atNextItem && it.sep && !it.value) {
        const nl = [];
        for (let i = 0; i < it.sep.length; ++i) {
          const st = it.sep[i];
          switch (st.type) {
            case "newline":
              nl.push(i);
              break;
            case "space":
              break;
            case "comment":
              if (st.indent > map2.indent)
                nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2)
          start = it.sep.splice(nl[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start });
            this.onKeyLine = true;
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it.sep && !it.explicitKey) {
            it.start.push(this.sourceToken);
            it.explicitKey = true;
          } else if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start, explicitKey: true });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken], explicitKey: true }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (it.explicitKey) {
            if (!it.sep) {
              if (includesToken(it.start, "newline")) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else {
                const start2 = getFirstKeyStartProps(it.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it.value) {
              map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
              const start2 = getFirstKeyStartProps(it.start);
              const key = it.key;
              const sep2 = it.sep;
              sep2.push(this.sourceToken);
              delete it.key;
              delete it.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key, sep: sep2 }]
              });
            } else if (start.length > 0) {
              it.sep = it.sep.concat(start, this.sourceToken);
            } else {
              it.sep.push(this.sourceToken);
            }
          } else {
            if (!it.sep) {
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            } else if (it.value || atNextItem) {
              map2.items.push({ start, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map2.items.push({ start, key: fs, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs);
          } else {
            Object.assign(it, { key: fs, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (bv.type === "block-seq") {
              if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                yield* this.pop({
                  type: "error",
                  offset: this.offset,
                  message: "Unexpected block-seq-ind on same line with key",
                  source: this.source
                });
                return;
              }
            } else if (atMapIndent) {
              map2.items.push({ start });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if (last?.type === "comment")
            end?.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end = prev?.value?.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while (top && top.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs, sep: [] });
          else if (it.sep)
            this.stack.push(fs);
          else
            Object.assign(it, { key: fs, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep2 = fc.end.splice(1, fc.end.length);
        sep2.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep: sep2 }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, explicitKey: true }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      // fallthrough
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};

// node_modules/.pnpm/yaml@2.7.1/node_modules/yaml/browser/dist/public-api.js
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser2 = new Parser(lineCounter?.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser2.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse3(src, reviver, options) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options === void 0 && reviver && typeof reviver === "object") {
    options = reviver;
  }
  const doc = parseDocument(src, options);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
function stringify3(value, replacer, options) {
  let _replacer = null;
  if (typeof replacer === "function" || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options === void 0 && replacer) {
    options = replacer;
  }
  if (typeof options === "string")
    options = options.length;
  if (typeof options === "number") {
    const indent = Math.round(options);
    options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
  }
  if (value === void 0) {
    const { keepUndefined } = options ?? replacer ?? {};
    if (!keepUndefined)
      return void 0;
  }
  if (isDocument(value) && !_replacer)
    return value.toString(options);
  return new Document(value, _replacer, options).toString(options);
}

// node_modules/.pnpm/monaco-yaml@5.3.1_monaco-editor@0.47.0/node_modules/monaco-yaml/yaml.worker.js
var path2 = __toESM(require_path_browserify(), 1);
var path = __toESM(require_path_browserify(), 1);
var path3 = __toESM(require_path_browserify(), 1);
var import_standalone = __toESM(require_standalone(), 1);
var parser = __toESM(require_yaml(), 1);
var path4 = __toESM(require_path_browserify(), 1);
function startsWith(haystack, needle) {
  if (haystack.length < needle.length) {
    return false;
  }
  for (var i = 0; i < needle.length; i++) {
    if (haystack[i] !== needle[i]) {
      return false;
    }
  }
  return true;
}
function endsWith(haystack, needle) {
  var diff = haystack.length - needle.length;
  if (diff > 0) {
    return haystack.lastIndexOf(needle) === diff;
  } else if (diff === 0) {
    return haystack === needle;
  } else {
    return false;
  }
}
function extendedRegExp(pattern) {
  if (startsWith(pattern, "(?i)")) {
    return new RegExp(pattern.substring(4), "i");
  } else {
    return new RegExp(pattern);
  }
}
function equals3(one, other) {
  if (one === other) {
    return true;
  }
  if (one === null || one === void 0 || other === null || other === void 0) {
    return false;
  }
  if (typeof one !== typeof other) {
    return false;
  }
  if (typeof one !== "object") {
    return false;
  }
  if (Array.isArray(one) !== Array.isArray(other)) {
    return false;
  }
  var i, key;
  if (Array.isArray(one)) {
    if (one.length !== other.length) {
      return false;
    }
    for (i = 0; i < one.length; i++) {
      if (!equals3(one[i], other[i])) {
        return false;
      }
    }
  } else {
    var oneKeys = [];
    for (key in one) {
      oneKeys.push(key);
    }
    oneKeys.sort();
    var otherKeys = [];
    for (key in other) {
      otherKeys.push(key);
    }
    otherKeys.sort();
    if (!equals3(oneKeys, otherKeys)) {
      return false;
    }
    for (i = 0; i < oneKeys.length; i++) {
      if (!equals3(one[oneKeys[i]], other[oneKeys[i]])) {
        return false;
      }
    }
  }
  return true;
}
function isNumber(val) {
  return typeof val === "number";
}
function isDefined(val) {
  return typeof val !== "undefined";
}
function isBoolean(val) {
  return typeof val === "boolean";
}
function isString2(val) {
  return typeof val === "string";
}
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["Undefined"] = 0] = "Undefined";
  ErrorCode2[ErrorCode2["EnumValueMismatch"] = 1] = "EnumValueMismatch";
  ErrorCode2[ErrorCode2["Deprecated"] = 2] = "Deprecated";
  ErrorCode2[ErrorCode2["UnexpectedEndOfComment"] = 257] = "UnexpectedEndOfComment";
  ErrorCode2[ErrorCode2["UnexpectedEndOfString"] = 258] = "UnexpectedEndOfString";
  ErrorCode2[ErrorCode2["UnexpectedEndOfNumber"] = 259] = "UnexpectedEndOfNumber";
  ErrorCode2[ErrorCode2["InvalidUnicode"] = 260] = "InvalidUnicode";
  ErrorCode2[ErrorCode2["InvalidEscapeCharacter"] = 261] = "InvalidEscapeCharacter";
  ErrorCode2[ErrorCode2["InvalidCharacter"] = 262] = "InvalidCharacter";
  ErrorCode2[ErrorCode2["PropertyExpected"] = 513] = "PropertyExpected";
  ErrorCode2[ErrorCode2["CommaExpected"] = 514] = "CommaExpected";
  ErrorCode2[ErrorCode2["ColonExpected"] = 515] = "ColonExpected";
  ErrorCode2[ErrorCode2["ValueExpected"] = 516] = "ValueExpected";
  ErrorCode2[ErrorCode2["CommaOrCloseBacketExpected"] = 517] = "CommaOrCloseBacketExpected";
  ErrorCode2[ErrorCode2["CommaOrCloseBraceExpected"] = 518] = "CommaOrCloseBraceExpected";
  ErrorCode2[ErrorCode2["TrailingComma"] = 519] = "TrailingComma";
  ErrorCode2[ErrorCode2["DuplicateKey"] = 520] = "DuplicateKey";
  ErrorCode2[ErrorCode2["CommentNotPermitted"] = 521] = "CommentNotPermitted";
  ErrorCode2[ErrorCode2["SchemaResolveError"] = 768] = "SchemaResolveError";
})(ErrorCode || (ErrorCode = {}));
var ClientCapabilities;
(function(ClientCapabilities2) {
  ClientCapabilities2.LATEST = {
    textDocument: {
      completion: {
        completionItem: {
          documentationFormat: [MarkupKind.Markdown, MarkupKind.PlainText],
          commitCharactersSupport: true
        }
      }
    }
  };
})(ClientCapabilities || (ClientCapabilities = {}));
var localize2 = (key, message, ...args) => args.length === 0 ? message : message.replaceAll(
  /{(\d+)}/g,
  (match, [index]) => index in args ? String(args[index]) : match
);
function loadMessageBundle() {
  return localize2;
}
var __extends = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var localize22 = loadMessageBundle();
var formats = {
  "color-hex": { errorMessage: localize22("colorHexFormatWarning", "Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA."), pattern: /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/ },
  "date-time": { errorMessage: localize22("dateTimeFormatWarning", "String is not a RFC3339 date-time."), pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i },
  "date": { errorMessage: localize22("dateFormatWarning", "String is not a RFC3339 date."), pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/i },
  "time": { errorMessage: localize22("timeFormatWarning", "String is not a RFC3339 time."), pattern: /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i },
  "email": { errorMessage: localize22("emailFormatWarning", "String is not an e-mail address."), pattern: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/ }
};
var ASTNodeImpl = (
  /** @class */
  (function() {
    function ASTNodeImpl3(parent, offset, length) {
      if (length === void 0) {
        length = 0;
      }
      this.offset = offset;
      this.length = length;
      this.parent = parent;
    }
    Object.defineProperty(ASTNodeImpl3.prototype, "children", {
      get: function() {
        return [];
      },
      enumerable: false,
      configurable: true
    });
    ASTNodeImpl3.prototype.toString = function() {
      return "type: " + this.type + " (" + this.offset + "/" + this.length + ")" + (this.parent ? " parent: {" + this.parent.toString() + "}" : "");
    };
    return ASTNodeImpl3;
  })()
);
var NullASTNodeImpl = (
  /** @class */
  (function(_super) {
    __extends(NullASTNodeImpl3, _super);
    function NullASTNodeImpl3(parent, offset) {
      var _this = _super.call(this, parent, offset) || this;
      _this.type = "null";
      _this.value = null;
      return _this;
    }
    return NullASTNodeImpl3;
  })(ASTNodeImpl)
);
var BooleanASTNodeImpl = (
  /** @class */
  (function(_super) {
    __extends(BooleanASTNodeImpl3, _super);
    function BooleanASTNodeImpl3(parent, boolValue, offset) {
      var _this = _super.call(this, parent, offset) || this;
      _this.type = "boolean";
      _this.value = boolValue;
      return _this;
    }
    return BooleanASTNodeImpl3;
  })(ASTNodeImpl)
);
var ArrayASTNodeImpl = (
  /** @class */
  (function(_super) {
    __extends(ArrayASTNodeImpl3, _super);
    function ArrayASTNodeImpl3(parent, offset) {
      var _this = _super.call(this, parent, offset) || this;
      _this.type = "array";
      _this.items = [];
      return _this;
    }
    Object.defineProperty(ArrayASTNodeImpl3.prototype, "children", {
      get: function() {
        return this.items;
      },
      enumerable: false,
      configurable: true
    });
    return ArrayASTNodeImpl3;
  })(ASTNodeImpl)
);
var NumberASTNodeImpl = (
  /** @class */
  (function(_super) {
    __extends(NumberASTNodeImpl3, _super);
    function NumberASTNodeImpl3(parent, offset) {
      var _this = _super.call(this, parent, offset) || this;
      _this.type = "number";
      _this.isInteger = true;
      _this.value = Number.NaN;
      return _this;
    }
    return NumberASTNodeImpl3;
  })(ASTNodeImpl)
);
var StringASTNodeImpl = (
  /** @class */
  (function(_super) {
    __extends(StringASTNodeImpl3, _super);
    function StringASTNodeImpl3(parent, offset, length) {
      var _this = _super.call(this, parent, offset, length) || this;
      _this.type = "string";
      _this.value = "";
      return _this;
    }
    return StringASTNodeImpl3;
  })(ASTNodeImpl)
);
var PropertyASTNodeImpl = (
  /** @class */
  (function(_super) {
    __extends(PropertyASTNodeImpl3, _super);
    function PropertyASTNodeImpl3(parent, offset, keyNode) {
      var _this = _super.call(this, parent, offset) || this;
      _this.type = "property";
      _this.colonOffset = -1;
      _this.keyNode = keyNode;
      return _this;
    }
    Object.defineProperty(PropertyASTNodeImpl3.prototype, "children", {
      get: function() {
        return this.valueNode ? [this.keyNode, this.valueNode] : [this.keyNode];
      },
      enumerable: false,
      configurable: true
    });
    return PropertyASTNodeImpl3;
  })(ASTNodeImpl)
);
var ObjectASTNodeImpl = (
  /** @class */
  (function(_super) {
    __extends(ObjectASTNodeImpl3, _super);
    function ObjectASTNodeImpl3(parent, offset) {
      var _this = _super.call(this, parent, offset) || this;
      _this.type = "object";
      _this.properties = [];
      return _this;
    }
    Object.defineProperty(ObjectASTNodeImpl3.prototype, "children", {
      get: function() {
        return this.properties;
      },
      enumerable: false,
      configurable: true
    });
    return ObjectASTNodeImpl3;
  })(ASTNodeImpl)
);
function asSchema(schema4) {
  if (isBoolean(schema4)) {
    return schema4 ? {} : { "not": {} };
  }
  return schema4;
}
var EnumMatch;
(function(EnumMatch3) {
  EnumMatch3[EnumMatch3["Key"] = 0] = "Key";
  EnumMatch3[EnumMatch3["Enum"] = 1] = "Enum";
})(EnumMatch || (EnumMatch = {}));
var SchemaCollector = (
  /** @class */
  (function() {
    function SchemaCollector3(focusOffset, exclude) {
      if (focusOffset === void 0) {
        focusOffset = -1;
      }
      this.focusOffset = focusOffset;
      this.exclude = exclude;
      this.schemas = [];
    }
    SchemaCollector3.prototype.add = function(schema4) {
      this.schemas.push(schema4);
    };
    SchemaCollector3.prototype.merge = function(other) {
      Array.prototype.push.apply(this.schemas, other.schemas);
    };
    SchemaCollector3.prototype.include = function(node) {
      return (this.focusOffset === -1 || contains2(node, this.focusOffset)) && node !== this.exclude;
    };
    SchemaCollector3.prototype.newSub = function() {
      return new SchemaCollector3(-1, this.exclude);
    };
    return SchemaCollector3;
  })()
);
var NoOpSchemaCollector = (
  /** @class */
  (function() {
    function NoOpSchemaCollector3() {
    }
    Object.defineProperty(NoOpSchemaCollector3.prototype, "schemas", {
      get: function() {
        return [];
      },
      enumerable: false,
      configurable: true
    });
    NoOpSchemaCollector3.prototype.add = function(schema4) {
    };
    NoOpSchemaCollector3.prototype.merge = function(other) {
    };
    NoOpSchemaCollector3.prototype.include = function(node) {
      return true;
    };
    NoOpSchemaCollector3.prototype.newSub = function() {
      return this;
    };
    NoOpSchemaCollector3.instance = new NoOpSchemaCollector3();
    return NoOpSchemaCollector3;
  })()
);
var ValidationResult = (
  /** @class */
  (function() {
    function ValidationResult3() {
      this.problems = [];
      this.propertiesMatches = 0;
      this.propertiesValueMatches = 0;
      this.primaryValueMatches = 0;
      this.enumValueMatch = false;
      this.enumValues = void 0;
    }
    ValidationResult3.prototype.hasProblems = function() {
      return !!this.problems.length;
    };
    ValidationResult3.prototype.mergeAll = function(validationResults) {
      for (var _i = 0, validationResults_1 = validationResults; _i < validationResults_1.length; _i++) {
        var validationResult = validationResults_1[_i];
        this.merge(validationResult);
      }
    };
    ValidationResult3.prototype.merge = function(validationResult) {
      this.problems = this.problems.concat(validationResult.problems);
    };
    ValidationResult3.prototype.mergeEnumValues = function(validationResult) {
      if (!this.enumValueMatch && !validationResult.enumValueMatch && this.enumValues && validationResult.enumValues) {
        this.enumValues = this.enumValues.concat(validationResult.enumValues);
        for (var _i = 0, _a4 = this.problems; _i < _a4.length; _i++) {
          var error = _a4[_i];
          if (error.code === ErrorCode.EnumValueMismatch) {
            error.message = localize22("enumWarning", "Value is not accepted. Valid values: {0}.", this.enumValues.map(function(v) {
              return JSON.stringify(v);
            }).join(", "));
          }
        }
      }
    };
    ValidationResult3.prototype.mergePropertyMatch = function(propertyValidationResult) {
      this.merge(propertyValidationResult);
      this.propertiesMatches++;
      if (propertyValidationResult.enumValueMatch || !propertyValidationResult.hasProblems() && propertyValidationResult.propertiesMatches) {
        this.propertiesValueMatches++;
      }
      if (propertyValidationResult.enumValueMatch && propertyValidationResult.enumValues && propertyValidationResult.enumValues.length === 1) {
        this.primaryValueMatches++;
      }
    };
    ValidationResult3.prototype.compare = function(other) {
      var hasProblems = this.hasProblems();
      if (hasProblems !== other.hasProblems()) {
        return hasProblems ? -1 : 1;
      }
      if (this.enumValueMatch !== other.enumValueMatch) {
        return other.enumValueMatch ? -1 : 1;
      }
      if (this.primaryValueMatches !== other.primaryValueMatches) {
        return this.primaryValueMatches - other.primaryValueMatches;
      }
      if (this.propertiesValueMatches !== other.propertiesValueMatches) {
        return this.propertiesValueMatches - other.propertiesValueMatches;
      }
      return this.propertiesMatches - other.propertiesMatches;
    };
    return ValidationResult3;
  })()
);
function getNodeValue22(node) {
  return getNodeValue2(node);
}
function contains2(node, offset, includeRightBound) {
  if (includeRightBound === void 0) {
    includeRightBound = false;
  }
  return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;
}
var JSONDocument = (
  /** @class */
  (function() {
    function JSONDocument3(root, syntaxErrors, comments) {
      if (syntaxErrors === void 0) {
        syntaxErrors = [];
      }
      if (comments === void 0) {
        comments = [];
      }
      this.root = root;
      this.syntaxErrors = syntaxErrors;
      this.comments = comments;
    }
    JSONDocument3.prototype.getNodeFromOffset = function(offset, includeRightBound) {
      if (includeRightBound === void 0) {
        includeRightBound = false;
      }
      if (this.root) {
        return findNodeAtOffset2(this.root, offset, includeRightBound);
      }
      return void 0;
    };
    JSONDocument3.prototype.visit = function(visitor) {
      if (this.root) {
        var doVisit_1 = function(node) {
          var ctn = visitor(node);
          var children = node.children;
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length && ctn; i++) {
              ctn = doVisit_1(children[i]);
            }
          }
          return ctn;
        };
        doVisit_1(this.root);
      }
    };
    JSONDocument3.prototype.validate = function(textDocument, schema4, severity) {
      if (severity === void 0) {
        severity = DiagnosticSeverity.Warning;
      }
      if (this.root && schema4) {
        var validationResult = new ValidationResult();
        validate(this.root, schema4, validationResult, NoOpSchemaCollector.instance);
        return validationResult.problems.map(function(p) {
          var _a4;
          var range = Range2.create(textDocument.positionAt(p.location.offset), textDocument.positionAt(p.location.offset + p.location.length));
          return Diagnostic.create(range, p.message, (_a4 = p.severity) !== null && _a4 !== void 0 ? _a4 : severity, p.code);
        });
      }
      return void 0;
    };
    JSONDocument3.prototype.getMatchingSchemas = function(schema4, focusOffset, exclude) {
      if (focusOffset === void 0) {
        focusOffset = -1;
      }
      var matchingSchemas = new SchemaCollector(focusOffset, exclude);
      if (this.root && schema4) {
        validate(this.root, schema4, new ValidationResult(), matchingSchemas);
      }
      return matchingSchemas.schemas;
    };
    return JSONDocument3;
  })()
);
function validate(n, schema4, validationResult, matchingSchemas) {
  if (!n || !matchingSchemas.include(n)) {
    return;
  }
  var node = n;
  switch (node.type) {
    case "object":
      _validateObjectNode(node, schema4, validationResult, matchingSchemas);
      break;
    case "array":
      _validateArrayNode(node, schema4, validationResult, matchingSchemas);
      break;
    case "string":
      _validateStringNode(node, schema4, validationResult, matchingSchemas);
      break;
    case "number":
      _validateNumberNode(node, schema4, validationResult, matchingSchemas);
      break;
    case "property":
      return validate(node.valueNode, schema4, validationResult, matchingSchemas);
  }
  _validateNode();
  matchingSchemas.add({ node, schema: schema4 });
  function _validateNode() {
    function matchesType(type) {
      return node.type === type || type === "integer" && node.type === "number" && node.isInteger;
    }
    if (Array.isArray(schema4.type)) {
      if (!schema4.type.some(matchesType)) {
        validationResult.problems.push({
          location: { offset: node.offset, length: node.length },
          message: schema4.errorMessage || localize22("typeArrayMismatchWarning", "Incorrect type. Expected one of {0}.", schema4.type.join(", "))
        });
      }
    } else if (schema4.type) {
      if (!matchesType(schema4.type)) {
        validationResult.problems.push({
          location: { offset: node.offset, length: node.length },
          message: schema4.errorMessage || localize22("typeMismatchWarning", 'Incorrect type. Expected "{0}".', schema4.type)
        });
      }
    }
    if (Array.isArray(schema4.allOf)) {
      for (var _i = 0, _a4 = schema4.allOf; _i < _a4.length; _i++) {
        var subSchemaRef = _a4[_i];
        validate(node, asSchema(subSchemaRef), validationResult, matchingSchemas);
      }
    }
    var notSchema = asSchema(schema4.not);
    if (notSchema) {
      var subValidationResult = new ValidationResult();
      var subMatchingSchemas = matchingSchemas.newSub();
      validate(node, notSchema, subValidationResult, subMatchingSchemas);
      if (!subValidationResult.hasProblems()) {
        validationResult.problems.push({
          location: { offset: node.offset, length: node.length },
          message: localize22("notSchemaWarning", "Matches a schema that is not allowed.")
        });
      }
      for (var _b2 = 0, _c = subMatchingSchemas.schemas; _b2 < _c.length; _b2++) {
        var ms = _c[_b2];
        ms.inverted = !ms.inverted;
        matchingSchemas.add(ms);
      }
    }
    var testAlternatives = function(alternatives, maxOneMatch) {
      var matches = [];
      var bestMatch = void 0;
      for (var _i2 = 0, alternatives_1 = alternatives; _i2 < alternatives_1.length; _i2++) {
        var subSchemaRef2 = alternatives_1[_i2];
        var subSchema = asSchema(subSchemaRef2);
        var subValidationResult2 = new ValidationResult();
        var subMatchingSchemas2 = matchingSchemas.newSub();
        validate(node, subSchema, subValidationResult2, subMatchingSchemas2);
        if (!subValidationResult2.hasProblems()) {
          matches.push(subSchema);
        }
        if (!bestMatch) {
          bestMatch = { schema: subSchema, validationResult: subValidationResult2, matchingSchemas: subMatchingSchemas2 };
        } else {
          if (!maxOneMatch && !subValidationResult2.hasProblems() && !bestMatch.validationResult.hasProblems()) {
            bestMatch.matchingSchemas.merge(subMatchingSchemas2);
            bestMatch.validationResult.propertiesMatches += subValidationResult2.propertiesMatches;
            bestMatch.validationResult.propertiesValueMatches += subValidationResult2.propertiesValueMatches;
          } else {
            var compareResult = subValidationResult2.compare(bestMatch.validationResult);
            if (compareResult > 0) {
              bestMatch = { schema: subSchema, validationResult: subValidationResult2, matchingSchemas: subMatchingSchemas2 };
            } else if (compareResult === 0) {
              bestMatch.matchingSchemas.merge(subMatchingSchemas2);
              bestMatch.validationResult.mergeEnumValues(subValidationResult2);
            }
          }
        }
      }
      if (matches.length > 1 && maxOneMatch) {
        validationResult.problems.push({
          location: { offset: node.offset, length: 1 },
          message: localize22("oneOfWarning", "Matches multiple schemas when only one must validate.")
        });
      }
      if (bestMatch) {
        validationResult.merge(bestMatch.validationResult);
        validationResult.propertiesMatches += bestMatch.validationResult.propertiesMatches;
        validationResult.propertiesValueMatches += bestMatch.validationResult.propertiesValueMatches;
        matchingSchemas.merge(bestMatch.matchingSchemas);
      }
      return matches.length;
    };
    if (Array.isArray(schema4.anyOf)) {
      testAlternatives(schema4.anyOf, false);
    }
    if (Array.isArray(schema4.oneOf)) {
      testAlternatives(schema4.oneOf, true);
    }
    var testBranch = function(schema22) {
      var subValidationResult2 = new ValidationResult();
      var subMatchingSchemas2 = matchingSchemas.newSub();
      validate(node, asSchema(schema22), subValidationResult2, subMatchingSchemas2);
      validationResult.merge(subValidationResult2);
      validationResult.propertiesMatches += subValidationResult2.propertiesMatches;
      validationResult.propertiesValueMatches += subValidationResult2.propertiesValueMatches;
      matchingSchemas.merge(subMatchingSchemas2);
    };
    var testCondition = function(ifSchema2, thenSchema, elseSchema) {
      var subSchema = asSchema(ifSchema2);
      var subValidationResult2 = new ValidationResult();
      var subMatchingSchemas2 = matchingSchemas.newSub();
      validate(node, subSchema, subValidationResult2, subMatchingSchemas2);
      matchingSchemas.merge(subMatchingSchemas2);
      if (!subValidationResult2.hasProblems()) {
        if (thenSchema) {
          testBranch(thenSchema);
        }
      } else if (elseSchema) {
        testBranch(elseSchema);
      }
    };
    var ifSchema = asSchema(schema4.if);
    if (ifSchema) {
      testCondition(ifSchema, asSchema(schema4.then), asSchema(schema4.else));
    }
    if (Array.isArray(schema4.enum)) {
      var val = getNodeValue22(node);
      var enumValueMatch = false;
      for (var _d = 0, _e = schema4.enum; _d < _e.length; _d++) {
        var e = _e[_d];
        if (equals3(val, e)) {
          enumValueMatch = true;
          break;
        }
      }
      validationResult.enumValues = schema4.enum;
      validationResult.enumValueMatch = enumValueMatch;
      if (!enumValueMatch) {
        validationResult.problems.push({
          location: { offset: node.offset, length: node.length },
          code: ErrorCode.EnumValueMismatch,
          message: schema4.errorMessage || localize22("enumWarning", "Value is not accepted. Valid values: {0}.", schema4.enum.map(function(v) {
            return JSON.stringify(v);
          }).join(", "))
        });
      }
    }
    if (isDefined(schema4.const)) {
      var val = getNodeValue22(node);
      if (!equals3(val, schema4.const)) {
        validationResult.problems.push({
          location: { offset: node.offset, length: node.length },
          code: ErrorCode.EnumValueMismatch,
          message: schema4.errorMessage || localize22("constWarning", "Value must be {0}.", JSON.stringify(schema4.const))
        });
        validationResult.enumValueMatch = false;
      } else {
        validationResult.enumValueMatch = true;
      }
      validationResult.enumValues = [schema4.const];
    }
    if (schema4.deprecationMessage && node.parent) {
      validationResult.problems.push({
        location: { offset: node.parent.offset, length: node.parent.length },
        severity: DiagnosticSeverity.Warning,
        message: schema4.deprecationMessage,
        code: ErrorCode.Deprecated
      });
    }
  }
  function _validateNumberNode(node2, schema22, validationResult2, matchingSchemas2) {
    var val = node2.value;
    function normalizeFloats(float3) {
      var _a4;
      var parts = /^(-?\d+)(?:\.(\d+))?(?:e([-+]\d+))?$/.exec(float3.toString());
      return parts && {
        value: Number(parts[1] + (parts[2] || "")),
        multiplier: (((_a4 = parts[2]) === null || _a4 === void 0 ? void 0 : _a4.length) || 0) - (parseInt(parts[3]) || 0)
      };
    }
    ;
    if (isNumber(schema22.multipleOf)) {
      var remainder = -1;
      if (Number.isInteger(schema22.multipleOf)) {
        remainder = val % schema22.multipleOf;
      } else {
        var normMultipleOf = normalizeFloats(schema22.multipleOf);
        var normValue = normalizeFloats(val);
        if (normMultipleOf && normValue) {
          var multiplier = Math.pow(10, Math.abs(normValue.multiplier - normMultipleOf.multiplier));
          if (normValue.multiplier < normMultipleOf.multiplier) {
            normValue.value *= multiplier;
          } else {
            normMultipleOf.value *= multiplier;
          }
          remainder = normValue.value % normMultipleOf.value;
        }
      }
      if (remainder !== 0) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          message: localize22("multipleOfWarning", "Value is not divisible by {0}.", schema22.multipleOf)
        });
      }
    }
    function getExclusiveLimit(limit, exclusive) {
      if (isNumber(exclusive)) {
        return exclusive;
      }
      if (isBoolean(exclusive) && exclusive) {
        return limit;
      }
      return void 0;
    }
    function getLimit(limit, exclusive) {
      if (!isBoolean(exclusive) || !exclusive) {
        return limit;
      }
      return void 0;
    }
    var exclusiveMinimum = getExclusiveLimit(schema22.minimum, schema22.exclusiveMinimum);
    if (isNumber(exclusiveMinimum) && val <= exclusiveMinimum) {
      validationResult2.problems.push({
        location: { offset: node2.offset, length: node2.length },
        message: localize22("exclusiveMinimumWarning", "Value is below the exclusive minimum of {0}.", exclusiveMinimum)
      });
    }
    var exclusiveMaximum = getExclusiveLimit(schema22.maximum, schema22.exclusiveMaximum);
    if (isNumber(exclusiveMaximum) && val >= exclusiveMaximum) {
      validationResult2.problems.push({
        location: { offset: node2.offset, length: node2.length },
        message: localize22("exclusiveMaximumWarning", "Value is above the exclusive maximum of {0}.", exclusiveMaximum)
      });
    }
    var minimum = getLimit(schema22.minimum, schema22.exclusiveMinimum);
    if (isNumber(minimum) && val < minimum) {
      validationResult2.problems.push({
        location: { offset: node2.offset, length: node2.length },
        message: localize22("minimumWarning", "Value is below the minimum of {0}.", minimum)
      });
    }
    var maximum = getLimit(schema22.maximum, schema22.exclusiveMaximum);
    if (isNumber(maximum) && val > maximum) {
      validationResult2.problems.push({
        location: { offset: node2.offset, length: node2.length },
        message: localize22("maximumWarning", "Value is above the maximum of {0}.", maximum)
      });
    }
  }
  function _validateStringNode(node2, schema22, validationResult2, matchingSchemas2) {
    if (isNumber(schema22.minLength) && node2.value.length < schema22.minLength) {
      validationResult2.problems.push({
        location: { offset: node2.offset, length: node2.length },
        message: localize22("minLengthWarning", "String is shorter than the minimum length of {0}.", schema22.minLength)
      });
    }
    if (isNumber(schema22.maxLength) && node2.value.length > schema22.maxLength) {
      validationResult2.problems.push({
        location: { offset: node2.offset, length: node2.length },
        message: localize22("maxLengthWarning", "String is longer than the maximum length of {0}.", schema22.maxLength)
      });
    }
    if (isString2(schema22.pattern)) {
      var regex = extendedRegExp(schema22.pattern);
      if (!regex.test(node2.value)) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          message: schema22.patternErrorMessage || schema22.errorMessage || localize22("patternWarning", 'String does not match the pattern of "{0}".', schema22.pattern)
        });
      }
    }
    if (schema22.format) {
      switch (schema22.format) {
        case "uri":
        case "uri-reference":
          {
            var errorMessage = void 0;
            if (!node2.value) {
              errorMessage = localize22("uriEmpty", "URI expected.");
            } else {
              var match = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/.exec(node2.value);
              if (!match) {
                errorMessage = localize22("uriMissing", "URI is expected.");
              } else if (!match[2] && schema22.format === "uri") {
                errorMessage = localize22("uriSchemeMissing", "URI with a scheme is expected.");
              }
            }
            if (errorMessage) {
              validationResult2.problems.push({
                location: { offset: node2.offset, length: node2.length },
                message: schema22.patternErrorMessage || schema22.errorMessage || localize22("uriFormatWarning", "String is not a URI: {0}", errorMessage)
              });
            }
          }
          break;
        case "color-hex":
        case "date-time":
        case "date":
        case "time":
        case "email":
          var format22 = formats[schema22.format];
          if (!node2.value || !format22.pattern.exec(node2.value)) {
            validationResult2.problems.push({
              location: { offset: node2.offset, length: node2.length },
              message: schema22.patternErrorMessage || schema22.errorMessage || format22.errorMessage
            });
          }
        default:
      }
    }
  }
  function _validateArrayNode(node2, schema22, validationResult2, matchingSchemas2) {
    if (Array.isArray(schema22.items)) {
      var subSchemas = schema22.items;
      for (var index = 0; index < subSchemas.length; index++) {
        var subSchemaRef = subSchemas[index];
        var subSchema = asSchema(subSchemaRef);
        var itemValidationResult = new ValidationResult();
        var item = node2.items[index];
        if (item) {
          validate(item, subSchema, itemValidationResult, matchingSchemas2);
          validationResult2.mergePropertyMatch(itemValidationResult);
        } else if (node2.items.length >= subSchemas.length) {
          validationResult2.propertiesValueMatches++;
        }
      }
      if (node2.items.length > subSchemas.length) {
        if (typeof schema22.additionalItems === "object") {
          for (var i = subSchemas.length; i < node2.items.length; i++) {
            var itemValidationResult = new ValidationResult();
            validate(node2.items[i], schema22.additionalItems, itemValidationResult, matchingSchemas2);
            validationResult2.mergePropertyMatch(itemValidationResult);
          }
        } else if (schema22.additionalItems === false) {
          validationResult2.problems.push({
            location: { offset: node2.offset, length: node2.length },
            message: localize22("additionalItemsWarning", "Array has too many items according to schema. Expected {0} or fewer.", subSchemas.length)
          });
        }
      }
    } else {
      var itemSchema = asSchema(schema22.items);
      if (itemSchema) {
        for (var _i = 0, _a4 = node2.items; _i < _a4.length; _i++) {
          var item = _a4[_i];
          var itemValidationResult = new ValidationResult();
          validate(item, itemSchema, itemValidationResult, matchingSchemas2);
          validationResult2.mergePropertyMatch(itemValidationResult);
        }
      }
    }
    var containsSchema = asSchema(schema22.contains);
    if (containsSchema) {
      var doesContain = node2.items.some(function(item2) {
        var itemValidationResult2 = new ValidationResult();
        validate(item2, containsSchema, itemValidationResult2, NoOpSchemaCollector.instance);
        return !itemValidationResult2.hasProblems();
      });
      if (!doesContain) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          message: schema22.errorMessage || localize22("requiredItemMissingWarning", "Array does not contain required item.")
        });
      }
    }
    if (isNumber(schema22.minItems) && node2.items.length < schema22.minItems) {
      validationResult2.problems.push({
        location: { offset: node2.offset, length: node2.length },
        message: localize22("minItemsWarning", "Array has too few items. Expected {0} or more.", schema22.minItems)
      });
    }
    if (isNumber(schema22.maxItems) && node2.items.length > schema22.maxItems) {
      validationResult2.problems.push({
        location: { offset: node2.offset, length: node2.length },
        message: localize22("maxItemsWarning", "Array has too many items. Expected {0} or fewer.", schema22.maxItems)
      });
    }
    if (schema22.uniqueItems === true) {
      var values_1 = getNodeValue22(node2);
      var duplicates = values_1.some(function(value, index2) {
        return index2 !== values_1.lastIndexOf(value);
      });
      if (duplicates) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          message: localize22("uniqueItemsWarning", "Array has duplicate items.")
        });
      }
    }
  }
  function _validateObjectNode(node2, schema22, validationResult2, matchingSchemas2) {
    var seenKeys = /* @__PURE__ */ Object.create(null);
    var unprocessedProperties = [];
    for (var _i = 0, _a4 = node2.properties; _i < _a4.length; _i++) {
      var propertyNode = _a4[_i];
      var key = propertyNode.keyNode.value;
      seenKeys[key] = propertyNode.valueNode;
      unprocessedProperties.push(key);
    }
    if (Array.isArray(schema22.required)) {
      for (var _b2 = 0, _c = schema22.required; _b2 < _c.length; _b2++) {
        var propertyName = _c[_b2];
        if (!seenKeys[propertyName]) {
          var keyNode = node2.parent && node2.parent.type === "property" && node2.parent.keyNode;
          var location = keyNode ? { offset: keyNode.offset, length: keyNode.length } : { offset: node2.offset, length: 1 };
          validationResult2.problems.push({
            location,
            message: localize22("MissingRequiredPropWarning", 'Missing property "{0}".', propertyName)
          });
        }
      }
    }
    var propertyProcessed = function(prop2) {
      var index = unprocessedProperties.indexOf(prop2);
      while (index >= 0) {
        unprocessedProperties.splice(index, 1);
        index = unprocessedProperties.indexOf(prop2);
      }
    };
    if (schema22.properties) {
      for (var _d = 0, _e = Object.keys(schema22.properties); _d < _e.length; _d++) {
        var propertyName = _e[_d];
        propertyProcessed(propertyName);
        var propertySchema = schema22.properties[propertyName];
        var child = seenKeys[propertyName];
        if (child) {
          if (isBoolean(propertySchema)) {
            if (!propertySchema) {
              var propertyNode = child.parent;
              validationResult2.problems.push({
                location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },
                message: schema22.errorMessage || localize22("DisallowedExtraPropWarning", "Property {0} is not allowed.", propertyName)
              });
            } else {
              validationResult2.propertiesMatches++;
              validationResult2.propertiesValueMatches++;
            }
          } else {
            var propertyValidationResult = new ValidationResult();
            validate(child, propertySchema, propertyValidationResult, matchingSchemas2);
            validationResult2.mergePropertyMatch(propertyValidationResult);
          }
        }
      }
    }
    if (schema22.patternProperties) {
      for (var _f = 0, _g = Object.keys(schema22.patternProperties); _f < _g.length; _f++) {
        var propertyPattern = _g[_f];
        var regex = extendedRegExp(propertyPattern);
        for (var _h = 0, _j = unprocessedProperties.slice(0); _h < _j.length; _h++) {
          var propertyName = _j[_h];
          if (regex.test(propertyName)) {
            propertyProcessed(propertyName);
            var child = seenKeys[propertyName];
            if (child) {
              var propertySchema = schema22.patternProperties[propertyPattern];
              if (isBoolean(propertySchema)) {
                if (!propertySchema) {
                  var propertyNode = child.parent;
                  validationResult2.problems.push({
                    location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },
                    message: schema22.errorMessage || localize22("DisallowedExtraPropWarning", "Property {0} is not allowed.", propertyName)
                  });
                } else {
                  validationResult2.propertiesMatches++;
                  validationResult2.propertiesValueMatches++;
                }
              } else {
                var propertyValidationResult = new ValidationResult();
                validate(child, propertySchema, propertyValidationResult, matchingSchemas2);
                validationResult2.mergePropertyMatch(propertyValidationResult);
              }
            }
          }
        }
      }
    }
    if (typeof schema22.additionalProperties === "object") {
      for (var _k = 0, unprocessedProperties_1 = unprocessedProperties; _k < unprocessedProperties_1.length; _k++) {
        var propertyName = unprocessedProperties_1[_k];
        var child = seenKeys[propertyName];
        if (child) {
          var propertyValidationResult = new ValidationResult();
          validate(child, schema22.additionalProperties, propertyValidationResult, matchingSchemas2);
          validationResult2.mergePropertyMatch(propertyValidationResult);
        }
      }
    } else if (schema22.additionalProperties === false) {
      if (unprocessedProperties.length > 0) {
        for (var _l = 0, unprocessedProperties_2 = unprocessedProperties; _l < unprocessedProperties_2.length; _l++) {
          var propertyName = unprocessedProperties_2[_l];
          var child = seenKeys[propertyName];
          if (child) {
            var propertyNode = child.parent;
            validationResult2.problems.push({
              location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },
              message: schema22.errorMessage || localize22("DisallowedExtraPropWarning", "Property {0} is not allowed.", propertyName)
            });
          }
        }
      }
    }
    if (isNumber(schema22.maxProperties)) {
      if (node2.properties.length > schema22.maxProperties) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          message: localize22("MaxPropWarning", "Object has more properties than limit of {0}.", schema22.maxProperties)
        });
      }
    }
    if (isNumber(schema22.minProperties)) {
      if (node2.properties.length < schema22.minProperties) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          message: localize22("MinPropWarning", "Object has fewer properties than the required number of {0}", schema22.minProperties)
        });
      }
    }
    if (schema22.dependencies) {
      for (var _m = 0, _o = Object.keys(schema22.dependencies); _m < _o.length; _m++) {
        var key = _o[_m];
        var prop = seenKeys[key];
        if (prop) {
          var propertyDep = schema22.dependencies[key];
          if (Array.isArray(propertyDep)) {
            for (var _p = 0, propertyDep_1 = propertyDep; _p < propertyDep_1.length; _p++) {
              var requiredProp = propertyDep_1[_p];
              if (!seenKeys[requiredProp]) {
                validationResult2.problems.push({
                  location: { offset: node2.offset, length: node2.length },
                  message: localize22("RequiredDependentPropWarning", "Object is missing property {0} required by property {1}.", requiredProp, key)
                });
              } else {
                validationResult2.propertiesValueMatches++;
              }
            }
          } else {
            var propertySchema = asSchema(propertyDep);
            if (propertySchema) {
              var propertyValidationResult = new ValidationResult();
              validate(node2, propertySchema, propertyValidationResult, matchingSchemas2);
              validationResult2.mergePropertyMatch(propertyValidationResult);
            }
          }
        }
      }
    }
    var propertyNames = asSchema(schema22.propertyNames);
    if (propertyNames) {
      for (var _q = 0, _r = node2.properties; _q < _r.length; _q++) {
        var f2 = _r[_q];
        var key = f2.keyNode;
        if (key) {
          validate(key, propertyNames, validationResult2, NoOpSchemaCollector.instance);
        }
      }
    }
  }
}
function createRegex(glob, opts) {
  if (typeof glob !== "string") {
    throw new TypeError("Expected a string");
  }
  var str = String(glob);
  var reStr = "";
  var extended = opts ? !!opts.extended : false;
  var globstar = opts ? !!opts.globstar : false;
  var inGroup = false;
  var flags = opts && typeof opts.flags === "string" ? opts.flags : "";
  var c;
  for (var i = 0, len = str.length; i < len; i++) {
    c = str[i];
    switch (c) {
      case "/":
      case "$":
      case "^":
      case "+":
      case ".":
      case "(":
      case ")":
      case "=":
      case "!":
      case "|":
        reStr += "\\" + c;
        break;
      case "?":
        if (extended) {
          reStr += ".";
          break;
        }
      case "[":
      case "]":
        if (extended) {
          reStr += c;
          break;
        }
      case "{":
        if (extended) {
          inGroup = true;
          reStr += "(";
          break;
        }
      case "}":
        if (extended) {
          inGroup = false;
          reStr += ")";
          break;
        }
      case ",":
        if (inGroup) {
          reStr += "|";
          break;
        }
        reStr += "\\" + c;
        break;
      case "*":
        var prevChar = str[i - 1];
        var starCount = 1;
        while (str[i + 1] === "*") {
          starCount++;
          i++;
        }
        var nextChar = str[i + 1];
        if (!globstar) {
          reStr += ".*";
        } else {
          var isGlobstar = starCount > 1 && (prevChar === "/" || prevChar === void 0 || prevChar === "{" || prevChar === ",") && (nextChar === "/" || nextChar === void 0 || nextChar === "," || nextChar === "}");
          if (isGlobstar) {
            if (nextChar === "/") {
              i++;
            } else if (prevChar === "/" && reStr.endsWith("\\/")) {
              reStr = reStr.substr(0, reStr.length - 2);
            }
            reStr += "((?:[^/]*(?:/|$))*)";
          } else {
            reStr += "([^/]*)";
          }
        }
        break;
      default:
        reStr += c;
    }
  }
  if (!flags || !~flags.indexOf("g")) {
    reStr = "^" + reStr + "$";
  }
  return new RegExp(reStr, flags);
}
var localize3 = loadMessageBundle();
var BANG = "!";
var PATH_SEP = "/";
var FilePatternAssociation = (
  /** @class */
  (function() {
    function FilePatternAssociation3(pattern, uris) {
      this.globWrappers = [];
      try {
        for (var _i = 0, pattern_1 = pattern; _i < pattern_1.length; _i++) {
          var patternString = pattern_1[_i];
          var include = patternString[0] !== BANG;
          if (!include) {
            patternString = patternString.substring(1);
          }
          if (patternString.length > 0) {
            if (patternString[0] === PATH_SEP) {
              patternString = patternString.substring(1);
            }
            this.globWrappers.push({
              regexp: createRegex("**/" + patternString, { extended: true, globstar: true }),
              include
            });
          }
        }
        ;
        this.uris = uris;
      } catch (e) {
        this.globWrappers.length = 0;
        this.uris = [];
      }
    }
    FilePatternAssociation3.prototype.matchesPattern = function(fileName) {
      var match = false;
      for (var _i = 0, _a4 = this.globWrappers; _i < _a4.length; _i++) {
        var _b2 = _a4[_i], regexp = _b2.regexp, include = _b2.include;
        if (regexp.test(fileName)) {
          match = include;
        }
      }
      return match;
    };
    FilePatternAssociation3.prototype.getURIs = function() {
      return this.uris;
    };
    return FilePatternAssociation3;
  })()
);
var SchemaHandle = (
  /** @class */
  (function() {
    function SchemaHandle2(service, url, unresolvedSchemaContent) {
      this.service = service;
      this.url = url;
      this.dependencies = {};
      if (unresolvedSchemaContent) {
        this.unresolvedSchema = this.service.promise.resolve(new UnresolvedSchema(unresolvedSchemaContent));
      }
    }
    SchemaHandle2.prototype.getUnresolvedSchema = function() {
      if (!this.unresolvedSchema) {
        this.unresolvedSchema = this.service.loadSchema(this.url);
      }
      return this.unresolvedSchema;
    };
    SchemaHandle2.prototype.getResolvedSchema = function() {
      var _this = this;
      if (!this.resolvedSchema) {
        this.resolvedSchema = this.getUnresolvedSchema().then(function(unresolved) {
          return _this.service.resolveSchemaContent(unresolved, _this.url, _this.dependencies);
        });
      }
      return this.resolvedSchema;
    };
    SchemaHandle2.prototype.clearSchema = function() {
      this.resolvedSchema = void 0;
      this.unresolvedSchema = void 0;
      this.dependencies = {};
    };
    return SchemaHandle2;
  })()
);
var UnresolvedSchema = (
  /** @class */
  /* @__PURE__ */ (function() {
    function UnresolvedSchema2(schema4, errors) {
      if (errors === void 0) {
        errors = [];
      }
      this.schema = schema4;
      this.errors = errors;
    }
    return UnresolvedSchema2;
  })()
);
var ResolvedSchema = (
  /** @class */
  (function() {
    function ResolvedSchema2(schema4, errors) {
      if (errors === void 0) {
        errors = [];
      }
      this.schema = schema4;
      this.errors = errors;
    }
    ResolvedSchema2.prototype.getSection = function(path5) {
      var schemaRef = this.getSectionRecursive(path5, this.schema);
      if (schemaRef) {
        return asSchema(schemaRef);
      }
      return void 0;
    };
    ResolvedSchema2.prototype.getSectionRecursive = function(path5, schema4) {
      if (!schema4 || typeof schema4 === "boolean" || path5.length === 0) {
        return schema4;
      }
      var next = path5.shift();
      if (schema4.properties && typeof schema4.properties[next]) {
        return this.getSectionRecursive(path5, schema4.properties[next]);
      } else if (schema4.patternProperties) {
        for (var _i = 0, _a4 = Object.keys(schema4.patternProperties); _i < _a4.length; _i++) {
          var pattern = _a4[_i];
          var regex = extendedRegExp(pattern);
          if (regex.test(next)) {
            return this.getSectionRecursive(path5, schema4.patternProperties[pattern]);
          }
        }
      } else if (typeof schema4.additionalProperties === "object") {
        return this.getSectionRecursive(path5, schema4.additionalProperties);
      } else if (next.match("[0-9]+")) {
        if (Array.isArray(schema4.items)) {
          var index = parseInt(next, 10);
          if (!isNaN(index) && schema4.items[index]) {
            return this.getSectionRecursive(path5, schema4.items[index]);
          }
        } else if (schema4.items) {
          return this.getSectionRecursive(path5, schema4.items);
        }
      }
      return void 0;
    };
    return ResolvedSchema2;
  })()
);
var JSONSchemaService = (
  /** @class */
  (function() {
    function JSONSchemaService2(requestService, contextService, promiseConstructor) {
      this.contextService = contextService;
      this.requestService = requestService;
      this.promiseConstructor = promiseConstructor || Promise;
      this.callOnDispose = [];
      this.contributionSchemas = {};
      this.contributionAssociations = [];
      this.schemasById = {};
      this.filePatternAssociations = [];
      this.registeredSchemasIds = {};
    }
    JSONSchemaService2.prototype.getRegisteredSchemaIds = function(filter) {
      return Object.keys(this.registeredSchemasIds).filter(function(id) {
        var scheme = URI2.parse(id).scheme;
        return scheme !== "schemaservice" && (!filter || filter(scheme));
      });
    };
    Object.defineProperty(JSONSchemaService2.prototype, "promise", {
      get: function() {
        return this.promiseConstructor;
      },
      enumerable: false,
      configurable: true
    });
    JSONSchemaService2.prototype.dispose = function() {
      while (this.callOnDispose.length > 0) {
        this.callOnDispose.pop()();
      }
    };
    JSONSchemaService2.prototype.onResourceChange = function(uri) {
      var _this = this;
      this.cachedSchemaForResource = void 0;
      var hasChanges = false;
      uri = normalizeId(uri);
      var toWalk = [uri];
      var all = Object.keys(this.schemasById).map(function(key) {
        return _this.schemasById[key];
      });
      while (toWalk.length) {
        var curr = toWalk.pop();
        for (var i = 0; i < all.length; i++) {
          var handle = all[i];
          if (handle && (handle.url === curr || handle.dependencies[curr])) {
            if (handle.url !== curr) {
              toWalk.push(handle.url);
            }
            handle.clearSchema();
            all[i] = void 0;
            hasChanges = true;
          }
        }
      }
      return hasChanges;
    };
    JSONSchemaService2.prototype.setSchemaContributions = function(schemaContributions) {
      if (schemaContributions.schemas) {
        var schemas2 = schemaContributions.schemas;
        for (var id in schemas2) {
          var normalizedId = normalizeId(id);
          this.contributionSchemas[normalizedId] = this.addSchemaHandle(normalizedId, schemas2[id]);
        }
      }
      if (Array.isArray(schemaContributions.schemaAssociations)) {
        var schemaAssociations = schemaContributions.schemaAssociations;
        for (var _i = 0, schemaAssociations_1 = schemaAssociations; _i < schemaAssociations_1.length; _i++) {
          var schemaAssociation = schemaAssociations_1[_i];
          var uris = schemaAssociation.uris.map(normalizeId);
          var association = this.addFilePatternAssociation(schemaAssociation.pattern, uris);
          this.contributionAssociations.push(association);
        }
      }
    };
    JSONSchemaService2.prototype.addSchemaHandle = function(id, unresolvedSchemaContent) {
      var schemaHandle = new SchemaHandle(this, id, unresolvedSchemaContent);
      this.schemasById[id] = schemaHandle;
      return schemaHandle;
    };
    JSONSchemaService2.prototype.getOrAddSchemaHandle = function(id, unresolvedSchemaContent) {
      return this.schemasById[id] || this.addSchemaHandle(id, unresolvedSchemaContent);
    };
    JSONSchemaService2.prototype.addFilePatternAssociation = function(pattern, uris) {
      var fpa = new FilePatternAssociation(pattern, uris);
      this.filePatternAssociations.push(fpa);
      return fpa;
    };
    JSONSchemaService2.prototype.registerExternalSchema = function(uri, filePatterns, unresolvedSchemaContent) {
      var id = normalizeId(uri);
      this.registeredSchemasIds[id] = true;
      this.cachedSchemaForResource = void 0;
      if (filePatterns) {
        this.addFilePatternAssociation(filePatterns, [uri]);
      }
      return unresolvedSchemaContent ? this.addSchemaHandle(id, unresolvedSchemaContent) : this.getOrAddSchemaHandle(id);
    };
    JSONSchemaService2.prototype.clearExternalSchemas = function() {
      this.schemasById = {};
      this.filePatternAssociations = [];
      this.registeredSchemasIds = {};
      this.cachedSchemaForResource = void 0;
      for (var id in this.contributionSchemas) {
        this.schemasById[id] = this.contributionSchemas[id];
        this.registeredSchemasIds[id] = true;
      }
      for (var _i = 0, _a4 = this.contributionAssociations; _i < _a4.length; _i++) {
        var contributionAssociation = _a4[_i];
        this.filePatternAssociations.push(contributionAssociation);
      }
    };
    JSONSchemaService2.prototype.getResolvedSchema = function(schemaId) {
      var id = normalizeId(schemaId);
      var schemaHandle = this.schemasById[id];
      if (schemaHandle) {
        return schemaHandle.getResolvedSchema();
      }
      return this.promise.resolve(void 0);
    };
    JSONSchemaService2.prototype.loadSchema = function(url) {
      if (!this.requestService) {
        var errorMessage = localize3("json.schema.norequestservice", "Unable to load schema from '{0}'. No schema request service available", toDisplayString(url));
        return this.promise.resolve(new UnresolvedSchema({}, [errorMessage]));
      }
      return this.requestService(url).then(function(content) {
        if (!content) {
          var errorMessage2 = localize3("json.schema.nocontent", "Unable to load schema from '{0}': No content.", toDisplayString(url));
          return new UnresolvedSchema({}, [errorMessage2]);
        }
        var schemaContent = {};
        var jsonErrors = [];
        schemaContent = parse2(content, jsonErrors);
        var errors = jsonErrors.length ? [localize3("json.schema.invalidFormat", "Unable to parse content from '{0}': Parse error at offset {1}.", toDisplayString(url), jsonErrors[0].offset)] : [];
        return new UnresolvedSchema(schemaContent, errors);
      }, function(error) {
        var errorMessage2 = error.toString();
        var errorSplit = error.toString().split("Error: ");
        if (errorSplit.length > 1) {
          errorMessage2 = errorSplit[1];
        }
        if (endsWith(errorMessage2, ".")) {
          errorMessage2 = errorMessage2.substr(0, errorMessage2.length - 1);
        }
        return new UnresolvedSchema({}, [localize3("json.schema.nocontent", "Unable to load schema from '{0}': {1}.", toDisplayString(url), errorMessage2)]);
      });
    };
    JSONSchemaService2.prototype.resolveSchemaContent = function(schemaToResolve, schemaURL, dependencies) {
      var _this = this;
      var resolveErrors = schemaToResolve.errors.slice(0);
      var schema4 = schemaToResolve.schema;
      if (schema4.$schema) {
        var id = normalizeId(schema4.$schema);
        if (id === "http://json-schema.org/draft-03/schema") {
          return this.promise.resolve(new ResolvedSchema({}, [localize3("json.schema.draft03.notsupported", "Draft-03 schemas are not supported.")]));
        } else if (id === "https://json-schema.org/draft/2019-09/schema") {
          resolveErrors.push(localize3("json.schema.draft201909.notsupported", "Draft 2019-09 schemas are not yet fully supported."));
        }
      }
      var contextService = this.contextService;
      var findSection = function(schema22, path5) {
        if (!path5) {
          return schema22;
        }
        var current = schema22;
        if (path5[0] === "/") {
          path5 = path5.substr(1);
        }
        path5.split("/").some(function(part) {
          part = part.replace(/~1/g, "/").replace(/~0/g, "~");
          current = current[part];
          return !current;
        });
        return current;
      };
      var merge2 = function(target, sourceRoot, sourceURI, refSegment) {
        var path5 = refSegment ? decodeURIComponent(refSegment) : void 0;
        var section = findSection(sourceRoot, path5);
        if (section) {
          for (var key in section) {
            if (section.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
              target[key] = section[key];
            }
          }
        } else {
          resolveErrors.push(localize3("json.schema.invalidref", "$ref '{0}' in '{1}' can not be resolved.", path5, sourceURI));
        }
      };
      var resolveExternalLink = function(node, uri, refSegment, parentSchemaURL, parentSchemaDependencies) {
        if (contextService && !/^[A-Za-z][A-Za-z0-9+\-.+]*:\/\/.*/.test(uri)) {
          uri = contextService.resolveRelativePath(uri, parentSchemaURL);
        }
        uri = normalizeId(uri);
        var referencedHandle = _this.getOrAddSchemaHandle(uri);
        return referencedHandle.getUnresolvedSchema().then(function(unresolvedSchema) {
          parentSchemaDependencies[uri] = true;
          if (unresolvedSchema.errors.length) {
            var loc = refSegment ? uri + "#" + refSegment : uri;
            resolveErrors.push(localize3("json.schema.problemloadingref", "Problems loading reference '{0}': {1}", loc, unresolvedSchema.errors[0]));
          }
          merge2(node, unresolvedSchema.schema, uri, refSegment);
          return resolveRefs(node, unresolvedSchema.schema, uri, referencedHandle.dependencies);
        });
      };
      var resolveRefs = function(node, parentSchema, parentSchemaURL, parentSchemaDependencies) {
        if (!node || typeof node !== "object") {
          return Promise.resolve(null);
        }
        var toWalk = [node];
        var seen = [];
        var openPromises = [];
        var collectEntries = function() {
          var entries = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            entries[_i] = arguments[_i];
          }
          for (var _a4 = 0, entries_1 = entries; _a4 < entries_1.length; _a4++) {
            var entry = entries_1[_a4];
            if (typeof entry === "object") {
              toWalk.push(entry);
            }
          }
        };
        var collectMapEntries = function() {
          var maps = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            maps[_i] = arguments[_i];
          }
          for (var _a4 = 0, maps_1 = maps; _a4 < maps_1.length; _a4++) {
            var map2 = maps_1[_a4];
            if (typeof map2 === "object") {
              for (var k in map2) {
                var key = k;
                var entry = map2[key];
                if (typeof entry === "object") {
                  toWalk.push(entry);
                }
              }
            }
          }
        };
        var collectArrayEntries = function() {
          var arrays = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            arrays[_i] = arguments[_i];
          }
          for (var _a4 = 0, arrays_1 = arrays; _a4 < arrays_1.length; _a4++) {
            var array = arrays_1[_a4];
            if (Array.isArray(array)) {
              for (var _b2 = 0, array_1 = array; _b2 < array_1.length; _b2++) {
                var entry = array_1[_b2];
                if (typeof entry === "object") {
                  toWalk.push(entry);
                }
              }
            }
          }
        };
        var handleRef = function(next2) {
          var seenRefs = [];
          while (next2.$ref) {
            var ref = next2.$ref;
            var segments = ref.split("#", 2);
            delete next2.$ref;
            if (segments[0].length > 0) {
              openPromises.push(resolveExternalLink(next2, segments[0], segments[1], parentSchemaURL, parentSchemaDependencies));
              return;
            } else {
              if (seenRefs.indexOf(ref) === -1) {
                merge2(next2, parentSchema, parentSchemaURL, segments[1]);
                seenRefs.push(ref);
              }
            }
          }
          collectEntries(next2.items, next2.additionalItems, next2.additionalProperties, next2.not, next2.contains, next2.propertyNames, next2.if, next2.then, next2.else);
          collectMapEntries(next2.definitions, next2.properties, next2.patternProperties, next2.dependencies);
          collectArrayEntries(next2.anyOf, next2.allOf, next2.oneOf, next2.items);
        };
        while (toWalk.length) {
          var next = toWalk.pop();
          if (seen.indexOf(next) >= 0) {
            continue;
          }
          seen.push(next);
          handleRef(next);
        }
        return _this.promise.all(openPromises);
      };
      return resolveRefs(schema4, schema4, schemaURL, dependencies).then(function(_) {
        return new ResolvedSchema(schema4, resolveErrors);
      });
    };
    JSONSchemaService2.prototype.getSchemaForResource = function(resource, document2) {
      if (document2 && document2.root && document2.root.type === "object") {
        var schemaProperties = document2.root.properties.filter(function(p) {
          return p.keyNode.value === "$schema" && p.valueNode && p.valueNode.type === "string";
        });
        if (schemaProperties.length > 0) {
          var valueNode = schemaProperties[0].valueNode;
          if (valueNode && valueNode.type === "string") {
            var schemeId = getNodeValue22(valueNode);
            if (schemeId && startsWith(schemeId, ".") && this.contextService) {
              schemeId = this.contextService.resolveRelativePath(schemeId, resource);
            }
            if (schemeId) {
              var id = normalizeId(schemeId);
              return this.getOrAddSchemaHandle(id).getResolvedSchema();
            }
          }
        }
      }
      if (this.cachedSchemaForResource && this.cachedSchemaForResource.resource === resource) {
        return this.cachedSchemaForResource.resolvedSchema;
      }
      var seen = /* @__PURE__ */ Object.create(null);
      var schemas2 = [];
      var normalizedResource = normalizeResourceForMatching(resource);
      for (var _i = 0, _a4 = this.filePatternAssociations; _i < _a4.length; _i++) {
        var entry = _a4[_i];
        if (entry.matchesPattern(normalizedResource)) {
          for (var _b2 = 0, _c = entry.getURIs(); _b2 < _c.length; _b2++) {
            var schemaId = _c[_b2];
            if (!seen[schemaId]) {
              schemas2.push(schemaId);
              seen[schemaId] = true;
            }
          }
        }
      }
      var resolvedSchema = schemas2.length > 0 ? this.createCombinedSchema(resource, schemas2).getResolvedSchema() : this.promise.resolve(void 0);
      this.cachedSchemaForResource = { resource, resolvedSchema };
      return resolvedSchema;
    };
    JSONSchemaService2.prototype.createCombinedSchema = function(resource, schemaIds) {
      if (schemaIds.length === 1) {
        return this.getOrAddSchemaHandle(schemaIds[0]);
      } else {
        var combinedSchemaId = "schemaservice://combinedSchema/" + encodeURIComponent(resource);
        var combinedSchema = {
          allOf: schemaIds.map(function(schemaId) {
            return { $ref: schemaId };
          })
        };
        return this.addSchemaHandle(combinedSchemaId, combinedSchema);
      }
    };
    JSONSchemaService2.prototype.getMatchingSchemas = function(document2, jsonDocument, schema4) {
      if (schema4) {
        var id = schema4.id || "schemaservice://untitled/matchingSchemas/" + idCounter++;
        return this.resolveSchemaContent(new UnresolvedSchema(schema4), id, {}).then(function(resolvedSchema) {
          return jsonDocument.getMatchingSchemas(resolvedSchema.schema).filter(function(s) {
            return !s.inverted;
          });
        });
      }
      return this.getSchemaForResource(document2.uri, jsonDocument).then(function(schema22) {
        if (schema22) {
          return jsonDocument.getMatchingSchemas(schema22.schema).filter(function(s) {
            return !s.inverted;
          });
        }
        return [];
      });
    };
    return JSONSchemaService2;
  })()
);
var idCounter = 0;
function normalizeId(id) {
  try {
    return URI2.parse(id).toString();
  } catch (e) {
    return id;
  }
}
function normalizeResourceForMatching(resource) {
  try {
    return URI2.parse(resource).with({ fragment: null, query: null }).toString();
  } catch (e) {
    return resource;
  }
}
function toDisplayString(url) {
  try {
    var uri = URI2.parse(url);
    if (uri.scheme === "file") {
      return uri.fsPath;
    }
  } catch (e) {
  }
  return url;
}
function convertSimple2RegExpPattern(pattern) {
  return pattern.replace(/[-\\{}+?|^$.,[\]()#\s]/g, "\\$&").replace(/[*]/g, ".*");
}
function getIndentation2(lineContent, position) {
  if (lineContent.length < position) {
    return 0;
  }
  for (let i = 0; i < position; i++) {
    const char = lineContent.charCodeAt(i);
    if (char !== 32 && char !== 9) {
      return i;
    }
  }
  return position;
}
function safeCreateUnicodeRegExp(pattern) {
  try {
    return new RegExp(pattern, "u");
  } catch (ignore) {
    return new RegExp(pattern);
  }
}
function getFirstNonWhitespaceCharacterAfterOffset(str, offset) {
  offset++;
  for (let i = offset; i < str.length; i++) {
    const char = str.charAt(i);
    if (char === " " || char === "	") {
      offset++;
    } else {
      return offset;
    }
  }
  return offset;
}
function equals22(one, other) {
  if (one === other) {
    return true;
  }
  if (one === null || one === void 0 || other === null || other === void 0) {
    return false;
  }
  if (typeof one !== typeof other) {
    return false;
  }
  if (typeof one !== "object") {
    return false;
  }
  if (Array.isArray(one) !== Array.isArray(other)) {
    return false;
  }
  let i, key;
  if (Array.isArray(one)) {
    if (one.length !== other.length) {
      return false;
    }
    for (i = 0; i < one.length; i++) {
      if (!equals22(one[i], other[i])) {
        return false;
      }
    }
  } else {
    const oneKeys = [];
    for (key in one) {
      oneKeys.push(key);
    }
    oneKeys.sort();
    const otherKeys = [];
    for (key in other) {
      otherKeys.push(key);
    }
    otherKeys.sort();
    if (!equals22(oneKeys, otherKeys)) {
      return false;
    }
    for (i = 0; i < oneKeys.length; i++) {
      if (!equals22(one[oneKeys[i]], other[oneKeys[i]])) {
        return false;
      }
    }
  }
  return true;
}
function isNumber2(val) {
  return typeof val === "number";
}
function isDefined2(val) {
  return typeof val !== "undefined";
}
function isBoolean2(val) {
  return typeof val === "boolean";
}
function isString22(val) {
  return typeof val === "string";
}
function isIterable(val) {
  return Symbol.iterator in Object(val);
}
function getSchemaTypeName(schema4) {
  const closestTitleWithType = schema4.type && schema4.closestTitle;
  if (schema4.title) {
    return schema4.title;
  }
  if (schema4.$id) {
    return getSchemaRefTypeTitle(schema4.$id);
  }
  if (schema4.$ref || schema4._$ref) {
    return getSchemaRefTypeTitle(schema4.$ref || schema4._$ref);
  }
  return Array.isArray(schema4.type) ? schema4.type.join(" | ") : closestTitleWithType ? schema4.type.concat("(", schema4.closestTitle, ")") : schema4.type || schema4.closestTitle;
}
function getSchemaRefTypeTitle($ref) {
  const match = $ref.match(/^(?:.*\/)?(.*?)(?:\.schema\.json)?$/);
  let type = !!match && match[1];
  if (!type) {
    type = "typeNotFound";
    console.error(`$ref (${$ref}) not parsed properly`);
  }
  return type;
}
function getSchemaTitle(schema4, url) {
  const uri = URI2.parse(url);
  let baseName = path.basename(uri.fsPath);
  if (!path.extname(uri.fsPath)) {
    baseName += ".json";
  }
  if (Object.getOwnPropertyDescriptor(schema4, "name")) {
    return Object.getOwnPropertyDescriptor(schema4, "name").value + ` (${baseName})`;
  } else if (schema4.title) {
    return schema4.description ? schema4.title + " - " + schema4.description + ` (${baseName})` : schema4.title + ` (${baseName})`;
  }
  return baseName;
}
function isPrimitiveType(schema4) {
  return schema4.type !== "object" && !isAnyOfAllOfOneOfType(schema4);
}
function isAnyOfAllOfOneOfType(schema4) {
  return !!(schema4.anyOf || schema4.allOf || schema4.oneOf);
}
var localize4 = loadMessageBundle();
var JSONValidation = (
  /** @class */
  (function() {
    function JSONValidation2(jsonSchemaService, promiseConstructor) {
      this.jsonSchemaService = jsonSchemaService;
      this.promise = promiseConstructor;
      this.validationEnabled = true;
    }
    JSONValidation2.prototype.configure = function(raw) {
      if (raw) {
        this.validationEnabled = raw.validate !== false;
        this.commentSeverity = raw.allowComments ? void 0 : DiagnosticSeverity.Error;
      }
    };
    JSONValidation2.prototype.doValidation = function(textDocument, jsonDocument, documentSettings, schema4) {
      var _this = this;
      if (!this.validationEnabled) {
        return this.promise.resolve([]);
      }
      var diagnostics = [];
      var added = {};
      var addProblem = function(problem) {
        var signature = problem.range.start.line + " " + problem.range.start.character + " " + problem.message;
        if (!added[signature]) {
          added[signature] = true;
          diagnostics.push(problem);
        }
      };
      var getDiagnostics = function(schema22) {
        var trailingCommaSeverity = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.trailingCommas) ? toDiagnosticSeverity(documentSettings.trailingCommas) : DiagnosticSeverity.Error;
        var commentSeverity = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.comments) ? toDiagnosticSeverity(documentSettings.comments) : _this.commentSeverity;
        var schemaValidation = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.schemaValidation) ? toDiagnosticSeverity(documentSettings.schemaValidation) : DiagnosticSeverity.Warning;
        var schemaRequest = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.schemaRequest) ? toDiagnosticSeverity(documentSettings.schemaRequest) : DiagnosticSeverity.Warning;
        if (schema22) {
          if (schema22.errors.length && jsonDocument.root && schemaRequest) {
            var astRoot = jsonDocument.root;
            var property = astRoot.type === "object" ? astRoot.properties[0] : void 0;
            if (property && property.keyNode.value === "$schema") {
              var node = property.valueNode || property;
              var range = Range2.create(textDocument.positionAt(node.offset), textDocument.positionAt(node.offset + node.length));
              addProblem(Diagnostic.create(range, schema22.errors[0], schemaRequest, ErrorCode.SchemaResolveError));
            } else {
              var range = Range2.create(textDocument.positionAt(astRoot.offset), textDocument.positionAt(astRoot.offset + 1));
              addProblem(Diagnostic.create(range, schema22.errors[0], schemaRequest, ErrorCode.SchemaResolveError));
            }
          } else if (schemaValidation) {
            var semanticErrors = jsonDocument.validate(textDocument, schema22.schema, schemaValidation);
            if (semanticErrors) {
              semanticErrors.forEach(addProblem);
            }
          }
          if (schemaAllowsComments(schema22.schema)) {
            commentSeverity = void 0;
          }
          if (schemaAllowsTrailingCommas(schema22.schema)) {
            trailingCommaSeverity = void 0;
          }
        }
        for (var _i = 0, _a4 = jsonDocument.syntaxErrors; _i < _a4.length; _i++) {
          var p = _a4[_i];
          if (p.code === ErrorCode.TrailingComma) {
            if (typeof trailingCommaSeverity !== "number") {
              continue;
            }
            p.severity = trailingCommaSeverity;
          }
          addProblem(p);
        }
        if (typeof commentSeverity === "number") {
          var message_1 = localize4("InvalidCommentToken", "Comments are not permitted in JSON.");
          jsonDocument.comments.forEach(function(c) {
            addProblem(Diagnostic.create(c, message_1, commentSeverity, ErrorCode.CommentNotPermitted));
          });
        }
        return diagnostics;
      };
      if (schema4) {
        var id = schema4.id || "schemaservice://untitled/" + idCounter2++;
        return this.jsonSchemaService.resolveSchemaContent(new UnresolvedSchema(schema4), id, {}).then(function(resolvedSchema) {
          return getDiagnostics(resolvedSchema);
        });
      }
      return this.jsonSchemaService.getSchemaForResource(textDocument.uri, jsonDocument).then(function(schema22) {
        return getDiagnostics(schema22);
      });
    };
    return JSONValidation2;
  })()
);
var idCounter2 = 0;
function schemaAllowsComments(schemaRef) {
  if (schemaRef && typeof schemaRef === "object") {
    if (isBoolean(schemaRef.allowComments)) {
      return schemaRef.allowComments;
    }
    if (schemaRef.allOf) {
      for (var _i = 0, _a4 = schemaRef.allOf; _i < _a4.length; _i++) {
        var schema4 = _a4[_i];
        var allow = schemaAllowsComments(schema4);
        if (isBoolean(allow)) {
          return allow;
        }
      }
    }
  }
  return void 0;
}
function schemaAllowsTrailingCommas(schemaRef) {
  if (schemaRef && typeof schemaRef === "object") {
    if (isBoolean(schemaRef.allowTrailingCommas)) {
      return schemaRef.allowTrailingCommas;
    }
    var deprSchemaRef = schemaRef;
    if (isBoolean(deprSchemaRef["allowsTrailingCommas"])) {
      return deprSchemaRef["allowsTrailingCommas"];
    }
    if (schemaRef.allOf) {
      for (var _i = 0, _a4 = schemaRef.allOf; _i < _a4.length; _i++) {
        var schema4 = _a4[_i];
        var allow = schemaAllowsTrailingCommas(schema4);
        if (isBoolean(allow)) {
          return allow;
        }
      }
    }
  }
  return void 0;
}
function toDiagnosticSeverity(severityLevel) {
  switch (severityLevel) {
    case "error":
      return DiagnosticSeverity.Error;
    case "warning":
      return DiagnosticSeverity.Warning;
    case "ignore":
      return void 0;
  }
  return void 0;
}
var Digit0 = 48;
var Digit9 = 57;
var A = 65;
var a = 97;
var f = 102;
function hexDigit(charCode) {
  if (charCode < Digit0) {
    return 0;
  }
  if (charCode <= Digit9) {
    return charCode - Digit0;
  }
  if (charCode < a) {
    charCode += a - A;
  }
  if (charCode >= a && charCode <= f) {
    return charCode - a + 10;
  }
  return 0;
}
function colorFromHex(text) {
  if (text[0] !== "#") {
    return void 0;
  }
  switch (text.length) {
    case 4:
      return {
        red: hexDigit(text.charCodeAt(1)) * 17 / 255,
        green: hexDigit(text.charCodeAt(2)) * 17 / 255,
        blue: hexDigit(text.charCodeAt(3)) * 17 / 255,
        alpha: 1
      };
    case 5:
      return {
        red: hexDigit(text.charCodeAt(1)) * 17 / 255,
        green: hexDigit(text.charCodeAt(2)) * 17 / 255,
        blue: hexDigit(text.charCodeAt(3)) * 17 / 255,
        alpha: hexDigit(text.charCodeAt(4)) * 17 / 255
      };
    case 7:
      return {
        red: (hexDigit(text.charCodeAt(1)) * 16 + hexDigit(text.charCodeAt(2))) / 255,
        green: (hexDigit(text.charCodeAt(3)) * 16 + hexDigit(text.charCodeAt(4))) / 255,
        blue: (hexDigit(text.charCodeAt(5)) * 16 + hexDigit(text.charCodeAt(6))) / 255,
        alpha: 1
      };
    case 9:
      return {
        red: (hexDigit(text.charCodeAt(1)) * 16 + hexDigit(text.charCodeAt(2))) / 255,
        green: (hexDigit(text.charCodeAt(3)) * 16 + hexDigit(text.charCodeAt(4))) / 255,
        blue: (hexDigit(text.charCodeAt(5)) * 16 + hexDigit(text.charCodeAt(6))) / 255,
        alpha: (hexDigit(text.charCodeAt(7)) * 16 + hexDigit(text.charCodeAt(8))) / 255
      };
  }
  return void 0;
}
var JSONDocumentSymbols = (
  /** @class */
  (function() {
    function JSONDocumentSymbols2(schemaService) {
      this.schemaService = schemaService;
    }
    JSONDocumentSymbols2.prototype.findDocumentSymbols = function(document2, doc, context) {
      var _this = this;
      if (context === void 0) {
        context = { resultLimit: Number.MAX_VALUE };
      }
      var root = doc.root;
      if (!root) {
        return [];
      }
      var limit = context.resultLimit || Number.MAX_VALUE;
      var resourceString = document2.uri;
      if (resourceString === "vscode://defaultsettings/keybindings.json" || endsWith(resourceString.toLowerCase(), "/user/keybindings.json")) {
        if (root.type === "array") {
          var result_1 = [];
          for (var _i = 0, _a4 = root.items; _i < _a4.length; _i++) {
            var item = _a4[_i];
            if (item.type === "object") {
              for (var _b2 = 0, _c = item.properties; _b2 < _c.length; _b2++) {
                var property = _c[_b2];
                if (property.keyNode.value === "key" && property.valueNode) {
                  var location = Location.create(document2.uri, getRange(document2, item));
                  result_1.push({ name: getNodeValue22(property.valueNode), kind: SymbolKind2.Function, location });
                  limit--;
                  if (limit <= 0) {
                    if (context && context.onResultLimitExceeded) {
                      context.onResultLimitExceeded(resourceString);
                    }
                    return result_1;
                  }
                }
              }
            }
          }
          return result_1;
        }
      }
      var toVisit = [
        { node: root, containerName: "" }
      ];
      var nextToVisit = 0;
      var limitExceeded = false;
      var result = [];
      var collectOutlineEntries = function(node, containerName) {
        if (node.type === "array") {
          node.items.forEach(function(node2) {
            if (node2) {
              toVisit.push({ node: node2, containerName });
            }
          });
        } else if (node.type === "object") {
          node.properties.forEach(function(property2) {
            var valueNode = property2.valueNode;
            if (valueNode) {
              if (limit > 0) {
                limit--;
                var location2 = Location.create(document2.uri, getRange(document2, property2));
                var childContainerName = containerName ? containerName + "." + property2.keyNode.value : property2.keyNode.value;
                result.push({ name: _this.getKeyLabel(property2), kind: _this.getSymbolKind(valueNode.type), location: location2, containerName });
                toVisit.push({ node: valueNode, containerName: childContainerName });
              } else {
                limitExceeded = true;
              }
            }
          });
        }
      };
      while (nextToVisit < toVisit.length) {
        var next = toVisit[nextToVisit++];
        collectOutlineEntries(next.node, next.containerName);
      }
      if (limitExceeded && context && context.onResultLimitExceeded) {
        context.onResultLimitExceeded(resourceString);
      }
      return result;
    };
    JSONDocumentSymbols2.prototype.findDocumentSymbols2 = function(document2, doc, context) {
      var _this = this;
      if (context === void 0) {
        context = { resultLimit: Number.MAX_VALUE };
      }
      var root = doc.root;
      if (!root) {
        return [];
      }
      var limit = context.resultLimit || Number.MAX_VALUE;
      var resourceString = document2.uri;
      if (resourceString === "vscode://defaultsettings/keybindings.json" || endsWith(resourceString.toLowerCase(), "/user/keybindings.json")) {
        if (root.type === "array") {
          var result_2 = [];
          for (var _i = 0, _a4 = root.items; _i < _a4.length; _i++) {
            var item = _a4[_i];
            if (item.type === "object") {
              for (var _b2 = 0, _c = item.properties; _b2 < _c.length; _b2++) {
                var property = _c[_b2];
                if (property.keyNode.value === "key" && property.valueNode) {
                  var range = getRange(document2, item);
                  var selectionRange = getRange(document2, property.keyNode);
                  result_2.push({ name: getNodeValue22(property.valueNode), kind: SymbolKind2.Function, range, selectionRange });
                  limit--;
                  if (limit <= 0) {
                    if (context && context.onResultLimitExceeded) {
                      context.onResultLimitExceeded(resourceString);
                    }
                    return result_2;
                  }
                }
              }
            }
          }
          return result_2;
        }
      }
      var result = [];
      var toVisit = [
        { node: root, result }
      ];
      var nextToVisit = 0;
      var limitExceeded = false;
      var collectOutlineEntries = function(node, result2) {
        if (node.type === "array") {
          node.items.forEach(function(node2, index) {
            if (node2) {
              if (limit > 0) {
                limit--;
                var range2 = getRange(document2, node2);
                var selectionRange2 = range2;
                var name = String(index);
                var symbol = { name, kind: _this.getSymbolKind(node2.type), range: range2, selectionRange: selectionRange2, children: [] };
                result2.push(symbol);
                toVisit.push({ result: symbol.children, node: node2 });
              } else {
                limitExceeded = true;
              }
            }
          });
        } else if (node.type === "object") {
          node.properties.forEach(function(property2) {
            var valueNode = property2.valueNode;
            if (valueNode) {
              if (limit > 0) {
                limit--;
                var range2 = getRange(document2, property2);
                var selectionRange2 = getRange(document2, property2.keyNode);
                var children = [];
                var symbol = { name: _this.getKeyLabel(property2), kind: _this.getSymbolKind(valueNode.type), range: range2, selectionRange: selectionRange2, children, detail: _this.getDetail(valueNode) };
                result2.push(symbol);
                toVisit.push({ result: children, node: valueNode });
              } else {
                limitExceeded = true;
              }
            }
          });
        }
      };
      while (nextToVisit < toVisit.length) {
        var next = toVisit[nextToVisit++];
        collectOutlineEntries(next.node, next.result);
      }
      if (limitExceeded && context && context.onResultLimitExceeded) {
        context.onResultLimitExceeded(resourceString);
      }
      return result;
    };
    JSONDocumentSymbols2.prototype.getSymbolKind = function(nodeType) {
      switch (nodeType) {
        case "object":
          return SymbolKind2.Module;
        case "string":
          return SymbolKind2.String;
        case "number":
          return SymbolKind2.Number;
        case "array":
          return SymbolKind2.Array;
        case "boolean":
          return SymbolKind2.Boolean;
        default:
          return SymbolKind2.Variable;
      }
    };
    JSONDocumentSymbols2.prototype.getKeyLabel = function(property) {
      var name = property.keyNode.value;
      if (name) {
        name = name.replace(/[\n]/g, "\u21B5");
      }
      if (name && name.trim()) {
        return name;
      }
      return '"' + name + '"';
    };
    JSONDocumentSymbols2.prototype.getDetail = function(node) {
      if (!node) {
        return void 0;
      }
      if (node.type === "boolean" || node.type === "number" || node.type === "null" || node.type === "string") {
        return String(node.value);
      } else {
        if (node.type === "array") {
          return node.children.length ? void 0 : "[]";
        } else if (node.type === "object") {
          return node.children.length ? void 0 : "{}";
        }
      }
      return void 0;
    };
    JSONDocumentSymbols2.prototype.findDocumentColors = function(document2, doc, context) {
      return this.schemaService.getSchemaForResource(document2.uri, doc).then(function(schema4) {
        var result = [];
        if (schema4) {
          var limit = context && typeof context.resultLimit === "number" ? context.resultLimit : Number.MAX_VALUE;
          var matchingSchemas = doc.getMatchingSchemas(schema4.schema);
          var visitedNode = {};
          for (var _i = 0, matchingSchemas_1 = matchingSchemas; _i < matchingSchemas_1.length; _i++) {
            var s = matchingSchemas_1[_i];
            if (!s.inverted && s.schema && (s.schema.format === "color" || s.schema.format === "color-hex") && s.node && s.node.type === "string") {
              var nodeId = String(s.node.offset);
              if (!visitedNode[nodeId]) {
                var color = colorFromHex(getNodeValue22(s.node));
                if (color) {
                  var range = getRange(document2, s.node);
                  result.push({ color, range });
                }
                visitedNode[nodeId] = true;
                limit--;
                if (limit <= 0) {
                  if (context && context.onResultLimitExceeded) {
                    context.onResultLimitExceeded(document2.uri);
                  }
                  return result;
                }
              }
            }
          }
        }
        return result;
      });
    };
    JSONDocumentSymbols2.prototype.getColorPresentations = function(document2, doc, color, range) {
      var result = [];
      var red256 = Math.round(color.red * 255), green256 = Math.round(color.green * 255), blue256 = Math.round(color.blue * 255);
      function toTwoDigitHex(n) {
        var r = n.toString(16);
        return r.length !== 2 ? "0" + r : r;
      }
      var label;
      if (color.alpha === 1) {
        label = "#" + toTwoDigitHex(red256) + toTwoDigitHex(green256) + toTwoDigitHex(blue256);
      } else {
        label = "#" + toTwoDigitHex(red256) + toTwoDigitHex(green256) + toTwoDigitHex(blue256) + toTwoDigitHex(Math.round(color.alpha * 255));
      }
      result.push({ label, textEdit: TextEdit.replace(range, JSON.stringify(label)) });
      return result;
    };
    return JSONDocumentSymbols2;
  })()
);
function getRange(document2, node) {
  return Range2.create(document2.positionAt(node.offset), document2.positionAt(node.offset + node.length));
}
function findLinks(document2, doc) {
  var links = [];
  doc.visit(function(node) {
    var _a4;
    if (node.type === "property" && node.keyNode.value === "$ref" && ((_a4 = node.valueNode) === null || _a4 === void 0 ? void 0 : _a4.type) === "string") {
      var path5 = node.valueNode.value;
      var targetNode = findTargetNode(doc, path5);
      if (targetNode) {
        var targetPos = document2.positionAt(targetNode.offset);
        links.push({
          target: document2.uri + "#" + (targetPos.line + 1) + "," + (targetPos.character + 1),
          range: createRange(document2, node.valueNode)
        });
      }
    }
    return true;
  });
  return Promise.resolve(links);
}
function createRange(document2, node) {
  return Range2.create(document2.positionAt(node.offset + 1), document2.positionAt(node.offset + node.length - 1));
}
function findTargetNode(doc, path5) {
  var tokens = parseJSONPointer(path5);
  if (!tokens) {
    return null;
  }
  return findNode(tokens, doc.root);
}
function findNode(pointer, node) {
  if (!node) {
    return null;
  }
  if (pointer.length === 0) {
    return node;
  }
  var token = pointer.shift();
  if (node && node.type === "object") {
    var propertyNode = node.properties.find(function(propertyNode2) {
      return propertyNode2.keyNode.value === token;
    });
    if (!propertyNode) {
      return null;
    }
    return findNode(pointer, propertyNode.valueNode);
  } else if (node && node.type === "array") {
    if (token.match(/^(0|[1-9][0-9]*)$/)) {
      var index = Number.parseInt(token);
      var arrayItem = node.items[index];
      if (!arrayItem) {
        return null;
      }
      return findNode(pointer, arrayItem);
    }
  }
  return null;
}
function parseJSONPointer(path5) {
  if (path5 === "#") {
    return [];
  }
  if (path5[0] !== "#" || path5[1] !== "/") {
    return null;
  }
  return path5.substring(2).split(/\//).map(unescape);
}
function unescape(str) {
  return str.replace(/~1/g, "/").replace(/~0/g, "~");
}
function matchOffsetToDocument(offset, jsonDocuments) {
  for (const jsonDoc of jsonDocuments.documents) {
    if (jsonDoc.internalDocument && jsonDoc.internalDocument.range[0] <= offset && jsonDoc.internalDocument.range[2] >= offset) {
      return jsonDoc;
    }
  }
  if (jsonDocuments.documents.length === 1) {
    return jsonDocuments.documents[0];
  }
  return null;
}
function filterInvalidCustomTags(customTags) {
  const validCustomTags = ["mapping", "scalar", "sequence"];
  if (!customTags) {
    return [];
  }
  return customTags.filter((tag) => {
    if (typeof tag === "string") {
      const typeInfo = tag.split(" ");
      const type = typeInfo[1] && typeInfo[1].toLowerCase() || "scalar";
      if (type === "map") {
        return false;
      }
      return validCustomTags.indexOf(type) !== -1;
    }
    return false;
  });
}
function isArrayEqual(fst, snd) {
  if (!snd || !fst) {
    return false;
  }
  if (snd.length !== fst.length) {
    return false;
  }
  for (let index = fst.length - 1; index >= 0; index--) {
    if (fst[index] !== snd[index]) {
      return false;
    }
  }
  return true;
}
var localize5 = loadMessageBundle();
var MSG_PROPERTY_NOT_ALLOWED = "Property {0} is not allowed.";
var formats2 = {
  "color-hex": {
    errorMessage: localize5("colorHexFormatWarning", "Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA."),
    pattern: /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/
  },
  "date-time": {
    errorMessage: localize5("dateTimeFormatWarning", "String is not a RFC3339 date-time."),
    pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i
  },
  date: {
    errorMessage: localize5("dateFormatWarning", "String is not a RFC3339 date."),
    pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/i
  },
  time: {
    errorMessage: localize5("timeFormatWarning", "String is not a RFC3339 time."),
    pattern: /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i
  },
  email: {
    errorMessage: localize5("emailFormatWarning", "String is not an e-mail address."),
    pattern: /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
  },
  ipv4: {
    errorMessage: localize5("ipv4FormatWarning", "String does not match IPv4 format."),
    pattern: /^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}$/
  },
  ipv6: {
    errorMessage: localize5("ipv6FormatWarning", "String does not match IPv6 format."),
    pattern: /^([0-9a-f]|:){1,4}(:([0-9a-f]{0,4})*){1,7}$/i
  }
};
var YAML_SOURCE = "YAML";
var YAML_SCHEMA_PREFIX = "yaml-schema: ";
var ProblemType;
(function(ProblemType2) {
  ProblemType2["missingRequiredPropWarning"] = "missingRequiredPropWarning";
  ProblemType2["typeMismatchWarning"] = "typeMismatchWarning";
  ProblemType2["constWarning"] = "constWarning";
})(ProblemType || (ProblemType = {}));
var ProblemTypeMessages = {
  [ProblemType.missingRequiredPropWarning]: 'Missing property "{0}".',
  [ProblemType.typeMismatchWarning]: 'Incorrect type. Expected "{0}".',
  [ProblemType.constWarning]: "Value must be {0}."
};
var ASTNodeImpl2 = class {
  constructor(parent, internalNode, offset, length) {
    this.offset = offset;
    this.length = length;
    this.parent = parent;
    this.internalNode = internalNode;
  }
  getNodeFromOffsetEndInclusive(offset) {
    const collector = [];
    const findNode2 = (node) => {
      if (offset >= node.offset && offset <= node.offset + node.length) {
        const children = node.children;
        for (let i = 0; i < children.length && children[i].offset <= offset; i++) {
          const item = findNode2(children[i]);
          if (item) {
            collector.push(item);
          }
        }
        return node;
      }
      return null;
    };
    const foundNode = findNode2(this);
    let currMinDist = Number.MAX_VALUE;
    let currMinNode = null;
    for (const currNode of collector) {
      const minDist = currNode.length + currNode.offset - offset + (offset - currNode.offset);
      if (minDist < currMinDist) {
        currMinNode = currNode;
        currMinDist = minDist;
      }
    }
    return currMinNode || foundNode;
  }
  get children() {
    return [];
  }
  toString() {
    return "type: " + this.type + " (" + this.offset + "/" + this.length + ")" + (this.parent ? " parent: {" + this.parent.toString() + "}" : "");
  }
};
var NullASTNodeImpl2 = class extends ASTNodeImpl2 {
  constructor(parent, internalNode, offset, length) {
    super(parent, internalNode, offset, length);
    this.type = "null";
    this.value = null;
  }
};
var BooleanASTNodeImpl2 = class extends ASTNodeImpl2 {
  constructor(parent, internalNode, boolValue, offset, length) {
    super(parent, internalNode, offset, length);
    this.type = "boolean";
    this.value = boolValue;
  }
};
var ArrayASTNodeImpl2 = class extends ASTNodeImpl2 {
  constructor(parent, internalNode, offset, length) {
    super(parent, internalNode, offset, length);
    this.type = "array";
    this.items = [];
  }
  get children() {
    return this.items;
  }
};
var NumberASTNodeImpl2 = class extends ASTNodeImpl2 {
  constructor(parent, internalNode, offset, length) {
    super(parent, internalNode, offset, length);
    this.type = "number";
    this.isInteger = true;
    this.value = Number.NaN;
  }
};
var StringASTNodeImpl2 = class extends ASTNodeImpl2 {
  constructor(parent, internalNode, offset, length) {
    super(parent, internalNode, offset, length);
    this.type = "string";
    this.value = "";
  }
};
var PropertyASTNodeImpl2 = class extends ASTNodeImpl2 {
  constructor(parent, internalNode, offset, length) {
    super(parent, internalNode, offset, length);
    this.type = "property";
    this.colonOffset = -1;
  }
  get children() {
    return this.valueNode ? [this.keyNode, this.valueNode] : [this.keyNode];
  }
};
var ObjectASTNodeImpl2 = class extends ASTNodeImpl2 {
  constructor(parent, internalNode, offset, length) {
    super(parent, internalNode, offset, length);
    this.type = "object";
    this.properties = [];
  }
  get children() {
    return this.properties;
  }
};
function asSchema2(schema4) {
  if (schema4 === void 0) {
    return void 0;
  }
  if (isBoolean2(schema4)) {
    return schema4 ? {} : { not: {} };
  }
  if (typeof schema4 !== "object") {
    console.warn(`Wrong schema: ${JSON.stringify(schema4)}, it MUST be an Object or Boolean`);
    schema4 = {
      type: schema4
    };
  }
  return schema4;
}
var EnumMatch2;
(function(EnumMatch3) {
  EnumMatch3[EnumMatch3["Key"] = 0] = "Key";
  EnumMatch3[EnumMatch3["Enum"] = 1] = "Enum";
})(EnumMatch2 || (EnumMatch2 = {}));
var SchemaCollector2 = class _SchemaCollector {
  constructor(focusOffset = -1, exclude = null) {
    this.focusOffset = focusOffset;
    this.exclude = exclude;
    this.schemas = [];
  }
  add(schema4) {
    this.schemas.push(schema4);
  }
  merge(other) {
    this.schemas.push(...other.schemas);
  }
  include(node) {
    return (this.focusOffset === -1 || contains22(node, this.focusOffset)) && node !== this.exclude;
  }
  newSub() {
    return new _SchemaCollector(-1, this.exclude);
  }
};
var NoOpSchemaCollector2 = class {
  constructor() {
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get schemas() {
    return [];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  add(schema4) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  merge(other) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  include(node) {
    return true;
  }
  newSub() {
    return this;
  }
};
NoOpSchemaCollector2.instance = new NoOpSchemaCollector2();
var ValidationResult2 = class {
  constructor(isKubernetes) {
    this.problems = [];
    this.propertiesMatches = 0;
    this.propertiesValueMatches = 0;
    this.primaryValueMatches = 0;
    this.enumValueMatch = false;
    if (isKubernetes) {
      this.enumValues = [];
    } else {
      this.enumValues = null;
    }
  }
  hasProblems() {
    return !!this.problems.length;
  }
  mergeAll(validationResults) {
    for (const validationResult of validationResults) {
      this.merge(validationResult);
    }
  }
  merge(validationResult) {
    this.problems = this.problems.concat(validationResult.problems);
  }
  mergeEnumValues(validationResult) {
    if (!this.enumValueMatch && !validationResult.enumValueMatch && this.enumValues && validationResult.enumValues) {
      this.enumValues = this.enumValues.concat(validationResult.enumValues);
      for (const error of this.problems) {
        if (error.code === ErrorCode.EnumValueMismatch) {
          error.message = localize5("enumWarning", "Value is not accepted. Valid values: {0}.", [...new Set(this.enumValues)].map((v) => {
            return JSON.stringify(v);
          }).join(", "));
        }
      }
    }
  }
  /**
   * Merge multiple warnings with same problemType together
   * @param subValidationResult another possible result
   */
  mergeWarningGeneric(subValidationResult, problemTypesToMerge) {
    var _a4, _b2, _c;
    if ((_a4 = this.problems) == null ? void 0 : _a4.length) {
      for (const problemType of problemTypesToMerge) {
        const bestResults = this.problems.filter((p) => p.problemType === problemType);
        for (const bestResult of bestResults) {
          const mergingResult = (_b2 = subValidationResult.problems) == null ? void 0 : _b2.find(
            (p) => p.problemType === problemType && bestResult.location.offset === p.location.offset && (problemType !== ProblemType.missingRequiredPropWarning || isArrayEqual(p.problemArgs, bestResult.problemArgs))
          );
          if (mergingResult) {
            if ((_c = mergingResult.problemArgs) == null ? void 0 : _c.length) {
              mergingResult.problemArgs.filter((p) => !bestResult.problemArgs.includes(p)).forEach((p) => bestResult.problemArgs.push(p));
              bestResult.message = getWarningMessage(bestResult.problemType, bestResult.problemArgs);
            }
            this.mergeSources(mergingResult, bestResult);
          }
        }
      }
    }
  }
  mergePropertyMatch(propertyValidationResult) {
    this.merge(propertyValidationResult);
    this.propertiesMatches++;
    if (propertyValidationResult.enumValueMatch || !propertyValidationResult.hasProblems() && propertyValidationResult.propertiesMatches) {
      this.propertiesValueMatches++;
    }
    if (propertyValidationResult.enumValueMatch && propertyValidationResult.enumValues) {
      this.primaryValueMatches++;
    }
  }
  mergeSources(mergingResult, bestResult) {
    const mergingSource = mergingResult.source.replace(YAML_SCHEMA_PREFIX, "");
    if (!bestResult.source.includes(mergingSource)) {
      bestResult.source = bestResult.source + " | " + mergingSource;
    }
    if (!bestResult.schemaUri.includes(mergingResult.schemaUri[0])) {
      bestResult.schemaUri = bestResult.schemaUri.concat(mergingResult.schemaUri);
    }
  }
  compareGeneric(other) {
    const hasProblems = this.hasProblems();
    if (hasProblems !== other.hasProblems()) {
      return hasProblems ? -1 : 1;
    }
    if (this.enumValueMatch !== other.enumValueMatch) {
      return other.enumValueMatch ? -1 : 1;
    }
    if (this.propertiesValueMatches !== other.propertiesValueMatches) {
      return this.propertiesValueMatches - other.propertiesValueMatches;
    }
    if (this.primaryValueMatches !== other.primaryValueMatches) {
      return this.primaryValueMatches - other.primaryValueMatches;
    }
    return this.propertiesMatches - other.propertiesMatches;
  }
  compareKubernetes(other) {
    const hasProblems = this.hasProblems();
    if (this.propertiesMatches !== other.propertiesMatches) {
      return this.propertiesMatches - other.propertiesMatches;
    }
    if (this.enumValueMatch !== other.enumValueMatch) {
      return other.enumValueMatch ? -1 : 1;
    }
    if (this.primaryValueMatches !== other.primaryValueMatches) {
      return this.primaryValueMatches - other.primaryValueMatches;
    }
    if (this.propertiesValueMatches !== other.propertiesValueMatches) {
      return this.propertiesValueMatches - other.propertiesValueMatches;
    }
    if (hasProblems !== other.hasProblems()) {
      return hasProblems ? -1 : 1;
    }
    return this.propertiesMatches - other.propertiesMatches;
  }
};
function getNodeValue3(node) {
  switch (node.type) {
    case "array":
      return node.children.map(getNodeValue3);
    case "object": {
      const obj = /* @__PURE__ */ Object.create(null);
      for (let _i = 0, _a4 = node.children; _i < _a4.length; _i++) {
        const prop = _a4[_i];
        const valueNode = prop.children[1];
        if (valueNode) {
          obj[prop.children[0].value] = getNodeValue3(valueNode);
        }
      }
      return obj;
    }
    case "null":
    case "string":
    case "number":
    case "boolean":
      return node.value;
    default:
      return void 0;
  }
}
function contains22(node, offset, includeRightBound = false) {
  return offset >= node.offset && offset <= node.offset + node.length || includeRightBound && offset === node.offset + node.length;
}
function findNodeAtOffset22(node, offset, includeRightBound) {
  if (includeRightBound === void 0) {
    includeRightBound = false;
  }
  if (contains22(node, offset, includeRightBound)) {
    const children = node.children;
    if (Array.isArray(children)) {
      for (let i = 0; i < children.length && children[i].offset <= offset; i++) {
        const item = findNodeAtOffset22(children[i], offset, includeRightBound);
        if (item) {
          return item;
        }
      }
    }
    return node;
  }
  return void 0;
}
var JSONDocument2 = class {
  constructor(root, syntaxErrors = [], comments = []) {
    this.root = root;
    this.syntaxErrors = syntaxErrors;
    this.comments = comments;
  }
  getNodeFromOffset(offset, includeRightBound = false) {
    if (this.root) {
      return findNodeAtOffset22(this.root, offset, includeRightBound);
    }
    return void 0;
  }
  getNodeFromOffsetEndInclusive(offset) {
    return this.root && this.root.getNodeFromOffsetEndInclusive(offset);
  }
  visit(visitor) {
    if (this.root) {
      const doVisit = (node) => {
        let ctn = visitor(node);
        const children = node.children;
        if (Array.isArray(children)) {
          for (let i = 0; i < children.length && ctn; i++) {
            ctn = doVisit(children[i]);
          }
        }
        return ctn;
      };
      doVisit(this.root);
    }
  }
  validate(textDocument, schema4) {
    if (this.root && schema4) {
      const validationResult = new ValidationResult2(this.isKubernetes);
      validate2(this.root, schema4, schema4, validationResult, NoOpSchemaCollector2.instance, {
        isKubernetes: this.isKubernetes,
        disableAdditionalProperties: this.disableAdditionalProperties,
        uri: this.uri
      });
      return validationResult.problems.map((p) => {
        const range = Range2.create(textDocument.positionAt(p.location.offset), textDocument.positionAt(p.location.offset + p.location.length));
        const diagnostic = Diagnostic.create(range, p.message, p.severity, p.code ? p.code : ErrorCode.Undefined, p.source);
        diagnostic.data = { schemaUri: p.schemaUri, ...p.data };
        return diagnostic;
      });
    }
    return null;
  }
  /**
   * This method returns the list of applicable schemas
   *
   * currently used @param didCallFromAutoComplete flag to differentiate the method call, when it is from auto complete
   * then user still types something and skip the validation for timebeing untill completed.
   * On https://github.com/redhat-developer/yaml-language-server/pull/719 the auto completes need to populate the list of enum string which matches to the enum
   * and on https://github.com/redhat-developer/vscode-yaml/issues/803 the validation should throw the error based on the enum string.
   *
   * @param schema schema
   * @param focusOffset  offsetValue
   * @param exclude excluded Node
   * @param didCallFromAutoComplete true if method called from AutoComplete
   * @returns array of applicable schemas
   */
  getMatchingSchemas(schema4, focusOffset = -1, exclude = null, didCallFromAutoComplete) {
    const matchingSchemas = new SchemaCollector2(focusOffset, exclude);
    if (this.root && schema4) {
      validate2(this.root, schema4, schema4, new ValidationResult2(this.isKubernetes), matchingSchemas, {
        isKubernetes: this.isKubernetes,
        disableAdditionalProperties: this.disableAdditionalProperties,
        uri: this.uri,
        callFromAutoComplete: didCallFromAutoComplete
      });
    }
    return matchingSchemas.schemas;
  }
};
function validate2(node, schema4, originalSchema, validationResult, matchingSchemas, options) {
  const { isKubernetes, callFromAutoComplete } = options;
  if (!node) {
    return;
  }
  if (typeof schema4 !== "object") {
    return;
  }
  if (!schema4.url) {
    schema4.url = originalSchema.url;
  }
  schema4.closestTitle = schema4.title || originalSchema.closestTitle;
  switch (node.type) {
    case "object":
      _validateObjectNode(node, schema4, validationResult, matchingSchemas);
      break;
    case "array":
      _validateArrayNode(node, schema4, validationResult, matchingSchemas);
      break;
    case "string":
      _validateStringNode(node, schema4, validationResult);
      break;
    case "number":
      _validateNumberNode(node, schema4, validationResult);
      break;
    case "property":
      return validate2(node.valueNode, schema4, schema4, validationResult, matchingSchemas, options);
  }
  _validateNode();
  matchingSchemas.add({ node, schema: schema4 });
  function _validateNode() {
    function matchesType(type) {
      return node.type === type || type === "integer" && node.type === "number" && node.isInteger;
    }
    if (Array.isArray(schema4.type)) {
      if (!schema4.type.some(matchesType)) {
        validationResult.problems.push({
          location: { offset: node.offset, length: node.length },
          severity: DiagnosticSeverity.Warning,
          message: schema4.errorMessage || localize5("typeArrayMismatchWarning", "Incorrect type. Expected one of {0}.", schema4.type.join(", ")),
          source: getSchemaSource(schema4, originalSchema),
          schemaUri: getSchemaUri(schema4, originalSchema)
        });
      }
    } else if (schema4.type) {
      if (!matchesType(schema4.type)) {
        const schemaType = schema4.type === "object" ? getSchemaTypeName(schema4) : schema4.type;
        validationResult.problems.push({
          location: { offset: node.offset, length: node.length },
          severity: DiagnosticSeverity.Warning,
          message: schema4.errorMessage || getWarningMessage(ProblemType.typeMismatchWarning, [schemaType]),
          source: getSchemaSource(schema4, originalSchema),
          schemaUri: getSchemaUri(schema4, originalSchema),
          problemType: ProblemType.typeMismatchWarning,
          problemArgs: [schemaType]
        });
      }
    }
    if (Array.isArray(schema4.allOf)) {
      for (const subSchemaRef of schema4.allOf) {
        validate2(node, asSchema2(subSchemaRef), schema4, validationResult, matchingSchemas, options);
      }
    }
    const notSchema = asSchema2(schema4.not);
    if (notSchema) {
      const subValidationResult = new ValidationResult2(isKubernetes);
      const subMatchingSchemas = matchingSchemas.newSub();
      validate2(node, notSchema, schema4, subValidationResult, subMatchingSchemas, options);
      if (!subValidationResult.hasProblems()) {
        validationResult.problems.push({
          location: { offset: node.offset, length: node.length },
          severity: DiagnosticSeverity.Warning,
          message: localize5("notSchemaWarning", "Matches a schema that is not allowed."),
          source: getSchemaSource(schema4, originalSchema),
          schemaUri: getSchemaUri(schema4, originalSchema)
        });
      }
      for (const ms of subMatchingSchemas.schemas) {
        ms.inverted = !ms.inverted;
        matchingSchemas.add(ms);
      }
    }
    const testAlternatives = (alternatives, maxOneMatch) => {
      var _a4;
      const matches = [];
      const subMatches = [];
      const noPropertyMatches = [];
      let bestMatch = null;
      for (const subSchemaRef of alternatives) {
        const subSchema = { ...asSchema2(subSchemaRef) };
        const subValidationResult = new ValidationResult2(isKubernetes);
        const subMatchingSchemas = matchingSchemas.newSub();
        validate2(node, subSchema, schema4, subValidationResult, subMatchingSchemas, options);
        if (!subValidationResult.hasProblems() || callFromAutoComplete) {
          matches.push(subSchema);
          subMatches.push(subSchema);
          if (subValidationResult.propertiesMatches === 0) {
            noPropertyMatches.push(subSchema);
          }
          if (subSchema.format) {
            subMatches.pop();
          }
        }
        if (!bestMatch) {
          bestMatch = {
            schema: subSchema,
            validationResult: subValidationResult,
            matchingSchemas: subMatchingSchemas
          };
        } else if (isKubernetes) {
          bestMatch = alternativeComparison(subValidationResult, bestMatch, subSchema, subMatchingSchemas);
        } else {
          bestMatch = genericComparison(node, maxOneMatch, subValidationResult, bestMatch, subSchema, subMatchingSchemas);
        }
      }
      if (subMatches.length > 1 && (subMatches.length > 1 || noPropertyMatches.length === 0) && maxOneMatch) {
        validationResult.problems.push({
          location: { offset: node.offset, length: 1 },
          severity: DiagnosticSeverity.Warning,
          message: localize5("oneOfWarning", "Matches multiple schemas when only one must validate."),
          source: getSchemaSource(schema4, originalSchema),
          schemaUri: getSchemaUri(schema4, originalSchema)
        });
      }
      if (bestMatch !== null) {
        validationResult.merge(bestMatch.validationResult);
        validationResult.propertiesMatches += bestMatch.validationResult.propertiesMatches;
        validationResult.propertiesValueMatches += bestMatch.validationResult.propertiesValueMatches;
        validationResult.enumValueMatch = validationResult.enumValueMatch || bestMatch.validationResult.enumValueMatch;
        if ((_a4 = bestMatch.validationResult.enumValues) == null ? void 0 : _a4.length) {
          validationResult.enumValues = (validationResult.enumValues || []).concat(bestMatch.validationResult.enumValues);
        }
        matchingSchemas.merge(bestMatch.matchingSchemas);
      }
      return matches.length;
    };
    if (Array.isArray(schema4.anyOf)) {
      testAlternatives(schema4.anyOf, false);
    }
    if (Array.isArray(schema4.oneOf)) {
      testAlternatives(schema4.oneOf, true);
    }
    const testBranch = (schema22, originalSchema2) => {
      const subValidationResult = new ValidationResult2(isKubernetes);
      const subMatchingSchemas = matchingSchemas.newSub();
      validate2(node, asSchema2(schema22), originalSchema2, subValidationResult, subMatchingSchemas, options);
      validationResult.merge(subValidationResult);
      validationResult.propertiesMatches += subValidationResult.propertiesMatches;
      validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;
      matchingSchemas.merge(subMatchingSchemas);
    };
    const testCondition = (ifSchema2, originalSchema2, thenSchema, elseSchema) => {
      const subSchema = asSchema2(ifSchema2);
      const subValidationResult = new ValidationResult2(isKubernetes);
      const subMatchingSchemas = matchingSchemas.newSub();
      validate2(node, subSchema, originalSchema2, subValidationResult, subMatchingSchemas, options);
      matchingSchemas.merge(subMatchingSchemas);
      const { filePatternAssociation } = subSchema;
      if (filePatternAssociation) {
        const association = new FilePatternAssociation2(filePatternAssociation);
        if (!association.matchesPattern(options.uri)) {
          subValidationResult.problems.push({
            location: { offset: node.offset, length: node.length },
            severity: DiagnosticSeverity.Warning,
            message: localize5("ifFilePatternAssociation", `filePatternAssociation '${filePatternAssociation}' does not match with doc uri '${options.uri}'.`),
            source: getSchemaSource(schema4, originalSchema2),
            schemaUri: getSchemaUri(schema4, originalSchema2)
          });
        }
      }
      if (!subValidationResult.hasProblems()) {
        if (thenSchema) {
          testBranch(thenSchema, originalSchema2);
        }
      } else if (elseSchema) {
        testBranch(elseSchema, originalSchema2);
      }
    };
    const ifSchema = asSchema2(schema4.if);
    if (ifSchema) {
      testCondition(ifSchema, schema4, asSchema2(schema4.then), asSchema2(schema4.else));
    }
    if (Array.isArray(schema4.enum)) {
      const val = getNodeValue3(node);
      let enumValueMatch = false;
      for (const e of schema4.enum) {
        if (equals22(val, e) || callFromAutoComplete && isString22(val) && isString22(e) && val && e.startsWith(val)) {
          enumValueMatch = true;
          break;
        }
      }
      validationResult.enumValues = schema4.enum;
      validationResult.enumValueMatch = enumValueMatch;
      if (!enumValueMatch) {
        validationResult.problems.push({
          location: { offset: node.offset, length: node.length },
          severity: DiagnosticSeverity.Warning,
          code: ErrorCode.EnumValueMismatch,
          message: schema4.errorMessage || localize5("enumWarning", "Value is not accepted. Valid values: {0}.", schema4.enum.map((v) => {
            return JSON.stringify(v);
          }).join(", ")),
          source: getSchemaSource(schema4, originalSchema),
          schemaUri: getSchemaUri(schema4, originalSchema),
          data: { values: schema4.enum }
        });
      }
    }
    if (isDefined2(schema4.const)) {
      const val = getNodeValue3(node);
      if (!equals22(val, schema4.const) && !(callFromAutoComplete && isString22(val) && isString22(schema4.const) && schema4.const.startsWith(val))) {
        validationResult.problems.push({
          location: { offset: node.offset, length: node.length },
          severity: DiagnosticSeverity.Warning,
          code: ErrorCode.EnumValueMismatch,
          problemType: ProblemType.constWarning,
          message: schema4.errorMessage || getWarningMessage(ProblemType.constWarning, [JSON.stringify(schema4.const)]),
          source: getSchemaSource(schema4, originalSchema),
          schemaUri: getSchemaUri(schema4, originalSchema),
          problemArgs: [JSON.stringify(schema4.const)],
          data: { values: [schema4.const] }
        });
        validationResult.enumValueMatch = false;
      } else {
        validationResult.enumValueMatch = true;
      }
      validationResult.enumValues = [schema4.const];
    }
    if (schema4.deprecationMessage && node.parent) {
      validationResult.problems.push({
        location: { offset: node.parent.offset, length: node.parent.length },
        severity: DiagnosticSeverity.Warning,
        message: schema4.deprecationMessage,
        source: getSchemaSource(schema4, originalSchema),
        schemaUri: getSchemaUri(schema4, originalSchema)
      });
    }
  }
  function _validateNumberNode(node2, schema22, validationResult2) {
    const val = node2.value;
    if (isNumber2(schema22.multipleOf)) {
      if (val % schema22.multipleOf !== 0) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          severity: DiagnosticSeverity.Warning,
          message: localize5("multipleOfWarning", "Value is not divisible by {0}.", schema22.multipleOf),
          source: getSchemaSource(schema22, originalSchema),
          schemaUri: getSchemaUri(schema22, originalSchema)
        });
      }
    }
    function getExclusiveLimit(limit, exclusive) {
      if (isNumber2(exclusive)) {
        return exclusive;
      }
      if (isBoolean2(exclusive) && exclusive) {
        return limit;
      }
      return void 0;
    }
    function getLimit(limit, exclusive) {
      if (!isBoolean2(exclusive) || !exclusive) {
        return limit;
      }
      return void 0;
    }
    const exclusiveMinimum = getExclusiveLimit(schema22.minimum, schema22.exclusiveMinimum);
    if (isNumber2(exclusiveMinimum) && val <= exclusiveMinimum) {
      validationResult2.problems.push({
        location: { offset: node2.offset, length: node2.length },
        severity: DiagnosticSeverity.Warning,
        message: localize5("exclusiveMinimumWarning", "Value is below the exclusive minimum of {0}.", exclusiveMinimum),
        source: getSchemaSource(schema22, originalSchema),
        schemaUri: getSchemaUri(schema22, originalSchema)
      });
    }
    const exclusiveMaximum = getExclusiveLimit(schema22.maximum, schema22.exclusiveMaximum);
    if (isNumber2(exclusiveMaximum) && val >= exclusiveMaximum) {
      validationResult2.problems.push({
        location: { offset: node2.offset, length: node2.length },
        severity: DiagnosticSeverity.Warning,
        message: localize5("exclusiveMaximumWarning", "Value is above the exclusive maximum of {0}.", exclusiveMaximum),
        source: getSchemaSource(schema22, originalSchema),
        schemaUri: getSchemaUri(schema22, originalSchema)
      });
    }
    const minimum = getLimit(schema22.minimum, schema22.exclusiveMinimum);
    if (isNumber2(minimum) && val < minimum) {
      validationResult2.problems.push({
        location: { offset: node2.offset, length: node2.length },
        severity: DiagnosticSeverity.Warning,
        message: localize5("minimumWarning", "Value is below the minimum of {0}.", minimum),
        source: getSchemaSource(schema22, originalSchema),
        schemaUri: getSchemaUri(schema22, originalSchema)
      });
    }
    const maximum = getLimit(schema22.maximum, schema22.exclusiveMaximum);
    if (isNumber2(maximum) && val > maximum) {
      validationResult2.problems.push({
        location: { offset: node2.offset, length: node2.length },
        severity: DiagnosticSeverity.Warning,
        message: localize5("maximumWarning", "Value is above the maximum of {0}.", maximum),
        source: getSchemaSource(schema22, originalSchema),
        schemaUri: getSchemaUri(schema22, originalSchema)
      });
    }
  }
  function _validateStringNode(node2, schema22, validationResult2) {
    if (isNumber2(schema22.minLength) && node2.value.length < schema22.minLength) {
      validationResult2.problems.push({
        location: { offset: node2.offset, length: node2.length },
        severity: DiagnosticSeverity.Warning,
        message: localize5("minLengthWarning", "String is shorter than the minimum length of {0}.", schema22.minLength),
        source: getSchemaSource(schema22, originalSchema),
        schemaUri: getSchemaUri(schema22, originalSchema)
      });
    }
    if (isNumber2(schema22.maxLength) && node2.value.length > schema22.maxLength) {
      validationResult2.problems.push({
        location: { offset: node2.offset, length: node2.length },
        severity: DiagnosticSeverity.Warning,
        message: localize5("maxLengthWarning", "String is longer than the maximum length of {0}.", schema22.maxLength),
        source: getSchemaSource(schema22, originalSchema),
        schemaUri: getSchemaUri(schema22, originalSchema)
      });
    }
    if (isString22(schema22.pattern)) {
      const regex = safeCreateUnicodeRegExp(schema22.pattern);
      if (!regex.test(node2.value)) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          severity: DiagnosticSeverity.Warning,
          message: schema22.patternErrorMessage || schema22.errorMessage || localize5("patternWarning", 'String does not match the pattern of "{0}".', schema22.pattern),
          source: getSchemaSource(schema22, originalSchema),
          schemaUri: getSchemaUri(schema22, originalSchema)
        });
      }
    }
    if (schema22.format) {
      switch (schema22.format) {
        case "uri":
        case "uri-reference":
          {
            let errorMessage;
            if (!node2.value) {
              errorMessage = localize5("uriEmpty", "URI expected.");
            } else {
              try {
                const uri = URI2.parse(node2.value);
                if (!uri.scheme && schema22.format === "uri") {
                  errorMessage = localize5("uriSchemeMissing", "URI with a scheme is expected.");
                }
              } catch (e) {
                errorMessage = e.message;
              }
            }
            if (errorMessage) {
              validationResult2.problems.push({
                location: { offset: node2.offset, length: node2.length },
                severity: DiagnosticSeverity.Warning,
                message: schema22.patternErrorMessage || schema22.errorMessage || localize5("uriFormatWarning", "String is not a URI: {0}", errorMessage),
                source: getSchemaSource(schema22, originalSchema),
                schemaUri: getSchemaUri(schema22, originalSchema)
              });
            }
          }
          break;
        case "color-hex":
        case "date-time":
        case "date":
        case "time":
        case "email":
        case "ipv4":
        case "ipv6":
          {
            const format22 = formats2[schema22.format];
            if (!node2.value || !format22.pattern.test(node2.value)) {
              validationResult2.problems.push({
                location: { offset: node2.offset, length: node2.length },
                severity: DiagnosticSeverity.Warning,
                message: schema22.patternErrorMessage || schema22.errorMessage || format22.errorMessage,
                source: getSchemaSource(schema22, originalSchema),
                schemaUri: getSchemaUri(schema22, originalSchema)
              });
            }
          }
          break;
        default:
      }
    }
  }
  function _validateArrayNode(node2, schema22, validationResult2, matchingSchemas2) {
    if (Array.isArray(schema22.items)) {
      const subSchemas = schema22.items;
      for (let index = 0; index < subSchemas.length; index++) {
        const subSchemaRef = subSchemas[index];
        const subSchema = asSchema2(subSchemaRef);
        const itemValidationResult = new ValidationResult2(isKubernetes);
        const item = node2.items[index];
        if (item) {
          validate2(item, subSchema, schema22, itemValidationResult, matchingSchemas2, options);
          validationResult2.mergePropertyMatch(itemValidationResult);
          validationResult2.mergeEnumValues(itemValidationResult);
        } else if (node2.items.length >= subSchemas.length) {
          validationResult2.propertiesValueMatches++;
        }
      }
      if (node2.items.length > subSchemas.length) {
        if (typeof schema22.additionalItems === "object") {
          for (let i = subSchemas.length; i < node2.items.length; i++) {
            const itemValidationResult = new ValidationResult2(isKubernetes);
            validate2(node2.items[i], schema22.additionalItems, schema22, itemValidationResult, matchingSchemas2, options);
            validationResult2.mergePropertyMatch(itemValidationResult);
            validationResult2.mergeEnumValues(itemValidationResult);
          }
        } else if (schema22.additionalItems === false) {
          validationResult2.problems.push({
            location: { offset: node2.offset, length: node2.length },
            severity: DiagnosticSeverity.Warning,
            message: localize5("additionalItemsWarning", "Array has too many items according to schema. Expected {0} or fewer.", subSchemas.length),
            source: getSchemaSource(schema22, originalSchema),
            schemaUri: getSchemaUri(schema22, originalSchema)
          });
        }
      }
    } else {
      const itemSchema = asSchema2(schema22.items);
      if (itemSchema) {
        const itemValidationResult = new ValidationResult2(isKubernetes);
        node2.items.forEach((item) => {
          if (itemSchema.oneOf && itemSchema.oneOf.length === 1) {
            const subSchemaRef = itemSchema.oneOf[0];
            const subSchema = { ...asSchema2(subSchemaRef) };
            subSchema.title = schema22.title;
            subSchema.closestTitle = schema22.closestTitle;
            validate2(item, subSchema, schema22, itemValidationResult, matchingSchemas2, options);
            validationResult2.mergePropertyMatch(itemValidationResult);
            validationResult2.mergeEnumValues(itemValidationResult);
          } else {
            validate2(item, itemSchema, schema22, itemValidationResult, matchingSchemas2, options);
            validationResult2.mergePropertyMatch(itemValidationResult);
            validationResult2.mergeEnumValues(itemValidationResult);
          }
        });
      }
    }
    const containsSchema = asSchema2(schema22.contains);
    if (containsSchema) {
      const doesContain = node2.items.some((item) => {
        const itemValidationResult = new ValidationResult2(isKubernetes);
        validate2(item, containsSchema, schema22, itemValidationResult, NoOpSchemaCollector2.instance, options);
        return !itemValidationResult.hasProblems();
      });
      if (!doesContain) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          severity: DiagnosticSeverity.Warning,
          message: schema22.errorMessage || localize5("requiredItemMissingWarning", "Array does not contain required item."),
          source: getSchemaSource(schema22, originalSchema),
          schemaUri: getSchemaUri(schema22, originalSchema)
        });
      }
    }
    if (isNumber2(schema22.minItems) && node2.items.length < schema22.minItems) {
      validationResult2.problems.push({
        location: { offset: node2.offset, length: node2.length },
        severity: DiagnosticSeverity.Warning,
        message: localize5("minItemsWarning", "Array has too few items. Expected {0} or more.", schema22.minItems),
        source: getSchemaSource(schema22, originalSchema),
        schemaUri: getSchemaUri(schema22, originalSchema)
      });
    }
    if (isNumber2(schema22.maxItems) && node2.items.length > schema22.maxItems) {
      validationResult2.problems.push({
        location: { offset: node2.offset, length: node2.length },
        severity: DiagnosticSeverity.Warning,
        message: localize5("maxItemsWarning", "Array has too many items. Expected {0} or fewer.", schema22.maxItems),
        source: getSchemaSource(schema22, originalSchema),
        schemaUri: getSchemaUri(schema22, originalSchema)
      });
    }
    if (schema22.uniqueItems === true) {
      const values = getNodeValue3(node2);
      const duplicates = values.some((value, index) => {
        return index !== values.lastIndexOf(value);
      });
      if (duplicates) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          severity: DiagnosticSeverity.Warning,
          message: localize5("uniqueItemsWarning", "Array has duplicate items."),
          source: getSchemaSource(schema22, originalSchema),
          schemaUri: getSchemaUri(schema22, originalSchema)
        });
      }
    }
  }
  function _validateObjectNode(node2, schema22, validationResult2, matchingSchemas2) {
    var _a4;
    const seenKeys = /* @__PURE__ */ Object.create(null);
    const unprocessedProperties = [];
    const unprocessedNodes = [...node2.properties];
    while (unprocessedNodes.length > 0) {
      const propertyNode = unprocessedNodes.pop();
      const key = propertyNode.keyNode.value;
      if (key === "<<" && propertyNode.valueNode) {
        switch (propertyNode.valueNode.type) {
          case "object": {
            unprocessedNodes.push(...propertyNode.valueNode["properties"]);
            break;
          }
          case "array": {
            propertyNode.valueNode["items"].forEach((sequenceNode) => {
              if (sequenceNode && isIterable(sequenceNode["properties"])) {
                unprocessedNodes.push(...sequenceNode["properties"]);
              }
            });
            break;
          }
          default: {
            break;
          }
        }
      } else {
        seenKeys[key] = propertyNode.valueNode;
        unprocessedProperties.push(key);
      }
    }
    if (Array.isArray(schema22.required)) {
      for (const propertyName of schema22.required) {
        if (seenKeys[propertyName] === void 0) {
          const keyNode = node2.parent && node2.parent.type === "property" && node2.parent.keyNode;
          const location = keyNode ? { offset: keyNode.offset, length: keyNode.length } : { offset: node2.offset, length: 1 };
          validationResult2.problems.push({
            location,
            severity: DiagnosticSeverity.Warning,
            message: getWarningMessage(ProblemType.missingRequiredPropWarning, [propertyName]),
            source: getSchemaSource(schema22, originalSchema),
            schemaUri: getSchemaUri(schema22, originalSchema),
            problemArgs: [propertyName],
            problemType: ProblemType.missingRequiredPropWarning
          });
        }
      }
    }
    const propertyProcessed = (prop) => {
      let index = unprocessedProperties.indexOf(prop);
      while (index >= 0) {
        unprocessedProperties.splice(index, 1);
        index = unprocessedProperties.indexOf(prop);
      }
    };
    if (schema22.properties) {
      for (const propertyName of Object.keys(schema22.properties)) {
        propertyProcessed(propertyName);
        const propertySchema = schema22.properties[propertyName];
        const child = seenKeys[propertyName];
        if (child) {
          if (isBoolean2(propertySchema)) {
            if (!propertySchema) {
              const propertyNode = child.parent;
              validationResult2.problems.push({
                location: {
                  offset: propertyNode.keyNode.offset,
                  length: propertyNode.keyNode.length
                },
                severity: DiagnosticSeverity.Warning,
                message: schema22.errorMessage || localize5("DisallowedExtraPropWarning", MSG_PROPERTY_NOT_ALLOWED, propertyName),
                source: getSchemaSource(schema22, originalSchema),
                schemaUri: getSchemaUri(schema22, originalSchema)
              });
            } else {
              validationResult2.propertiesMatches++;
              validationResult2.propertiesValueMatches++;
            }
          } else {
            propertySchema.url = (_a4 = schema22.url) != null ? _a4 : originalSchema.url;
            const propertyValidationResult = new ValidationResult2(isKubernetes);
            validate2(child, propertySchema, schema22, propertyValidationResult, matchingSchemas2, options);
            validationResult2.mergePropertyMatch(propertyValidationResult);
            validationResult2.mergeEnumValues(propertyValidationResult);
          }
        }
      }
    }
    if (schema22.patternProperties) {
      for (const propertyPattern of Object.keys(schema22.patternProperties)) {
        const regex = safeCreateUnicodeRegExp(propertyPattern);
        for (const propertyName of unprocessedProperties.slice(0)) {
          if (regex.test(propertyName)) {
            propertyProcessed(propertyName);
            const child = seenKeys[propertyName];
            if (child) {
              const propertySchema = schema22.patternProperties[propertyPattern];
              if (isBoolean2(propertySchema)) {
                if (!propertySchema) {
                  const propertyNode = child.parent;
                  validationResult2.problems.push({
                    location: {
                      offset: propertyNode.keyNode.offset,
                      length: propertyNode.keyNode.length
                    },
                    severity: DiagnosticSeverity.Warning,
                    message: schema22.errorMessage || localize5("DisallowedExtraPropWarning", MSG_PROPERTY_NOT_ALLOWED, propertyName),
                    source: getSchemaSource(schema22, originalSchema),
                    schemaUri: getSchemaUri(schema22, originalSchema)
                  });
                } else {
                  validationResult2.propertiesMatches++;
                  validationResult2.propertiesValueMatches++;
                }
              } else {
                const propertyValidationResult = new ValidationResult2(isKubernetes);
                validate2(child, propertySchema, schema22, propertyValidationResult, matchingSchemas2, options);
                validationResult2.mergePropertyMatch(propertyValidationResult);
                validationResult2.mergeEnumValues(propertyValidationResult);
              }
            }
          }
        }
      }
    }
    if (typeof schema22.additionalProperties === "object") {
      for (const propertyName of unprocessedProperties) {
        const child = seenKeys[propertyName];
        if (child) {
          const propertyValidationResult = new ValidationResult2(isKubernetes);
          validate2(child, schema22.additionalProperties, schema22, propertyValidationResult, matchingSchemas2, options);
          validationResult2.mergePropertyMatch(propertyValidationResult);
          validationResult2.mergeEnumValues(propertyValidationResult);
        }
      }
    } else if (schema22.additionalProperties === false || schema22.type === "object" && schema22.additionalProperties === void 0 && options.disableAdditionalProperties === true) {
      if (unprocessedProperties.length > 0) {
        const possibleProperties = schema22.properties && Object.keys(schema22.properties).filter((prop) => !seenKeys[prop]);
        for (const propertyName of unprocessedProperties) {
          const child = seenKeys[propertyName];
          if (child) {
            let propertyNode = null;
            if (child.type !== "property") {
              propertyNode = child.parent;
              if (propertyNode.type === "object") {
                propertyNode = propertyNode.properties[0];
              }
            } else {
              propertyNode = child;
            }
            const problem = {
              location: {
                offset: propertyNode.keyNode.offset,
                length: propertyNode.keyNode.length
              },
              severity: DiagnosticSeverity.Warning,
              code: ErrorCode.PropertyExpected,
              message: schema22.errorMessage || localize5("DisallowedExtraPropWarning", MSG_PROPERTY_NOT_ALLOWED, propertyName),
              source: getSchemaSource(schema22, originalSchema),
              schemaUri: getSchemaUri(schema22, originalSchema)
            };
            if (possibleProperties == null ? void 0 : possibleProperties.length) {
              problem.data = { properties: possibleProperties };
            }
            validationResult2.problems.push(problem);
          }
        }
      }
    }
    if (isNumber2(schema22.maxProperties)) {
      if (node2.properties.length > schema22.maxProperties) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          severity: DiagnosticSeverity.Warning,
          message: localize5("MaxPropWarning", "Object has more properties than limit of {0}.", schema22.maxProperties),
          source: getSchemaSource(schema22, originalSchema),
          schemaUri: getSchemaUri(schema22, originalSchema)
        });
      }
    }
    if (isNumber2(schema22.minProperties)) {
      if (node2.properties.length < schema22.minProperties) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          severity: DiagnosticSeverity.Warning,
          message: localize5("MinPropWarning", "Object has fewer properties than the required number of {0}", schema22.minProperties),
          source: getSchemaSource(schema22, originalSchema),
          schemaUri: getSchemaUri(schema22, originalSchema)
        });
      }
    }
    if (schema22.dependencies) {
      for (const key of Object.keys(schema22.dependencies)) {
        const prop = seenKeys[key];
        if (prop) {
          const propertyDep = schema22.dependencies[key];
          if (Array.isArray(propertyDep)) {
            for (const requiredProp of propertyDep) {
              if (!seenKeys[requiredProp]) {
                validationResult2.problems.push({
                  location: { offset: node2.offset, length: node2.length },
                  severity: DiagnosticSeverity.Warning,
                  message: localize5("RequiredDependentPropWarning", "Object is missing property {0} required by property {1}.", requiredProp, key),
                  source: getSchemaSource(schema22, originalSchema),
                  schemaUri: getSchemaUri(schema22, originalSchema)
                });
              } else {
                validationResult2.propertiesValueMatches++;
              }
            }
          } else {
            const propertySchema = asSchema2(propertyDep);
            if (propertySchema) {
              const propertyValidationResult = new ValidationResult2(isKubernetes);
              validate2(node2, propertySchema, schema22, propertyValidationResult, matchingSchemas2, options);
              validationResult2.mergePropertyMatch(propertyValidationResult);
              validationResult2.mergeEnumValues(propertyValidationResult);
            }
          }
        }
      }
    }
    const propertyNames = asSchema2(schema22.propertyNames);
    if (propertyNames) {
      for (const f2 of node2.properties) {
        const key = f2.keyNode;
        if (key) {
          validate2(key, propertyNames, schema22, validationResult2, NoOpSchemaCollector2.instance, options);
        }
      }
    }
  }
  function alternativeComparison(subValidationResult, bestMatch, subSchema, subMatchingSchemas) {
    const compareResult = subValidationResult.compareKubernetes(bestMatch.validationResult);
    if (compareResult > 0) {
      bestMatch = {
        schema: subSchema,
        validationResult: subValidationResult,
        matchingSchemas: subMatchingSchemas
      };
    } else if (compareResult === 0) {
      bestMatch.matchingSchemas.merge(subMatchingSchemas);
      bestMatch.validationResult.mergeEnumValues(subValidationResult);
    }
    return bestMatch;
  }
  function genericComparison(node2, maxOneMatch, subValidationResult, bestMatch, subSchema, subMatchingSchemas) {
    if (!maxOneMatch && !subValidationResult.hasProblems() && (!bestMatch.validationResult.hasProblems() || callFromAutoComplete)) {
      bestMatch.matchingSchemas.merge(subMatchingSchemas);
      bestMatch.validationResult.propertiesMatches += subValidationResult.propertiesMatches;
      bestMatch.validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;
    } else {
      const compareResult = subValidationResult.compareGeneric(bestMatch.validationResult);
      if (compareResult > 0 || compareResult === 0 && maxOneMatch && bestMatch.schema.type === "object" && node2.type !== "null" && node2.type !== bestMatch.schema.type) {
        bestMatch = {
          schema: subSchema,
          validationResult: subValidationResult,
          matchingSchemas: subMatchingSchemas
        };
      } else if (compareResult === 0) {
        bestMatch.matchingSchemas.merge(subMatchingSchemas);
        bestMatch.validationResult.mergeEnumValues(subValidationResult);
        bestMatch.validationResult.mergeWarningGeneric(subValidationResult, [
          ProblemType.missingRequiredPropWarning,
          ProblemType.typeMismatchWarning,
          ProblemType.constWarning
        ]);
      }
    }
    return bestMatch;
  }
}
function getSchemaSource(schema4, originalSchema) {
  var _a4;
  if (schema4) {
    let label;
    if (schema4.title) {
      label = schema4.title;
    } else if (schema4.closestTitle) {
      label = schema4.closestTitle;
    } else if (originalSchema.closestTitle) {
      label = originalSchema.closestTitle;
    } else {
      const uriString = (_a4 = schema4.url) != null ? _a4 : originalSchema.url;
      if (uriString) {
        const url = URI2.parse(uriString);
        if (url.scheme === "file") {
          label = url.fsPath;
        }
        label = url.toString();
      }
    }
    if (label) {
      return `${YAML_SCHEMA_PREFIX}${label}`;
    }
  }
  return YAML_SOURCE;
}
function getSchemaUri(schema4, originalSchema) {
  var _a4;
  const uriString = (_a4 = schema4.url) != null ? _a4 : originalSchema.url;
  return uriString ? [uriString] : [];
}
function getWarningMessage(problemType, args) {
  return localize5(problemType, ProblemTypeMessages[problemType], args.join(" | "));
}
var maxRefCount = 1e3;
var refDepth = 0;
var seenAlias = /* @__PURE__ */ new Set();
function convertAST(parent, node, doc, lineCounter) {
  if (!parent) {
    refDepth = 0;
  }
  if (!node) {
    return null;
  }
  if (isMap(node)) {
    return convertMap(node, parent, doc, lineCounter);
  }
  if (isPair(node)) {
    return convertPair(node, parent, doc, lineCounter);
  }
  if (isSeq(node)) {
    return convertSeq(node, parent, doc, lineCounter);
  }
  if (isScalar(node)) {
    return convertScalar(node, parent);
  }
  if (isAlias(node) && !seenAlias.has(node) && refDepth < maxRefCount) {
    seenAlias.add(node);
    const converted = convertAlias(node, parent, doc, lineCounter);
    seenAlias.delete(node);
    return converted;
  } else {
    return;
  }
}
function convertMap(node, parent, doc, lineCounter) {
  let range;
  if (node.flow && !node.range) {
    range = collectFlowMapRange(node);
  } else {
    range = node.range;
  }
  const result = new ObjectASTNodeImpl2(parent, node, ...toFixedOffsetLength(range, lineCounter));
  for (const it of node.items) {
    if (isPair(it)) {
      result.properties.push(convertAST(result, it, doc, lineCounter));
    }
  }
  return result;
}
function convertPair(node, parent, doc, lineCounter) {
  const keyNode = node.key;
  const valueNode = node.value;
  const rangeStart = keyNode.range[0];
  let rangeEnd = keyNode.range[1];
  let nodeEnd = keyNode.range[2];
  if (valueNode) {
    rangeEnd = valueNode.range[1];
    nodeEnd = valueNode.range[2];
  }
  const result = new PropertyASTNodeImpl2(parent, node, ...toFixedOffsetLength([rangeStart, rangeEnd, nodeEnd], lineCounter));
  if (isAlias(keyNode)) {
    const keyAlias = new StringASTNodeImpl2(parent, keyNode, ...toOffsetLength(keyNode.range));
    keyAlias.value = keyNode.source;
    result.keyNode = keyAlias;
  } else {
    result.keyNode = convertAST(result, keyNode, doc, lineCounter);
  }
  result.valueNode = convertAST(result, valueNode, doc, lineCounter);
  return result;
}
function convertSeq(node, parent, doc, lineCounter) {
  const result = new ArrayASTNodeImpl2(parent, node, ...toOffsetLength(node.range));
  for (const it of node.items) {
    if (isNode(it)) {
      const convertedNode = convertAST(result, it, doc, lineCounter);
      if (convertedNode) {
        result.children.push(convertedNode);
      }
    }
  }
  return result;
}
function convertScalar(node, parent) {
  if (node.value === null) {
    return new NullASTNodeImpl2(parent, node, ...toOffsetLength(node.range));
  }
  switch (typeof node.value) {
    case "string": {
      const result = new StringASTNodeImpl2(parent, node, ...toOffsetLength(node.range));
      result.value = node.value;
      return result;
    }
    case "boolean":
      return new BooleanASTNodeImpl2(parent, node, node.value, ...toOffsetLength(node.range));
    case "number": {
      const result = new NumberASTNodeImpl2(parent, node, ...toOffsetLength(node.range));
      result.value = node.value;
      result.isInteger = Number.isInteger(result.value);
      return result;
    }
    default: {
      const result = new StringASTNodeImpl2(parent, node, ...toOffsetLength(node.range));
      result.value = node.source;
      return result;
    }
  }
}
function convertAlias(node, parent, doc, lineCounter) {
  refDepth++;
  const resolvedNode = node.resolve(doc);
  if (resolvedNode) {
    return convertAST(parent, resolvedNode, doc, lineCounter);
  } else {
    const resultNode = new StringASTNodeImpl2(parent, node, ...toOffsetLength(node.range));
    resultNode.value = node.source;
    return resultNode;
  }
}
function toOffsetLength(range) {
  return [range[0], range[1] - range[0]];
}
function toFixedOffsetLength(range, lineCounter) {
  const start = lineCounter.linePos(range[0]);
  const end = lineCounter.linePos(range[1]);
  const result = [range[0], range[1] - range[0]];
  if (start.line !== end.line && (lineCounter.lineStarts.length !== end.line || end.col === 1)) {
    result[1]--;
  }
  return result;
}
function collectFlowMapRange(node) {
  let start = Number.MAX_SAFE_INTEGER;
  let end = 0;
  for (const it of node.items) {
    if (isPair(it)) {
      if (isNode(it.key)) {
        if (it.key.range && it.key.range[0] <= start) {
          start = it.key.range[0];
        }
      }
      if (isNode(it.value)) {
        if (it.value.range && it.value.range[2] >= end) {
          end = it.value.range[2];
        }
      }
    }
  }
  return [start, end, end];
}
function getParent(doc, nodeToFind) {
  let parentNode;
  visit2(doc, (_, node, path5) => {
    if (node === nodeToFind) {
      parentNode = path5[path5.length - 1];
      return visit2.BREAK;
    }
  });
  if (isDocument(parentNode)) {
    return void 0;
  }
  return parentNode;
}
function isMapContainsEmptyPair(map2) {
  if (map2.items.length > 1) {
    return false;
  }
  const pair = map2.items[0];
  return isScalar(pair.key) && isScalar(pair.value) && pair.key.value === "" && !pair.value.value;
}
function indexOf(seq2, item) {
  for (const [i, obj] of seq2.items.entries()) {
    if (item === obj) {
      return i;
    }
  }
  return void 0;
}
function isInComment(tokens, offset) {
  let inComment = false;
  for (const token of tokens) {
    if (token.type === "document") {
      _visit2([], token, (item) => {
        var _a4;
        if (isCollectionItem(item) && ((_a4 = item.value) == null ? void 0 : _a4.type) === "comment") {
          if (token.offset <= offset && item.value.source.length + item.value.offset >= offset) {
            inComment = true;
            return visit2.BREAK;
          }
        } else if (item.type === "comment" && item.offset <= offset && item.offset + item.source.length >= offset) {
          inComment = true;
          return visit2.BREAK;
        }
      });
    } else if (token.type === "comment") {
      if (token.offset <= offset && token.source.length + token.offset >= offset) {
        return true;
      }
    }
    if (inComment) {
      break;
    }
  }
  return inComment;
}
function isCollectionItem(token) {
  return token["start"] !== void 0;
}
function _visit2(path5, item, visitor) {
  let ctrl = visitor(item, path5);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token2 = item[field];
    if (token2 && "items" in token2) {
      for (let i = 0; i < token2.items.length; ++i) {
        const ci = _visit2(Object.freeze(path5.concat([[field, i]])), token2.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === visit2.BREAK)
          return visit2.BREAK;
        else if (ci === visit2.REMOVE) {
          token2.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path5);
    }
  }
  const token = item["sep"];
  if (token) {
    for (let i = 0; i < token.length; ++i) {
      const ci = _visit2(Object.freeze(path5), token[i], visitor);
      if (typeof ci === "number")
        i = ci - 1;
      else if (ci === visit2.BREAK)
        return visit2.BREAK;
      else if (ci === visit2.REMOVE) {
        token.items.splice(i, 1);
        i -= 1;
      }
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path5) : ctrl;
}
var SingleYAMLDocument = class _SingleYAMLDocument extends JSONDocument2 {
  constructor(lineCounter) {
    super(null, []);
    this.lineCounter = lineCounter;
  }
  /**
   * Create a deep copy of this document
   */
  clone() {
    const copy = new _SingleYAMLDocument(this.lineCounter);
    copy.isKubernetes = this.isKubernetes;
    copy.disableAdditionalProperties = this.disableAdditionalProperties;
    copy.uri = this.uri;
    copy.currentDocIndex = this.currentDocIndex;
    copy._lineComments = this.lineComments.slice();
    copy.internalDocument = this._internalDocument.clone();
    return copy;
  }
  collectLineComments() {
    this._lineComments = [];
    if (this._internalDocument.commentBefore) {
      const comments = this._internalDocument.commentBefore.split("\n");
      comments.forEach((comment) => this._lineComments.push(`#${comment}`));
    }
    visit2(this.internalDocument, (_key, node) => {
      if (node == null ? void 0 : node.commentBefore) {
        const comments = node == null ? void 0 : node.commentBefore.split("\n");
        comments.forEach((comment) => this._lineComments.push(`#${comment}`));
      }
      if (node == null ? void 0 : node.comment) {
        this._lineComments.push(`#${node.comment}`);
      }
    });
    if (this._internalDocument.comment) {
      this._lineComments.push(`#${this._internalDocument.comment}`);
    }
  }
  /**
   * Updates the internal AST tree of the object
   * from the internal node. This is call whenever the
   * internalDocument is set but also can be called to
   * reflect any changes on the underlying document
   * without setting the internalDocument explicitly.
   */
  updateFromInternalDocument() {
    this.root = convertAST(null, this._internalDocument.contents, this._internalDocument, this.lineCounter);
  }
  set internalDocument(document2) {
    this._internalDocument = document2;
    this.updateFromInternalDocument();
  }
  get internalDocument() {
    return this._internalDocument;
  }
  get lineComments() {
    if (!this._lineComments) {
      this.collectLineComments();
    }
    return this._lineComments;
  }
  set lineComments(val) {
    this._lineComments = val;
  }
  get errors() {
    return this.internalDocument.errors.map(YAMLErrorToYamlDocDiagnostics);
  }
  get warnings() {
    return this.internalDocument.warnings.map(YAMLErrorToYamlDocDiagnostics);
  }
  getNodeFromPosition(positionOffset, textBuffer, configuredIndentation) {
    const position = textBuffer.getPosition(positionOffset);
    const lineContent = textBuffer.getLineContent(position.line);
    if (lineContent.trim().length === 0) {
      return [this.findClosestNode(positionOffset, textBuffer, configuredIndentation), true];
    }
    const textAfterPosition = lineContent.substring(position.character);
    const spacesAfterPositionMatch = textAfterPosition.match(/^([ ]+)\n?$/);
    const areOnlySpacesAfterPosition = !!spacesAfterPositionMatch;
    const countOfSpacesAfterPosition = spacesAfterPositionMatch == null ? void 0 : spacesAfterPositionMatch[1].length;
    let closestNode;
    visit2(this.internalDocument, (key, node) => {
      if (!node) {
        return;
      }
      const range = node.range;
      if (!range) {
        return;
      }
      const isNullNodeOnTheLine = () => areOnlySpacesAfterPosition && positionOffset + countOfSpacesAfterPosition === range[2] && isScalar(node) && node.value === null;
      if (range[0] <= positionOffset && range[1] >= positionOffset || isNullNodeOnTheLine()) {
        closestNode = node;
      } else {
        return visit2.SKIP;
      }
    });
    return [closestNode, false];
  }
  findClosestNode(offset, textBuffer, configuredIndentation) {
    let offsetDiff = this.internalDocument.range[2];
    let maxOffset = this.internalDocument.range[0];
    let closestNode;
    visit2(this.internalDocument, (key, node) => {
      if (!node) {
        return;
      }
      const range = node.range;
      if (!range) {
        return;
      }
      const diff = range[1] - offset;
      if (maxOffset <= range[0] && diff <= 0 && Math.abs(diff) <= offsetDiff) {
        offsetDiff = Math.abs(diff);
        maxOffset = range[0];
        closestNode = node;
      }
    });
    const position = textBuffer.getPosition(offset);
    const lineContent = textBuffer.getLineContent(position.line);
    const indentation = getIndentation2(lineContent, position.character);
    if (isScalar(closestNode) && closestNode.value === null) {
      return closestNode;
    }
    if (indentation === position.character) {
      closestNode = this.getProperParentByIndentation(indentation, closestNode, textBuffer, "", configuredIndentation);
    }
    return closestNode;
  }
  getProperParentByIndentation(indentation, node, textBuffer, currentLine, configuredIndentation, rootParent) {
    if (!node) {
      return this.internalDocument.contents;
    }
    configuredIndentation = !configuredIndentation ? 2 : configuredIndentation;
    if (isNode(node) && node.range) {
      const position = textBuffer.getPosition(node.range[0]);
      const lineContent = textBuffer.getLineContent(position.line);
      currentLine = currentLine === "" ? lineContent.trim() : currentLine;
      if (currentLine.startsWith("-") && indentation === configuredIndentation && currentLine === lineContent.trim()) {
        position.character += indentation;
      }
      if (position.character > indentation && position.character > 0) {
        const parent = this.getParent(node);
        if (parent) {
          return this.getProperParentByIndentation(indentation, parent, textBuffer, currentLine, configuredIndentation, rootParent);
        }
      } else if (position.character < indentation) {
        const parent = this.getParent(node);
        if (isPair(parent) && isNode(parent.value)) {
          return parent.value;
        } else if (isPair(rootParent) && isNode(rootParent.value)) {
          return rootParent.value;
        }
      } else {
        return node;
      }
    } else if (isPair(node)) {
      rootParent = node;
      const parent = this.getParent(node);
      return this.getProperParentByIndentation(indentation, parent, textBuffer, currentLine, configuredIndentation, rootParent);
    }
    return node;
  }
  getParent(node) {
    return getParent(this.internalDocument, node);
  }
};
var YAMLDocument = class {
  constructor(documents, tokens) {
    this.documents = documents;
    this.tokens = tokens;
    this.errors = [];
    this.warnings = [];
  }
};
var YamlDocuments = class {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
  }
  /**
   * Get cached YAMLDocument
   * @param document TextDocument to parse
   * @param parserOptions YAML parserOptions
   * @param addRootObject if true and document is empty add empty object {} to force schema usage
   * @returns the YAMLDocument
   */
  getYamlDocument(document2, parserOptions, addRootObject = false) {
    this.ensureCache(document2, parserOptions != null ? parserOptions : defaultOptions, addRootObject);
    return this.cache.get(document2.uri).document;
  }
  /**
   * For test purpose only!
   */
  clear() {
    this.cache.clear();
  }
  ensureCache(document2, parserOptions, addRootObject) {
    const key = document2.uri;
    if (!this.cache.has(key)) {
      this.cache.set(key, { version: -1, document: new YAMLDocument([], []), parserOptions: defaultOptions });
    }
    const cacheEntry = this.cache.get(key);
    if (cacheEntry.version !== document2.version || parserOptions.customTags && !isArrayEqual(cacheEntry.parserOptions.customTags, parserOptions.customTags)) {
      let text = document2.getText();
      if (addRootObject && !/\S/.test(text)) {
        text = `{${text}}`;
      }
      const doc = parse22(text, parserOptions, document2);
      cacheEntry.document = doc;
      cacheEntry.version = document2.version;
      cacheEntry.parserOptions = parserOptions;
    }
  }
};
var yamlDocumentsCache = new YamlDocuments();
function YAMLErrorToYamlDocDiagnostics(error) {
  return {
    message: error.message,
    location: {
      start: error.pos[0],
      end: error.pos[1],
      toLineEnd: true
    },
    severity: 1,
    code: ErrorCode.Undefined
  };
}
var CommonTagImpl = class {
  constructor(tag, type) {
    this.tag = tag;
    this.type = type;
  }
  get collection() {
    if (this.type === "mapping") {
      return "map";
    }
    if (this.type === "sequence") {
      return "seq";
    }
    return void 0;
  }
  resolve(value) {
    if (isMap(value) && this.type === "mapping") {
      return value;
    }
    if (isSeq(value) && this.type === "sequence") {
      return value;
    }
    if (typeof value === "string" && this.type === "scalar") {
      return value;
    }
  }
};
var IncludeTag = class {
  constructor() {
    this.tag = "!include";
    this.type = "scalar";
  }
  resolve(value, onError) {
    if (value && value.length > 0 && value.trim()) {
      return value;
    }
    onError("!include without value");
  }
};
function getCustomTags(customTags) {
  const tags = [];
  const filteredTags = filterInvalidCustomTags(customTags);
  for (const tag of filteredTags) {
    const typeInfo = tag.split(" ");
    const tagName = typeInfo[0];
    const tagType = typeInfo[1] && typeInfo[1].toLowerCase() || "scalar";
    tags.push(new CommonTagImpl(tagName, tagType));
  }
  tags.push(new IncludeTag());
  return tags;
}
var TextBuffer = class {
  constructor(doc) {
    this.doc = doc;
  }
  getLineCount() {
    return this.doc.lineCount;
  }
  getLineLength(lineNumber) {
    const lineOffsets = this.doc.getLineOffsets();
    if (lineNumber >= lineOffsets.length) {
      return this.doc.getText().length;
    } else if (lineNumber < 0) {
      return 0;
    }
    const nextLineOffset = lineNumber + 1 < lineOffsets.length ? lineOffsets[lineNumber + 1] : this.doc.getText().length;
    return nextLineOffset - lineOffsets[lineNumber];
  }
  getLineContent(lineNumber) {
    const lineOffsets = this.doc.getLineOffsets();
    if (lineNumber >= lineOffsets.length) {
      return this.doc.getText();
    } else if (lineNumber < 0) {
      return "";
    }
    const nextLineOffset = lineNumber + 1 < lineOffsets.length ? lineOffsets[lineNumber + 1] : this.doc.getText().length;
    return this.doc.getText().substring(lineOffsets[lineNumber], nextLineOffset);
  }
  getLineCharCode(lineNumber, index) {
    return this.doc.getText(Range2.create(lineNumber - 1, index, lineNumber - 1, index + 1)).charCodeAt(0);
  }
  getText(range) {
    return this.doc.getText(range);
  }
  getPosition(offest) {
    return this.doc.positionAt(offest);
  }
};
var defaultOptions = {
  customTags: [],
  yamlVersion: "1.2"
};
function parse22(text, parserOptions = defaultOptions, document2) {
  var _a4;
  const options = {
    strict: false,
    customTags: getCustomTags(parserOptions.customTags),
    version: (_a4 = parserOptions.yamlVersion) != null ? _a4 : defaultOptions.yamlVersion,
    keepSourceTokens: true
  };
  const composer = new Composer(options);
  const lineCounter = new LineCounter();
  let isLastLineEmpty = false;
  if (document2) {
    const textBuffer = new TextBuffer(document2);
    const position = textBuffer.getPosition(text.length);
    const lineContent = textBuffer.getLineContent(position.line);
    isLastLineEmpty = lineContent.trim().length === 0;
  }
  const parser2 = isLastLineEmpty ? new Parser() : new Parser(lineCounter.addNewLine);
  const tokens = parser2.parse(text);
  const tokensArr = Array.from(tokens);
  const docs = composer.compose(tokensArr, true, text.length);
  const yamlDocs = Array.from(docs, (doc) => parsedDocToSingleYAMLDocument(doc, lineCounter));
  return new YAMLDocument(yamlDocs, tokensArr);
}
function parsedDocToSingleYAMLDocument(parsedDoc, lineCounter) {
  const syd = new SingleYAMLDocument(lineCounter);
  syd.internalDocument = parsedDoc;
  return syd;
}
function getSchemaFromModeline(doc) {
  if (doc instanceof SingleYAMLDocument) {
    const yamlLanguageServerModeline = doc.lineComments.find((lineComment2) => {
      return isModeline(lineComment2);
    });
    if (yamlLanguageServerModeline != void 0) {
      const schemaMatchs = yamlLanguageServerModeline.match(/\$schema=\S+/g);
      if (schemaMatchs !== null && schemaMatchs.length >= 1) {
        if (schemaMatchs.length >= 2) {
          console.log("Several $schema attributes have been found on the yaml-language-server modeline. The first one will be picked.");
        }
        return schemaMatchs[0].substring("$schema=".length);
      }
    }
  }
  return void 0;
}
function isModeline(lineText) {
  const matchModeline = lineText.match(/^#\s+yaml-language-server\s*:/g);
  return matchModeline !== null && matchModeline.length === 1;
}
var AJVStub = class {
  // eslint-disable-next-line class-methods-use-this
  validateSchema() {
    return true;
  }
  // eslint-disable-next-line class-methods-use-this
  defaultMeta() {
  }
};
var ajv = new AJVStub();
var ajv04 = new AJVStub();
var ajv2019 = new AJVStub();
var ajv2020 = new AJVStub();
var localize6 = loadMessageBundle();
var MODIFICATION_ACTIONS;
(function(MODIFICATION_ACTIONS2) {
  MODIFICATION_ACTIONS2[MODIFICATION_ACTIONS2["delete"] = 0] = "delete";
  MODIFICATION_ACTIONS2[MODIFICATION_ACTIONS2["add"] = 1] = "add";
  MODIFICATION_ACTIONS2[MODIFICATION_ACTIONS2["deleteAll"] = 2] = "deleteAll";
})(MODIFICATION_ACTIONS || (MODIFICATION_ACTIONS = {}));
var FilePatternAssociation2 = class {
  constructor(pattern) {
    try {
      this.patternRegExp = new RegExp(convertSimple2RegExpPattern(pattern) + "$");
    } catch (e) {
      this.patternRegExp = null;
    }
    this.schemas = [];
  }
  addSchema(id) {
    this.schemas.push(id);
  }
  matchesPattern(fileName) {
    return this.patternRegExp && this.patternRegExp.test(fileName);
  }
  getSchemas() {
    return this.schemas;
  }
};
var YAMLSchemaService = class extends JSONSchemaService {
  constructor(requestService, contextService, promiseConstructor) {
    super(requestService, contextService, promiseConstructor);
    this.schemaUriToNameAndDescription = /* @__PURE__ */ new Map();
    this.customSchemaProvider = void 0;
    this.requestService = requestService;
    this.schemaPriorityMapping = /* @__PURE__ */ new Map();
  }
  registerCustomSchemaProvider(customSchemaProvider) {
    this.customSchemaProvider = customSchemaProvider;
  }
  getAllSchemas() {
    const result = [];
    const schemaUris = /* @__PURE__ */ new Set();
    for (const filePattern of this.filePatternAssociations) {
      const schemaUri = filePattern.uris[0];
      if (schemaUris.has(schemaUri)) {
        continue;
      }
      schemaUris.add(schemaUri);
      const schemaHandle = {
        uri: schemaUri,
        fromStore: false,
        usedForCurrentFile: false
      };
      if (this.schemaUriToNameAndDescription.has(schemaUri)) {
        const { name, description, versions } = this.schemaUriToNameAndDescription.get(schemaUri);
        schemaHandle.name = name;
        schemaHandle.description = description;
        schemaHandle.fromStore = true;
        schemaHandle.versions = versions;
      }
      result.push(schemaHandle);
    }
    return result;
  }
  async resolveSchemaContent(schemaToResolve, schemaURL, dependencies) {
    const resolveErrors = schemaToResolve.errors.slice(0);
    let schema4 = schemaToResolve.schema;
    const contextService = this.contextService;
    let validationErrors = [];
    switch (this.normalizeId(schema4.$schema)) {
      case ajv04.defaultMeta(): {
        if (!ajv04.validateSchema(schema4)) {
          validationErrors = validationErrors.concat(ajv04.errors);
        }
        break;
      }
      case ajv2019.defaultMeta(): {
        if (!ajv2019.validateSchema(schema4)) {
          validationErrors = validationErrors.concat(ajv2019.errors);
        }
        break;
      }
      case ajv2020.defaultMeta(): {
        if (!ajv2020.validateSchema(schema4)) {
          validationErrors = validationErrors.concat(ajv2020.errors);
        }
        break;
      }
      default:
        if (!ajv.validateSchema(schema4)) {
          validationErrors = validationErrors.concat(ajv.errors);
        }
        break;
    }
    if (validationErrors.length > 0) {
      const errs = [];
      for (const err of validationErrors) {
        errs.push(`${err.instancePath} : ${err.message}`);
      }
      resolveErrors.push(`Schema '${getSchemaTitle(schemaToResolve.schema, schemaURL)}' is not valid:
${errs.join("\n")}`);
    }
    const findSection = (schema22, path5) => {
      if (!path5) {
        return schema22;
      }
      let current = schema22;
      if (path5[0] === "/") {
        path5 = path5.substr(1);
      }
      path5.split("/").some((part) => {
        current = current[part];
        return !current;
      });
      return current;
    };
    const merge2 = (target, sourceRoot, sourceURI, path5) => {
      const section = findSection(sourceRoot, path5);
      if (section) {
        for (const key in section) {
          if (Object.prototype.hasOwnProperty.call(section, key) && !Object.prototype.hasOwnProperty.call(target, key)) {
            target[key] = section[key];
          }
        }
      } else {
        resolveErrors.push(localize6("json.schema.invalidref", "$ref '{0}' in '{1}' can not be resolved.", path5, sourceURI));
      }
    };
    const resolveExternalLink = (node, uri, linkPath, parentSchemaURL, parentSchemaDependencies) => {
      if (contextService && !/^\w+:\/\/.*/.test(uri)) {
        uri = contextService.resolveRelativePath(uri, parentSchemaURL);
      }
      uri = this.normalizeId(uri);
      const referencedHandle = this.getOrAddSchemaHandle(uri);
      return referencedHandle.getUnresolvedSchema().then((unresolvedSchema) => {
        parentSchemaDependencies[uri] = true;
        if (unresolvedSchema.errors.length) {
          const loc = linkPath ? uri + "#" + linkPath : uri;
          resolveErrors.push(localize6("json.schema.problemloadingref", "Problems loading reference '{0}': {1}", loc, unresolvedSchema.errors[0]));
        }
        merge2(node, unresolvedSchema.schema, uri, linkPath);
        node.url = uri;
        return resolveRefs(node, unresolvedSchema.schema, uri, referencedHandle.dependencies);
      });
    };
    const resolveRefs = async (node, parentSchema, parentSchemaURL, parentSchemaDependencies) => {
      if (!node || typeof node !== "object") {
        return null;
      }
      const toWalk = [node];
      const seen = /* @__PURE__ */ new Set();
      const openPromises = [];
      const collectEntries = (...entries) => {
        for (const entry of entries) {
          if (typeof entry === "object") {
            toWalk.push(entry);
          }
        }
      };
      const collectMapEntries = (...maps) => {
        for (const map2 of maps) {
          if (typeof map2 === "object") {
            for (const key in map2) {
              const entry = map2[key];
              if (typeof entry === "object") {
                toWalk.push(entry);
              }
            }
          }
        }
      };
      const collectArrayEntries = (...arrays) => {
        for (const array of arrays) {
          if (Array.isArray(array)) {
            for (const entry of array) {
              if (typeof entry === "object") {
                toWalk.push(entry);
              }
            }
          }
        }
      };
      const handleRef = (next) => {
        const seenRefs = /* @__PURE__ */ new Set();
        while (next.$ref) {
          const ref = next.$ref;
          const segments = ref.split("#", 2);
          next._$ref = next.$ref;
          delete next.$ref;
          if (segments[0].length > 0) {
            openPromises.push(resolveExternalLink(next, segments[0], segments[1], parentSchemaURL, parentSchemaDependencies));
            return;
          } else {
            if (!seenRefs.has(ref)) {
              merge2(next, parentSchema, parentSchemaURL, segments[1]);
              seenRefs.add(ref);
            }
          }
        }
        collectEntries(next.items, next.additionalItems, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else);
        collectMapEntries(next.definitions, next.properties, next.patternProperties, next.dependencies);
        collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.items, next.schemaSequence);
      };
      if (parentSchemaURL.indexOf("#") > 0) {
        const segments = parentSchemaURL.split("#", 2);
        if (segments[0].length > 0 && segments[1].length > 0) {
          const newSchema = {};
          await resolveExternalLink(newSchema, segments[0], segments[1], parentSchemaURL, parentSchemaDependencies);
          for (const key in schema4) {
            if (key === "required") {
              continue;
            }
            if (Object.prototype.hasOwnProperty.call(schema4, key) && !Object.prototype.hasOwnProperty.call(newSchema, key)) {
              newSchema[key] = schema4[key];
            }
          }
          schema4 = newSchema;
        }
      }
      while (toWalk.length) {
        const next = toWalk.pop();
        if (seen.has(next)) {
          continue;
        }
        seen.add(next);
        handleRef(next);
      }
      return Promise.all(openPromises);
    };
    await resolveRefs(schema4, schema4, schemaURL, dependencies);
    return new ResolvedSchema(schema4, resolveErrors);
  }
  getSchemaForResource(resource, doc) {
    const resolveModelineSchema = () => {
      let schemaFromModeline = getSchemaFromModeline(doc);
      if (schemaFromModeline !== void 0) {
        if (!schemaFromModeline.startsWith("file:") && !schemaFromModeline.startsWith("http")) {
          let appendix = "";
          if (schemaFromModeline.indexOf("#") > 0) {
            const segments = schemaFromModeline.split("#", 2);
            schemaFromModeline = segments[0];
            appendix = segments[1];
          }
          if (!path2.isAbsolute(schemaFromModeline)) {
            const resUri = URI2.parse(resource);
            schemaFromModeline = URI2.file(path2.resolve(path2.parse(resUri.fsPath).dir, schemaFromModeline)).toString();
          } else {
            schemaFromModeline = URI2.file(schemaFromModeline).toString();
          }
          if (appendix.length > 0) {
            schemaFromModeline += "#" + appendix;
          }
        }
        return schemaFromModeline;
      }
    };
    const resolveSchemaForResource = (schemas2) => {
      const schemaHandle = super.createCombinedSchema(resource, schemas2);
      return schemaHandle.getResolvedSchema().then((schema4) => {
        if (schema4.schema && typeof schema4.schema === "object") {
          schema4.schema.url = schemaHandle.url;
        }
        if (schema4.schema && schema4.schema.schemaSequence && schema4.schema.schemaSequence[doc.currentDocIndex]) {
          return new ResolvedSchema(schema4.schema.schemaSequence[doc.currentDocIndex]);
        }
        return schema4;
      });
    };
    const resolveSchema = () => {
      const seen = /* @__PURE__ */ Object.create(null);
      const schemas2 = [];
      for (const entry of this.filePatternAssociations) {
        if (entry.matchesPattern(resource)) {
          for (const schemaId of entry.getURIs()) {
            if (!seen[schemaId]) {
              schemas2.push(schemaId);
              seen[schemaId] = true;
            }
          }
        }
      }
      if (schemas2.length > 0) {
        const highestPrioSchemas = this.highestPrioritySchemas(schemas2);
        return resolveSchemaForResource(highestPrioSchemas);
      }
      return Promise.resolve(null);
    };
    const modelineSchema = resolveModelineSchema();
    if (modelineSchema) {
      return resolveSchemaForResource([modelineSchema]);
    }
    if (this.customSchemaProvider) {
      return this.customSchemaProvider(resource).then((schemaUri) => {
        if (Array.isArray(schemaUri)) {
          if (schemaUri.length === 0) {
            return resolveSchema();
          }
          return Promise.all(schemaUri.map((schemaUri2) => {
            return this.resolveCustomSchema(schemaUri2, doc);
          })).then((schemas2) => {
            return {
              errors: [],
              schema: {
                allOf: schemas2.map((schemaObj) => {
                  return schemaObj.schema;
                })
              }
            };
          }, () => {
            return resolveSchema();
          });
        }
        if (!schemaUri) {
          return resolveSchema();
        }
        return this.resolveCustomSchema(schemaUri, doc);
      }).then((schema4) => {
        return schema4;
      }, () => {
        return resolveSchema();
      });
    } else {
      return resolveSchema();
    }
  }
  // Set the priority of a schema in the schema service
  addSchemaPriority(uri, priority) {
    let currSchemaArray = this.schemaPriorityMapping.get(uri);
    if (currSchemaArray) {
      currSchemaArray = currSchemaArray.add(priority);
      this.schemaPriorityMapping.set(uri, currSchemaArray);
    } else {
      this.schemaPriorityMapping.set(uri, (/* @__PURE__ */ new Set()).add(priority));
    }
  }
  /**
   * Search through all the schemas and find the ones with the highest priority
   */
  highestPrioritySchemas(schemas2) {
    let highestPrio = 0;
    const priorityMapping = /* @__PURE__ */ new Map();
    schemas2.forEach((schema4) => {
      const priority = this.schemaPriorityMapping.get(schema4) || [0];
      priority.forEach((prio) => {
        if (prio > highestPrio) {
          highestPrio = prio;
        }
        let currPriorityArray = priorityMapping.get(prio);
        if (currPriorityArray) {
          currPriorityArray = currPriorityArray.concat(schema4);
          priorityMapping.set(prio, currPriorityArray);
        } else {
          priorityMapping.set(prio, [schema4]);
        }
      });
    });
    return priorityMapping.get(highestPrio) || [];
  }
  async resolveCustomSchema(schemaUri, doc) {
    const unresolvedSchema = await this.loadSchema(schemaUri);
    const schema4 = await this.resolveSchemaContent(unresolvedSchema, schemaUri, []);
    if (schema4.schema && typeof schema4.schema === "object") {
      schema4.schema.url = schemaUri;
    }
    if (schema4.schema && schema4.schema.schemaSequence && schema4.schema.schemaSequence[doc.currentDocIndex]) {
      return new ResolvedSchema(schema4.schema.schemaSequence[doc.currentDocIndex], schema4.errors);
    }
    return schema4;
  }
  /**
   * Save a schema with schema ID and schema content.
   * Overrides previous schemas set for that schema ID.
   */
  async saveSchema(schemaId, schemaContent) {
    const id = this.normalizeId(schemaId);
    this.getOrAddSchemaHandle(id, schemaContent);
    this.schemaPriorityMapping.set(id, (/* @__PURE__ */ new Set()).add(SchemaPriority.Settings));
    return Promise.resolve(void 0);
  }
  /**
   * Delete schemas on specific path
   */
  async deleteSchemas(deletions) {
    deletions.schemas.forEach((s) => {
      this.deleteSchema(s);
    });
    return Promise.resolve(void 0);
  }
  /**
   * Delete a schema with schema ID.
   */
  async deleteSchema(schemaId) {
    const id = this.normalizeId(schemaId);
    if (this.schemasById[id]) {
      delete this.schemasById[id];
    }
    this.schemaPriorityMapping.delete(id);
    return Promise.resolve(void 0);
  }
  /**
   * Add content to a specified schema at a specified path
   */
  async addContent(additions) {
    const schema4 = await this.getResolvedSchema(additions.schema);
    if (schema4) {
      const resolvedSchemaLocation = this.resolveJSONSchemaToSection(schema4.schema, additions.path);
      if (typeof resolvedSchemaLocation === "object") {
        resolvedSchemaLocation[additions.key] = additions.content;
      }
      await this.saveSchema(additions.schema, schema4.schema);
    }
  }
  /**
   * Delete content in a specified schema at a specified path
   */
  async deleteContent(deletions) {
    const schema4 = await this.getResolvedSchema(deletions.schema);
    if (schema4) {
      const resolvedSchemaLocation = this.resolveJSONSchemaToSection(schema4.schema, deletions.path);
      if (typeof resolvedSchemaLocation === "object") {
        delete resolvedSchemaLocation[deletions.key];
      }
      await this.saveSchema(deletions.schema, schema4.schema);
    }
  }
  /**
   * Take a JSON Schema and the path that you would like to get to
   * @returns the JSON Schema resolved at that specific path
   */
  resolveJSONSchemaToSection(schema4, paths) {
    const splitPathway = paths.split("/");
    let resolvedSchemaLocation = schema4;
    for (const path5 of splitPathway) {
      if (path5 === "") {
        continue;
      }
      this.resolveNext(resolvedSchemaLocation, path5);
      resolvedSchemaLocation = resolvedSchemaLocation[path5];
    }
    return resolvedSchemaLocation;
  }
  /**
   * Resolve the next Object if they have compatible types
   * @param object a location in the JSON Schema
   * @param token the next token that you want to search for
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  resolveNext(object, token) {
    if (Array.isArray(object) && isNaN(token)) {
      throw new Error("Expected a number after the array object");
    } else if (typeof object === "object" && typeof token !== "string") {
      throw new Error("Expected a string after the object");
    }
  }
  /**
   * Everything below here is needed because we're importing from vscode-json-languageservice umd and we need
   * to provide a wrapper around the javascript methods we are calling since they have no type
   */
  normalizeId(id) {
    try {
      return URI2.parse(id).toString();
    } catch (e) {
      return id;
    }
  }
  /*
   * Everything below here is needed because we're importing from vscode-json-languageservice umd and we need
   * to provide a wrapper around the javascript methods we are calling since they have no type
   */
  getOrAddSchemaHandle(id, unresolvedSchemaContent) {
    return super.getOrAddSchemaHandle(id, unresolvedSchemaContent);
  }
  loadSchema(schemaUri) {
    const requestService = this.requestService;
    return super.loadSchema(schemaUri).then((unresolvedJsonSchema) => {
      if (unresolvedJsonSchema.errors && unresolvedJsonSchema.schema === void 0) {
        return requestService(schemaUri).then(
          (content) => {
            if (!content) {
              const errorMessage = localize6("json.schema.nocontent", "Unable to load schema from '{0}': No content. {1}", toDisplayString2(schemaUri), unresolvedJsonSchema.errors);
              return new UnresolvedSchema({}, [errorMessage]);
            }
            try {
              const schemaContent = parse3(content);
              return new UnresolvedSchema(schemaContent, []);
            } catch (yamlError) {
              const errorMessage = localize6("json.schema.invalidFormat", "Unable to parse content from '{0}': {1}.", toDisplayString2(schemaUri), yamlError);
              return new UnresolvedSchema({}, [errorMessage]);
            }
          },
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (error) => {
            let errorMessage = error.toString();
            const errorSplit = error.toString().split("Error: ");
            if (errorSplit.length > 1) {
              errorMessage = errorSplit[1];
            }
            return new UnresolvedSchema({}, [errorMessage]);
          }
        );
      }
      unresolvedJsonSchema.uri = schemaUri;
      if (this.schemaUriToNameAndDescription.has(schemaUri)) {
        const { name, description, versions } = this.schemaUriToNameAndDescription.get(schemaUri);
        unresolvedJsonSchema.schema.title = name != null ? name : unresolvedJsonSchema.schema.title;
        unresolvedJsonSchema.schema.description = description != null ? description : unresolvedJsonSchema.schema.description;
        unresolvedJsonSchema.schema.versions = versions != null ? versions : unresolvedJsonSchema.schema.versions;
      }
      return unresolvedJsonSchema;
    });
  }
  registerExternalSchema(uri, filePatterns, unresolvedSchema, name, description, versions) {
    if (name || description) {
      this.schemaUriToNameAndDescription.set(uri, { name, description, versions });
    }
    return super.registerExternalSchema(uri, filePatterns, unresolvedSchema);
  }
  clearExternalSchemas() {
    super.clearExternalSchemas();
  }
  setSchemaContributions(schemaContributions) {
    super.setSchemaContributions(schemaContributions);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getRegisteredSchemaIds(filter) {
    return super.getRegisteredSchemaIds(filter);
  }
  getResolvedSchema(schemaId) {
    return super.getResolvedSchema(schemaId);
  }
  onResourceChange(uri) {
    return super.onResourceChange(uri);
  }
};
function toDisplayString2(url) {
  try {
    const uri = URI2.parse(url);
    if (uri.scheme === "file") {
      return uri.fsPath;
    }
  } catch (e) {
  }
  return url;
}
var YAMLDocumentSymbols = class {
  constructor(schemaService, telemetry2) {
    this.telemetry = telemetry2;
    this.jsonDocumentSymbols = new JSONDocumentSymbols(schemaService);
    this.jsonDocumentSymbols.getKeyLabel = (property) => {
      const keyNode = property.keyNode.internalNode;
      let name = "";
      if (isMap(keyNode)) {
        name = "{}";
      } else if (isSeq(keyNode)) {
        name = "[]";
      } else {
        name = keyNode.source;
      }
      return name;
    };
  }
  findDocumentSymbols(document2, context = { resultLimit: Number.MAX_VALUE }) {
    var _a4;
    let results = [];
    try {
      const doc = yamlDocumentsCache.getYamlDocument(document2);
      if (!doc || doc["documents"].length === 0) {
        return null;
      }
      for (const yamlDoc of doc["documents"]) {
        if (yamlDoc.root) {
          results = results.concat(this.jsonDocumentSymbols.findDocumentSymbols(document2, yamlDoc, context));
        }
      }
    } catch (err) {
      (_a4 = this.telemetry) == null ? void 0 : _a4.sendError("yaml.documentSymbols.error", err);
    }
    return results;
  }
  findHierarchicalDocumentSymbols(document2, context = { resultLimit: Number.MAX_VALUE }) {
    var _a4;
    let results = [];
    try {
      const doc = yamlDocumentsCache.getYamlDocument(document2);
      if (!doc || doc["documents"].length === 0) {
        return null;
      }
      for (const yamlDoc of doc["documents"]) {
        if (yamlDoc.root) {
          results = results.concat(this.jsonDocumentSymbols.findDocumentSymbols2(document2, yamlDoc, context));
        }
      }
    } catch (err) {
      (_a4 = this.telemetry) == null ? void 0 : _a4.sendError("yaml.hierarchicalDocumentSymbols.error", err);
    }
    return results;
  }
};
function setKubernetesParserOption(jsonDocuments, option) {
  for (const jsonDoc of jsonDocuments) {
    jsonDoc.isKubernetes = option;
  }
}
var YAMLHover = class {
  constructor(schemaService, telemetry2) {
    this.telemetry = telemetry2;
    this.shouldHover = true;
    this.schemaService = schemaService;
  }
  configure(languageSettings) {
    if (languageSettings) {
      this.shouldHover = languageSettings.hover;
      this.indentation = languageSettings.indentation;
    }
  }
  doHover(document2, position, isKubernetes = false) {
    var _a4;
    try {
      if (!this.shouldHover || !document2) {
        return Promise.resolve(void 0);
      }
      const doc = yamlDocumentsCache.getYamlDocument(document2);
      const offset = document2.offsetAt(position);
      const currentDoc = matchOffsetToDocument(offset, doc);
      if (currentDoc === null) {
        return Promise.resolve(void 0);
      }
      setKubernetesParserOption(doc.documents, isKubernetes);
      const currentDocIndex = doc.documents.indexOf(currentDoc);
      currentDoc.currentDocIndex = currentDocIndex;
      return this.getHover(document2, position, currentDoc);
    } catch (error) {
      (_a4 = this.telemetry) == null ? void 0 : _a4.sendError("yaml.hover.error", error);
    }
  }
  // method copied from https://github.com/microsoft/vscode-json-languageservice/blob/2ea5ad3d2ffbbe40dea11cfe764a502becf113ce/src/services/jsonHover.ts#L23
  getHover(document2, position, doc) {
    const offset = document2.offsetAt(position);
    let node = doc.getNodeFromOffset(offset);
    if (!node || (node.type === "object" || node.type === "array") && offset > node.offset + 1 && offset < node.offset + node.length - 1) {
      return Promise.resolve(null);
    }
    const hoverRangeNode = node;
    if (node.type === "string") {
      const parent = node.parent;
      if (parent && parent.type === "property" && parent.keyNode === node) {
        node = parent.valueNode;
        if (!node) {
          return Promise.resolve(null);
        }
      }
    }
    const hoverRange = Range2.create(document2.positionAt(hoverRangeNode.offset), document2.positionAt(hoverRangeNode.offset + hoverRangeNode.length));
    const createHover = (contents) => {
      const markupContent = {
        kind: MarkupKind.Markdown,
        value: contents
      };
      const result = {
        contents: markupContent,
        range: hoverRange
      };
      return result;
    };
    const removePipe = (value) => {
      return value.replace(/\s\|\|\s*$/, "");
    };
    return this.schemaService.getSchemaForResource(document2.uri, doc).then((schema4) => {
      if (schema4 && node && !schema4.errors.length) {
        const matchingSchemas = doc.getMatchingSchemas(schema4.schema, node.offset);
        let title = void 0;
        let markdownDescription = void 0;
        let markdownEnumDescriptions = [];
        const markdownExamples = [];
        const markdownEnums = [];
        matchingSchemas.every((s) => {
          if ((s.node === node || node.type === "property" && node.valueNode === s.node) && !s.inverted && s.schema) {
            title = title || s.schema.title || s.schema.closestTitle;
            markdownDescription = markdownDescription || s.schema.markdownDescription || this.toMarkdown(s.schema.description);
            if (s.schema.enum) {
              if (s.schema.markdownEnumDescriptions) {
                markdownEnumDescriptions = s.schema.markdownEnumDescriptions;
              } else if (s.schema.enumDescriptions) {
                markdownEnumDescriptions = s.schema.enumDescriptions.map(this.toMarkdown, this);
              } else {
                markdownEnumDescriptions = [];
              }
              s.schema.enum.forEach((enumValue, idx) => {
                if (typeof enumValue !== "string") {
                  enumValue = JSON.stringify(enumValue);
                }
                markdownEnums.push({
                  value: enumValue,
                  description: markdownEnumDescriptions[idx]
                });
              });
            }
            if (s.schema.anyOf && isAllSchemasMatched(node, matchingSchemas, s.schema)) {
              title = "";
              markdownDescription = s.schema.description ? s.schema.description + "\n" : "";
              s.schema.anyOf.forEach((childSchema, index) => {
                title += childSchema.title || s.schema.closestTitle || "";
                markdownDescription += childSchema.markdownDescription || this.toMarkdown(childSchema.description) || "";
                if (index !== s.schema.anyOf.length - 1) {
                  title += " || ";
                  markdownDescription += " || ";
                }
              });
              title = removePipe(title);
              markdownDescription = removePipe(markdownDescription);
            }
            if (s.schema.examples) {
              s.schema.examples.forEach((example) => {
                markdownExamples.push(stringify3(example, null, 2));
              });
            }
          }
          return true;
        });
        let result = "";
        if (title) {
          result = "#### " + this.toMarkdown(title);
        }
        if (markdownDescription) {
          result = ensureLineBreak(result);
          result += markdownDescription;
        }
        if (markdownEnums.length !== 0) {
          result = ensureLineBreak(result);
          result += "Allowed Values:\n\n";
          markdownEnums.forEach((me) => {
            if (me.description) {
              result += `* \`${toMarkdownCodeBlock(me.value)}\`: ${me.description}
`;
            } else {
              result += `* \`${toMarkdownCodeBlock(me.value)}\`
`;
            }
          });
        }
        if (markdownExamples.length !== 0) {
          markdownExamples.forEach((example) => {
            result = ensureLineBreak(result);
            result += "Example:\n\n";
            result += `\`\`\`yaml
${example}\`\`\`
`;
          });
        }
        if (result.length > 0 && schema4.schema.url) {
          result = ensureLineBreak(result);
          result += `Source: [${getSchemaName(schema4.schema)}](${schema4.schema.url})`;
        }
        return createHover(result);
      }
      return null;
    });
  }
  // copied from https://github.com/microsoft/vscode-json-languageservice/blob/2ea5ad3d2ffbbe40dea11cfe764a502becf113ce/src/services/jsonHover.ts#L112
  toMarkdown(plain) {
    if (plain) {
      let escaped = plain.replace(/([^\n\r])(\r?\n)([^\n\r])/gm, "$1\n\n$3");
      escaped = escaped.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
      if (this.indentation !== void 0) {
        const indentationMatchRegex = new RegExp(` {${this.indentation.length}}`, "g");
        escaped = escaped.replace(indentationMatchRegex, "&emsp;");
      }
      return escaped;
    }
    return void 0;
  }
};
function ensureLineBreak(content) {
  if (content.length === 0) {
    return content;
  }
  if (!content.endsWith("\n")) {
    content += "\n";
  }
  return content + "\n";
}
function getSchemaName(schema4) {
  let result = "JSON Schema";
  const urlString = schema4.url;
  if (urlString) {
    const url = URI2.parse(urlString);
    result = path3.basename(url.fsPath);
  } else if (schema4.title) {
    result = schema4.title;
  }
  return result;
}
function toMarkdownCodeBlock(content) {
  if (content.indexOf("`") !== -1) {
    return "`` " + content + " ``";
  }
  return content;
}
function isAllSchemasMatched(node, matchingSchemas, schema4) {
  let count = 0;
  for (const matchSchema of matchingSchemas) {
    if (node === matchSchema.node && matchSchema.schema !== schema4) {
      schema4.anyOf.forEach((childSchema) => {
        if (matchSchema.schema.title === childSchema.title && matchSchema.schema.description === childSchema.description && matchSchema.schema.properties === childSchema.properties) {
          count++;
        }
      });
    }
  }
  return count === schema4.anyOf.length;
}
var UnusedAnchorsValidator = class {
  validate(document2, yamlDoc) {
    const result = [];
    const anchors = /* @__PURE__ */ new Set();
    const usedAnchors = /* @__PURE__ */ new Set();
    const anchorParent = /* @__PURE__ */ new Map();
    visit2(yamlDoc.internalDocument, (key, node, path5) => {
      if (!isNode(node)) {
        return;
      }
      if ((isCollection(node) || isScalar(node)) && node.anchor) {
        anchors.add(node);
        anchorParent.set(node, path5[path5.length - 1]);
      }
      if (isAlias(node)) {
        usedAnchors.add(node.resolve(yamlDoc.internalDocument));
      }
    });
    for (const anchor of anchors) {
      if (!usedAnchors.has(anchor)) {
        const aToken = this.getAnchorNode(anchorParent.get(anchor), anchor);
        if (aToken) {
          const range = Range2.create(document2.positionAt(aToken.offset), document2.positionAt(aToken.offset + aToken.source.length));
          const warningDiagnostic = Diagnostic.create(range, `Unused anchor "${aToken.source}"`, DiagnosticSeverity.Hint, 0);
          warningDiagnostic.tags = [DiagnosticTag.Unnecessary];
          result.push(warningDiagnostic);
        }
      }
    }
    return result;
  }
  getAnchorNode(parentNode, node) {
    if (parentNode && parentNode.srcToken) {
      const token = parentNode.srcToken;
      if (isCollectionItem(token)) {
        return getAnchorFromCollectionItem(token);
      } else if (cst_exports.isCollection(token)) {
        for (const t of token.items) {
          if (node.srcToken !== t.value)
            continue;
          const anchor = getAnchorFromCollectionItem(t);
          if (anchor) {
            return anchor;
          }
        }
      }
    }
    return void 0;
  }
};
function getAnchorFromCollectionItem(token) {
  for (const t of token.start) {
    if (t.type === "anchor") {
      return t;
    }
  }
  if (token.sep && Array.isArray(token.sep)) {
    for (const t of token.sep) {
      if (t.type === "anchor") {
        return t;
      }
    }
  }
}
var YAMLStyleValidator = class {
  constructor(settings) {
    this.forbidMapping = settings.flowMapping === "forbid";
    this.forbidSequence = settings.flowSequence === "forbid";
  }
  validate(document2, yamlDoc) {
    const result = [];
    visit2(yamlDoc.internalDocument, (key, node) => {
      var _a4, _b2;
      if (this.forbidMapping && isMap(node) && ((_a4 = node.srcToken) == null ? void 0 : _a4.type) === "flow-collection") {
        result.push(Diagnostic.create(this.getRangeOf(document2, node.srcToken), "Flow style mapping is forbidden", DiagnosticSeverity.Error, "flowMap"));
      }
      if (this.forbidSequence && isSeq(node) && ((_b2 = node.srcToken) == null ? void 0 : _b2.type) === "flow-collection") {
        result.push(Diagnostic.create(this.getRangeOf(document2, node.srcToken), "Flow style sequence is forbidden", DiagnosticSeverity.Error, "flowSeq"));
      }
    });
    return result;
  }
  getRangeOf(document2, node) {
    return Range2.create(document2.positionAt(node.start.offset), document2.positionAt(node.end.pop().offset));
  }
};
var MapKeyOrderValidator = class {
  validate(document2, yamlDoc) {
    const result = [];
    visit2(yamlDoc.internalDocument, (key, node) => {
      if (isMap(node)) {
        for (let i = 1; i < node.items.length; i++) {
          if (compare(node.items[i - 1], node.items[i]) > 0) {
            const range = createRange2(document2, node.items[i - 1]);
            result.push(Diagnostic.create(range, `Wrong ordering of key "${node.items[i - 1].key}" in mapping`, DiagnosticSeverity.Error, "mapKeyOrder"));
          }
        }
      }
    });
    return result;
  }
};
function createRange2(document2, node) {
  var _a4, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  const start = (_f = (_c = (_a4 = node == null ? void 0 : node.srcToken.start[0]) == null ? void 0 : _a4.offset) != null ? _c : (_b2 = node == null ? void 0 : node.srcToken) == null ? void 0 : _b2.key.offset) != null ? _f : (_e = (_d = node == null ? void 0 : node.srcToken) == null ? void 0 : _d.sep[0]) == null ? void 0 : _e.offset;
  const end = ((_g = node == null ? void 0 : node.srcToken) == null ? void 0 : _g.value.offset) || ((_i = (_h = node == null ? void 0 : node.srcToken) == null ? void 0 : _h.sep[0]) == null ? void 0 : _i.offset) || ((_j = node == null ? void 0 : node.srcToken) == null ? void 0 : _j.key.offset) || ((_k = node == null ? void 0 : node.srcToken.start[node.srcToken.start.length - 1]) == null ? void 0 : _k.offset);
  return Range2.create(document2.positionAt(start), document2.positionAt(end));
}
function compare(thiz, that) {
  const thatKey = String(that.key);
  const thisKey = String(thiz.key);
  return thisKey.localeCompare(thatKey);
}
var yamlDiagToLSDiag = (yamlDiag, textDocument) => {
  const start = textDocument.positionAt(yamlDiag.location.start);
  const range = {
    start,
    end: yamlDiag.location.toLineEnd ? Position2.create(start.line, new TextBuffer(textDocument).getLineLength(start.line)) : textDocument.positionAt(yamlDiag.location.end)
  };
  return Diagnostic.create(range, yamlDiag.message, yamlDiag.severity, yamlDiag.code, YAML_SOURCE);
};
var YAMLValidation = class {
  constructor(schemaService, telemetry2) {
    this.telemetry = telemetry2;
    this.validators = [];
    this.MATCHES_MULTIPLE = "Matches multiple schemas when only one must validate.";
    this.validationEnabled = true;
    this.jsonValidation = new JSONValidation(schemaService, Promise);
  }
  configure(settings) {
    this.validators = [];
    if (settings) {
      this.validationEnabled = settings.validate;
      this.customTags = settings.customTags;
      this.disableAdditionalProperties = settings.disableAdditionalProperties;
      this.yamlVersion = settings.yamlVersion;
      if (settings.flowMapping === "forbid" || settings.flowSequence === "forbid") {
        this.validators.push(new YAMLStyleValidator(settings));
      }
      if (settings.keyOrdering) {
        this.validators.push(new MapKeyOrderValidator());
      }
    }
    this.validators.push(new UnusedAnchorsValidator());
  }
  async doValidation(textDocument, isKubernetes = false) {
    var _a4;
    if (!this.validationEnabled) {
      return Promise.resolve([]);
    }
    const validationResult = [];
    try {
      const yamlDocument = yamlDocumentsCache.getYamlDocument(textDocument, { customTags: this.customTags, yamlVersion: this.yamlVersion }, true);
      let index = 0;
      for (const currentYAMLDoc of yamlDocument.documents) {
        currentYAMLDoc.isKubernetes = isKubernetes;
        currentYAMLDoc.currentDocIndex = index;
        currentYAMLDoc.disableAdditionalProperties = this.disableAdditionalProperties;
        currentYAMLDoc.uri = textDocument.uri;
        const validation = await this.jsonValidation.doValidation(textDocument, currentYAMLDoc);
        const syd = currentYAMLDoc;
        if (syd.errors.length > 0) {
          validationResult.push(...syd.errors);
        }
        if (syd.warnings.length > 0) {
          validationResult.push(...syd.warnings);
        }
        validationResult.push(...validation);
        validationResult.push(...this.runAdditionalValidators(textDocument, currentYAMLDoc));
        index++;
      }
    } catch (err) {
      (_a4 = this.telemetry) == null ? void 0 : _a4.sendError("yaml.validation.error", err);
    }
    let previousErr;
    const foundSignatures = /* @__PURE__ */ new Set();
    const duplicateMessagesRemoved = [];
    for (let err of validationResult) {
      if (isKubernetes && err.message === this.MATCHES_MULTIPLE) {
        continue;
      }
      if (Object.prototype.hasOwnProperty.call(err, "location")) {
        err = yamlDiagToLSDiag(err, textDocument);
      }
      if (!err.source) {
        err.source = YAML_SOURCE;
      }
      if (previousErr && previousErr.message === err.message && previousErr.range.end.line === err.range.start.line && Math.abs(previousErr.range.end.character - err.range.end.character) >= 1) {
        previousErr.range.end = err.range.end;
        continue;
      } else {
        previousErr = err;
      }
      const errSig = err.range.start.line + " " + err.range.start.character + " " + err.message;
      if (!foundSignatures.has(errSig)) {
        duplicateMessagesRemoved.push(err);
        foundSignatures.add(errSig);
      }
    }
    return duplicateMessagesRemoved;
  }
  runAdditionalValidators(document2, yarnDoc) {
    const result = [];
    for (const validator of this.validators) {
      result.push(...validator.validate(document2, yarnDoc));
    }
    return result;
  }
};
var YAMLFormatter = class {
  constructor() {
    this.formatterEnabled = true;
  }
  configure(shouldFormat) {
    if (shouldFormat) {
      this.formatterEnabled = shouldFormat.format;
    }
  }
  async format(document2, options = {}) {
    if (!this.formatterEnabled) {
      return [];
    }
    try {
      const text = document2.getText();
      const prettierOptions = {
        parser: "yaml",
        plugins: [parser],
        // --- FormattingOptions ---
        tabWidth: options.tabWidth || options.tabSize,
        // --- CustomFormatterOptions ---
        singleQuote: options.singleQuote,
        bracketSpacing: options.bracketSpacing,
        // 'preserve' is the default for Options.proseWrap. See also server.ts
        proseWrap: "always" === options.proseWrap ? "always" : "never" === options.proseWrap ? "never" : "preserve",
        printWidth: options.printWidth
      };
      const formatted = await (0, import_standalone.format)(text, prettierOptions);
      return [TextEdit.replace(Range2.create(Position2.create(0, 0), document2.positionAt(text.length)), formatted)];
    } catch (error) {
      return [];
    }
  }
};
var YamlLinks = class {
  constructor(telemetry2) {
    this.telemetry = telemetry2;
  }
  findLinks(document2) {
    var _a4;
    try {
      const doc = yamlDocumentsCache.getYamlDocument(document2);
      const linkPromises = [];
      for (const yamlDoc of doc.documents) {
        linkPromises.push(findLinks(document2, yamlDoc));
      }
      return Promise.all(linkPromises).then((yamlLinkArray) => [].concat(...yamlLinkArray));
    } catch (err) {
      (_a4 = this.telemetry) == null ? void 0 : _a4.sendError("yaml.documentLink.error", err);
    }
  }
};
function getFoldingRanges(document2, context) {
  if (!document2) {
    return;
  }
  const result = [];
  const doc = yamlDocumentsCache.getYamlDocument(document2);
  for (const ymlDoc of doc.documents) {
    if (doc.documents.length > 1) {
      result.push(createNormalizedFolding(document2, ymlDoc.root));
    }
    ymlDoc.visit((node) => {
      var _a4;
      if (node.type === "object" && ((_a4 = node.parent) == null ? void 0 : _a4.type) === "array") {
        result.push(createNormalizedFolding(document2, node));
      }
      if (node.type === "property" && node.valueNode) {
        switch (node.valueNode.type) {
          case "array":
          case "object":
            result.push(createNormalizedFolding(document2, node));
            break;
          case "string": {
            const nodePosn = document2.positionAt(node.offset);
            const valuePosn = document2.positionAt(node.valueNode.offset + node.valueNode.length);
            if (nodePosn.line !== valuePosn.line) {
              result.push(createNormalizedFolding(document2, node));
            }
            break;
          }
          default:
            return true;
        }
      }
      return true;
    });
  }
  const rangeLimit = context && context.rangeLimit;
  if (typeof rangeLimit !== "number" || result.length <= rangeLimit) {
    return result;
  }
  if (context && context.onRangeLimitExceeded) {
    context.onRangeLimitExceeded(document2.uri);
  }
  return result.slice(0, context.rangeLimit);
}
function createNormalizedFolding(document2, node) {
  const startPos = document2.positionAt(node.offset);
  let endPos = document2.positionAt(node.offset + node.length);
  const textFragment = document2.getText(Range2.create(startPos, endPos));
  const newLength = textFragment.length - textFragment.trimRight().length;
  if (newLength > 0) {
    endPos = document2.positionAt(node.offset + node.length - newLength);
  }
  return FoldingRange.create(startPos.line, endPos.line, startPos.character, endPos.character);
}
var YamlCommands;
(function(YamlCommands2) {
  YamlCommands2["JUMP_TO_SCHEMA"] = "jumpToSchema";
})(YamlCommands || (YamlCommands = {}));
var FlowStyleRewriter = class {
  constructor(indentation) {
    this.indentation = indentation;
  }
  write(node) {
    if (node.internalNode.srcToken["type"] !== "flow-collection") {
      return null;
    }
    const collection = node.internalNode.srcToken;
    const blockType = collection.start.type === "flow-map-start" ? "block-map" : "block-seq";
    const parentType = node.parent.type;
    const blockStyle = {
      type: blockType,
      offset: collection.offset,
      indent: collection.indent,
      items: []
    };
    for (const item of collection.items) {
      cst_exports.visit(item, ({ key, sep: sep2, value }) => {
        if (blockType === "block-map") {
          const start = [{ type: "space", indent: 0, offset: key.offset, source: this.indentation }];
          if (parentType === "property") {
            start.unshift({ type: "newline", indent: 0, offset: key.offset, source: "\n" });
          }
          blockStyle.items.push({
            start,
            key,
            sep: sep2,
            value
          });
        } else if (blockType === "block-seq") {
          blockStyle.items.push({
            start: [
              { type: "newline", indent: 0, offset: value.offset, source: "\n" },
              { type: "space", indent: 0, offset: value.offset, source: this.indentation },
              { type: "seq-item-ind", indent: 0, offset: value.offset, source: "-" },
              { type: "space", indent: 0, offset: value.offset, source: " " }
            ],
            value
          });
        }
        if (value.type === "flow-collection") {
          return visit2.SKIP;
        }
      });
    }
    return cst_exports.stringify(blockStyle);
  }
};
var cloneDeep = structuredClone;
var YamlCodeActions = class {
  constructor(clientCapabilities) {
    this.clientCapabilities = clientCapabilities;
    this.indentation = "  ";
  }
  configure(settings) {
    this.indentation = settings.indentation;
  }
  getCodeAction(document2, params) {
    if (!params.context.diagnostics) {
      return;
    }
    const result = [];
    result.push(...this.getConvertToBooleanActions(params.context.diagnostics, document2));
    result.push(...this.getJumpToSchemaActions(params.context.diagnostics));
    result.push(...this.getTabToSpaceConverting(params.context.diagnostics, document2));
    result.push(...this.getUnusedAnchorsDelete(params.context.diagnostics, document2));
    result.push(...this.getConvertToBlockStyleActions(params.context.diagnostics, document2));
    result.push(...this.getKeyOrderActions(params.context.diagnostics, document2));
    result.push(...this.getQuickFixForPropertyOrValueMismatch(params.context.diagnostics, document2));
    return result;
  }
  getJumpToSchemaActions(diagnostics) {
    var _a4, _b2, _c, _d, _e;
    const isOpenTextDocumentEnabled = (_d = (_c = (_b2 = (_a4 = this.clientCapabilities) == null ? void 0 : _a4.window) == null ? void 0 : _b2.showDocument) == null ? void 0 : _c.support) != null ? _d : false;
    if (!isOpenTextDocumentEnabled) {
      return [];
    }
    const schemaUriToDiagnostic = /* @__PURE__ */ new Map();
    for (const diagnostic of diagnostics) {
      const schemaUri = ((_e = diagnostic.data) == null ? void 0 : _e.schemaUri) || [];
      for (const schemaUriStr of schemaUri) {
        if (schemaUriStr) {
          if (!schemaUriToDiagnostic.has(schemaUriStr)) {
            schemaUriToDiagnostic.set(schemaUriStr, []);
          }
          schemaUriToDiagnostic.get(schemaUriStr).push(diagnostic);
        }
      }
    }
    const result = [];
    for (const schemaUri of schemaUriToDiagnostic.keys()) {
      const action = CodeAction.create(`Jump to schema location (${path4.basename(schemaUri)})`, Command2.create("JumpToSchema", YamlCommands.JUMP_TO_SCHEMA, schemaUri));
      action.diagnostics = schemaUriToDiagnostic.get(schemaUri);
      result.push(action);
    }
    return result;
  }
  getTabToSpaceConverting(diagnostics, document2) {
    const result = [];
    const textBuff = new TextBuffer(document2);
    const processedLine = [];
    for (const diag of diagnostics) {
      if (diag.message === "Using tabs can lead to unpredictable results") {
        if (processedLine.includes(diag.range.start.line)) {
          continue;
        }
        const lineContent = textBuff.getLineContent(diag.range.start.line);
        let replacedTabs = 0;
        let newText = "";
        for (let i = diag.range.start.character; i <= diag.range.end.character; i++) {
          const char = lineContent.charAt(i);
          if (char !== "	") {
            break;
          }
          replacedTabs++;
          newText += this.indentation;
        }
        processedLine.push(diag.range.start.line);
        let resultRange = diag.range;
        if (replacedTabs !== diag.range.end.character - diag.range.start.character) {
          resultRange = Range2.create(diag.range.start, Position2.create(diag.range.end.line, diag.range.start.character + replacedTabs));
        }
        result.push(CodeAction.create("Convert Tab to Spaces", createWorkspaceEdit(document2.uri, [TextEdit.replace(resultRange, newText)]), CodeActionKind.QuickFix));
      }
    }
    if (result.length !== 0) {
      const replaceEdits = [];
      for (let i = 0; i <= textBuff.getLineCount(); i++) {
        const lineContent = textBuff.getLineContent(i);
        let replacedTabs = 0;
        let newText = "";
        for (let j = 0; j < lineContent.length; j++) {
          const char = lineContent.charAt(j);
          if (char !== " " && char !== "	") {
            if (replacedTabs !== 0) {
              replaceEdits.push(TextEdit.replace(Range2.create(i, j - replacedTabs, i, j), newText));
              replacedTabs = 0;
              newText = "";
            }
            break;
          }
          if (char === " " && replacedTabs !== 0) {
            replaceEdits.push(TextEdit.replace(Range2.create(i, j - replacedTabs, i, j), newText));
            replacedTabs = 0;
            newText = "";
            continue;
          }
          if (char === "	") {
            newText += this.indentation;
            replacedTabs++;
          }
        }
        if (replacedTabs !== 0) {
          replaceEdits.push(TextEdit.replace(Range2.create(i, 0, i, textBuff.getLineLength(i)), newText));
        }
      }
      if (replaceEdits.length > 0) {
        result.push(CodeAction.create("Convert all Tabs to Spaces", createWorkspaceEdit(document2.uri, replaceEdits), CodeActionKind.QuickFix));
      }
    }
    return result;
  }
  getUnusedAnchorsDelete(diagnostics, document2) {
    const result = [];
    const buffer = new TextBuffer(document2);
    for (const diag of diagnostics) {
      if (diag.message.startsWith("Unused anchor") && diag.source === YAML_SOURCE) {
        const range = Range2.create(diag.range.start, diag.range.end);
        const actual = buffer.getText(range);
        const lineContent = buffer.getLineContent(range.end.line);
        const lastWhitespaceChar = getFirstNonWhitespaceCharacterAfterOffset(lineContent, range.end.character);
        range.end.character = lastWhitespaceChar;
        const action = CodeAction.create(`Delete unused anchor: ${actual}`, createWorkspaceEdit(document2.uri, [TextEdit.del(range)]), CodeActionKind.QuickFix);
        action.diagnostics = [diag];
        result.push(action);
      }
    }
    return result;
  }
  getConvertToBooleanActions(diagnostics, document2) {
    const results = [];
    for (const diagnostic of diagnostics) {
      if (diagnostic.message === 'Incorrect type. Expected "boolean".') {
        const value = document2.getText(diagnostic.range).toLocaleLowerCase();
        if (value === '"true"' || value === '"false"' || value === "'true'" || value === "'false'") {
          const newValue = value.includes("true") ? "true" : "false";
          results.push(CodeAction.create("Convert to boolean", createWorkspaceEdit(document2.uri, [TextEdit.replace(diagnostic.range, newValue)]), CodeActionKind.QuickFix));
        }
      }
    }
    return results;
  }
  getConvertToBlockStyleActions(diagnostics, document2) {
    const results = [];
    for (const diagnostic of diagnostics) {
      if (diagnostic.code === "flowMap" || diagnostic.code === "flowSeq") {
        const node = getNodeForDiagnostic(document2, diagnostic);
        if (isMap(node.internalNode) || isSeq(node.internalNode)) {
          const blockTypeDescription = isMap(node.internalNode) ? "map" : "sequence";
          const rewriter = new FlowStyleRewriter(this.indentation);
          results.push(CodeAction.create(`Convert to block style ${blockTypeDescription}`, createWorkspaceEdit(document2.uri, [TextEdit.replace(diagnostic.range, rewriter.write(node))]), CodeActionKind.QuickFix));
        }
      }
    }
    return results;
  }
  getKeyOrderActions(diagnostics, document2) {
    var _a4, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    const results = [];
    for (const diagnostic of diagnostics) {
      if ((diagnostic == null ? void 0 : diagnostic.code) === "mapKeyOrder") {
        let node = getNodeForDiagnostic(document2, diagnostic);
        while (node && node.type !== "object") {
          node = node.parent;
        }
        if (node && isMap(node.internalNode)) {
          const sorted = cloneDeep(node.internalNode);
          if ((sorted.srcToken.type === "block-map" || sorted.srcToken.type === "flow-collection") && (node.internalNode.srcToken.type === "block-map" || node.internalNode.srcToken.type === "flow-collection")) {
            sorted.srcToken.items.sort((a2, b) => {
              if (a2.key && b.key && cst_exports.isScalar(a2.key) && cst_exports.isScalar(b.key)) {
                return a2.key.source.localeCompare(b.key.source);
              }
              if (!a2.key && b.key) {
                return -1;
              }
              if (a2.key && !b.key) {
                return 1;
              }
              if (!a2.key && !b.key) {
                return 0;
              }
            });
            for (let i = 0; i < sorted.srcToken.items.length; i++) {
              const item = sorted.srcToken.items[i];
              const uItem = node.internalNode.srcToken.items[i];
              item.start = uItem.start;
              if (((_a4 = item.value) == null ? void 0 : _a4.type) === "alias" || ((_b2 = item.value) == null ? void 0 : _b2.type) === "scalar" || ((_c = item.value) == null ? void 0 : _c.type) === "single-quoted-scalar" || ((_d = item.value) == null ? void 0 : _d.type) === "double-quoted-scalar") {
                const newLineIndex = (_g = (_f = (_e = item.value) == null ? void 0 : _e.end) == null ? void 0 : _f.findIndex((p) => p.type === "newline")) != null ? _g : -1;
                let newLineToken = null;
                if (((_h = uItem.value) == null ? void 0 : _h.type) === "block-scalar") {
                  newLineToken = (_j = (_i = uItem.value) == null ? void 0 : _i.props) == null ? void 0 : _j.find((p) => p.type === "newline");
                } else if (cst_exports.isScalar(uItem.value)) {
                  newLineToken = (_l = (_k = uItem.value) == null ? void 0 : _k.end) == null ? void 0 : _l.find((p) => p.type === "newline");
                }
                if (newLineToken && newLineIndex < 0) {
                  item.value.end = (_m = item.value.end) != null ? _m : [];
                  item.value.end.push(newLineToken);
                }
                if (!newLineToken && newLineIndex > -1) {
                  item.value.end.splice(newLineIndex, 1);
                }
              } else if (((_n = item.value) == null ? void 0 : _n.type) === "block-scalar") {
                const newline = item.value.props.find((p) => p.type === "newline");
                if (!newline) {
                  item.value.props.push({ type: "newline", indent: 0, offset: item.value.offset, source: "\n" });
                }
              }
            }
          }
          const replaceRange = Range2.create(document2.positionAt(node.offset), document2.positionAt(node.offset + node.length));
          results.push(CodeAction.create("Fix key order for this map", createWorkspaceEdit(document2.uri, [TextEdit.replace(replaceRange, cst_exports.stringify(sorted.srcToken))]), CodeActionKind.QuickFix));
        }
      }
    }
    return results;
  }
  /**
   * Check if diagnostic contains info for quick fix
   * Supports Enum/Const/Property mismatch
   */
  getPossibleQuickFixValues(diagnostic) {
    if (typeof diagnostic.data !== "object") {
      return;
    }
    if (diagnostic.code === ErrorCode.EnumValueMismatch && "values" in diagnostic.data && Array.isArray(diagnostic.data.values)) {
      return diagnostic.data.values;
    } else if (diagnostic.code === ErrorCode.PropertyExpected && "properties" in diagnostic.data && Array.isArray(diagnostic.data.properties)) {
      return diagnostic.data.properties;
    }
  }
  getQuickFixForPropertyOrValueMismatch(diagnostics, document2) {
    const results = [];
    for (const diagnostic of diagnostics) {
      const values = this.getPossibleQuickFixValues(diagnostic);
      if (!(values == null ? void 0 : values.length)) {
        continue;
      }
      for (const value of values) {
        results.push(CodeAction.create(value, createWorkspaceEdit(document2.uri, [TextEdit.replace(diagnostic.range, value)]), CodeActionKind.QuickFix));
      }
    }
    return results;
  }
};
function getNodeForDiagnostic(document2, diagnostic) {
  const yamlDocuments = yamlDocumentsCache.getYamlDocument(document2);
  const startOffset = document2.offsetAt(diagnostic.range.start);
  const yamlDoc = matchOffsetToDocument(startOffset, yamlDocuments);
  const node = yamlDoc.getNodeFromOffset(startOffset);
  return node;
}
function createWorkspaceEdit(uri, edits) {
  const changes = {};
  changes[uri] = edits;
  const edit = {
    changes
  };
  return edit;
}
function doDocumentOnTypeFormatting(document2, params) {
  const { position } = params;
  const tb = new TextBuffer(document2);
  if (params.ch === "\n") {
    const previousLine = tb.getLineContent(position.line - 1);
    if (previousLine.trimRight().endsWith(":")) {
      const currentLine = tb.getLineContent(position.line);
      const subLine = currentLine.substring(position.character, currentLine.length);
      const isInArray = previousLine.indexOf(" - ") !== -1;
      if (subLine.trimRight().length === 0) {
        const indentationFix = position.character - (previousLine.length - previousLine.trimLeft().length);
        if (indentationFix === params.options.tabSize && !isInArray) {
          return;
        }
        const result = [];
        if (currentLine.length > 0) {
          result.push(TextEdit.del(Range2.create(position, Position2.create(position.line, currentLine.length - 1))));
        }
        result.push(TextEdit.insert(position, " ".repeat(params.options.tabSize + (isInArray ? 2 - indentationFix : 0))));
        return result;
      }
      if (isInArray) {
        return [TextEdit.insert(position, " ".repeat(params.options.tabSize))];
      }
    }
    if (previousLine.trimRight().endsWith("|")) {
      return [TextEdit.insert(position, " ".repeat(params.options.tabSize))];
    }
    if (previousLine.includes(" - ") && !previousLine.includes(": ")) {
      return [TextEdit.insert(position, "- ")];
    }
    if (previousLine.includes(" - ") && previousLine.includes(": ")) {
      return [TextEdit.insert(position, "  ")];
    }
  }
}
function getSchemaUrls(schema4) {
  const result = /* @__PURE__ */ new Map();
  if (!schema4) {
    return result;
  }
  if (schema4.url) {
    if (schema4.url.startsWith("schemaservice://combinedSchema/")) {
      addSchemasForOf(schema4, result);
    } else {
      result.set(schema4.url, schema4);
    }
  } else {
    addSchemasForOf(schema4, result);
  }
  return result;
}
function addSchemasForOf(schema4, result) {
  if (schema4.allOf) {
    addInnerSchemaUrls(schema4.allOf, result);
  }
  if (schema4.anyOf) {
    addInnerSchemaUrls(schema4.anyOf, result);
  }
  if (schema4.oneOf) {
    addInnerSchemaUrls(schema4.oneOf, result);
  }
}
function addInnerSchemaUrls(schemas2, result) {
  for (const subSchema of schemas2) {
    if (!isBoolean2(subSchema) && subSchema.url && !result.has(subSchema.url)) {
      result.set(subSchema.url, subSchema);
    }
  }
}
var YamlCodeLens = class {
  constructor(schemaService, telemetry2) {
    this.schemaService = schemaService;
    this.telemetry = telemetry2;
  }
  async getCodeLens(document2) {
    var _a4;
    const result = [];
    try {
      const yamlDocument = yamlDocumentsCache.getYamlDocument(document2);
      let schemaUrls = /* @__PURE__ */ new Map();
      for (const currentYAMLDoc of yamlDocument.documents) {
        const schema4 = await this.schemaService.getSchemaForResource(document2.uri, currentYAMLDoc);
        if (schema4 == null ? void 0 : schema4.schema) {
          schemaUrls = new Map([...getSchemaUrls(schema4 == null ? void 0 : schema4.schema), ...schemaUrls]);
        }
      }
      for (const urlToSchema of schemaUrls) {
        const lens = CodeLens.create(Range2.create(0, 0, 0, 0));
        lens.command = {
          title: getSchemaTitle(urlToSchema[1], urlToSchema[0]),
          command: YamlCommands.JUMP_TO_SCHEMA,
          arguments: [urlToSchema[0]]
        };
        result.push(lens);
      }
    } catch (err) {
      (_a4 = this.telemetry) == null ? void 0 : _a4.sendError("yaml.codeLens.error", err);
    }
    return result;
  }
  resolveCodeLens(param) {
    return param;
  }
};
var SpacesDiffResult = class {
  constructor() {
    this.spacesDiff = 0;
    this.looksLikeAlignment = false;
  }
};
function spacesDiff(a2, aLength, b, bLength, result) {
  result.spacesDiff = 0;
  result.looksLikeAlignment = false;
  let i;
  for (i = 0; i < aLength && i < bLength; i++) {
    const aCharCode = a2.charCodeAt(i);
    const bCharCode = b.charCodeAt(i);
    if (aCharCode !== bCharCode) {
      break;
    }
  }
  let aSpacesCnt = 0, aTabsCount = 0;
  for (let j = i; j < aLength; j++) {
    const aCharCode = a2.charCodeAt(j);
    if (aCharCode === 32) {
      aSpacesCnt++;
    } else {
      aTabsCount++;
    }
  }
  let bSpacesCnt = 0, bTabsCount = 0;
  for (let j = i; j < bLength; j++) {
    const bCharCode = b.charCodeAt(j);
    if (bCharCode === 32) {
      bSpacesCnt++;
    } else {
      bTabsCount++;
    }
  }
  if (aSpacesCnt > 0 && aTabsCount > 0) {
    return;
  }
  if (bSpacesCnt > 0 && bTabsCount > 0) {
    return;
  }
  const tabsDiff = Math.abs(aTabsCount - bTabsCount);
  const spacesDiff2 = Math.abs(aSpacesCnt - bSpacesCnt);
  if (tabsDiff === 0) {
    result.spacesDiff = spacesDiff2;
    if (spacesDiff2 > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a2.length && bSpacesCnt < b.length) {
      if (b.charCodeAt(bSpacesCnt) !== 32 && a2.charCodeAt(bSpacesCnt - 1) === 32) {
        if (a2.charCodeAt(a2.length - 1) === 44) {
          result.looksLikeAlignment = true;
        }
      }
    }
    return;
  }
  if (spacesDiff2 % tabsDiff === 0) {
    result.spacesDiff = spacesDiff2 / tabsDiff;
  }
}
function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {
  const linesCount = Math.min(source.getLineCount(), 1e4);
  let linesIndentedWithTabsCount = 0;
  let linesIndentedWithSpacesCount = 0;
  let previousLineText = "";
  let previousLineIndentation = 0;
  const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7];
  const MAX_ALLOWED_TAB_SIZE_GUESS = 8;
  const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  const tmp = new SpacesDiffResult();
  for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {
    const currentLineLength = source.getLineLength(lineNumber);
    const currentLineText = source.getLineContent(lineNumber);
    const useCurrentLineText = currentLineLength <= 65536;
    let currentLineHasContent = false;
    let currentLineIndentation = 0;
    let currentLineSpacesCount = 0;
    let currentLineTabsCount = 0;
    for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {
      const charCode = useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j);
      if (charCode === 9) {
        currentLineTabsCount++;
      } else if (charCode === 32) {
        currentLineSpacesCount++;
      } else {
        currentLineHasContent = true;
        currentLineIndentation = j;
        break;
      }
    }
    if (!currentLineHasContent) {
      continue;
    }
    if (currentLineTabsCount > 0) {
      linesIndentedWithTabsCount++;
    } else if (currentLineSpacesCount > 1) {
      linesIndentedWithSpacesCount++;
    }
    spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);
    if (tmp.looksLikeAlignment) {
      if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {
        continue;
      }
    }
    const currentSpacesDiff = tmp.spacesDiff;
    if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {
      spacesDiffCount[currentSpacesDiff]++;
    }
    previousLineText = currentLineText;
    previousLineIndentation = currentLineIndentation;
  }
  let insertSpaces = defaultInsertSpaces;
  if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {
    insertSpaces = linesIndentedWithTabsCount < linesIndentedWithSpacesCount;
  }
  let tabSize = defaultTabSize;
  if (insertSpaces) {
    let tabSizeScore = insertSpaces ? 0 : 0.1 * linesCount;
    ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {
      const possibleTabSizeScore = spacesDiffCount[possibleTabSize];
      if (possibleTabSizeScore > tabSizeScore) {
        tabSizeScore = possibleTabSizeScore;
        tabSize = possibleTabSize;
      }
    });
    if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {
      tabSize = 2;
    }
  }
  return {
    insertSpaces,
    tabSize
  };
}
function stringifyObject(obj, indent, stringifyLiteral, settings, depth = 0, consecutiveArrays = 0) {
  if (obj !== null && typeof obj === "object") {
    const newIndent = depth === 0 && settings.shouldIndentWithTab || depth > 0 ? indent + settings.indentation : "";
    if (Array.isArray(obj)) {
      consecutiveArrays += 1;
      if (obj.length === 0) {
        return "";
      }
      let result = "";
      for (let i = 0; i < obj.length; i++) {
        let pseudoObj = obj[i];
        if (typeof obj[i] !== "object") {
          result += "\n" + newIndent + "- " + stringifyLiteral(obj[i]);
          continue;
        }
        if (!Array.isArray(obj[i])) {
          pseudoObj = prependToObject(obj[i], consecutiveArrays);
        }
        result += stringifyObject(pseudoObj, indent, stringifyLiteral, settings, depth += 1, consecutiveArrays);
      }
      return result;
    } else {
      const keys = Object.keys(obj);
      if (keys.length === 0) {
        return "";
      }
      let result = depth === 0 && settings.newLineFirst || depth > 0 ? "\n" : "";
      let isFirstProp = true;
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (depth === 0 && settings.existingProps.includes(key)) {
          continue;
        }
        const isObject2 = typeof obj[key] === "object";
        const colonDelimiter = isObject2 ? ":" : ": ";
        const parentArrayCompensation = isObject2 && /^\s|-/.test(key) ? settings.indentation : "";
        const objectIndent = newIndent + parentArrayCompensation;
        const lineBreak = isFirstProp ? "" : "\n";
        if (depth === 0 && isFirstProp && !settings.indentFirstObject) {
          const value = stringifyObject(obj[key], objectIndent, stringifyLiteral, settings, depth + 1, 0);
          result += lineBreak + indent + key + colonDelimiter + value;
        } else {
          const value = stringifyObject(obj[key], objectIndent, stringifyLiteral, settings, depth + 1, 0);
          result += lineBreak + newIndent + key + colonDelimiter + value;
        }
        isFirstProp = false;
      }
      return result;
    }
  }
  return stringifyLiteral(obj);
}
function prependToObject(obj, consecutiveArrays) {
  const newObj = {};
  for (let i = 0; i < Object.keys(obj).length; i++) {
    const key = Object.keys(obj)[i];
    if (i === 0) {
      newObj["- ".repeat(consecutiveArrays) + key] = obj[key];
    } else {
      newObj["  ".repeat(consecutiveArrays) + key] = obj[key];
    }
  }
  return newObj;
}
var localize7 = loadMessageBundle();
var doubleQuotesEscapeRegExp = /[\\]+"/g;
var parentCompletionKind = CompletionItemKind2.Class;
var existingProposeItem = "__";
var YamlCompletion = class {
  constructor(schemaService, clientCapabilities = {}, yamlDocument, telemetry2) {
    this.schemaService = schemaService;
    this.clientCapabilities = clientCapabilities;
    this.yamlDocument = yamlDocument;
    this.telemetry = telemetry2;
    this.completionEnabled = true;
    this.arrayPrefixIndentation = "";
  }
  configure(languageSettings) {
    if (languageSettings) {
      this.completionEnabled = languageSettings.completion;
    }
    this.customTags = languageSettings.customTags;
    this.yamlVersion = languageSettings.yamlVersion;
    this.configuredIndentation = languageSettings.indentation;
    this.disableDefaultProperties = languageSettings.disableDefaultProperties;
    this.parentSkeletonSelectedFirst = languageSettings.parentSkeletonSelectedFirst;
  }
  async doComplete(document2, position, isKubernetes = false, doComplete = true) {
    var _a4;
    const result = CompletionList.create([], false);
    if (!this.completionEnabled) {
      return result;
    }
    const doc = this.yamlDocument.getYamlDocument(document2, { customTags: this.customTags, yamlVersion: this.yamlVersion }, true);
    const textBuffer = new TextBuffer(document2);
    if (!this.configuredIndentation) {
      const indent = guessIndentation(textBuffer, 2, true);
      this.indentation = indent.insertSpaces ? " ".repeat(indent.tabSize) : "	";
    } else {
      this.indentation = this.configuredIndentation;
    }
    setKubernetesParserOption(doc.documents, isKubernetes);
    for (const jsonDoc of doc.documents) {
      jsonDoc.uri = document2.uri;
    }
    const offset = document2.offsetAt(position);
    const text = document2.getText();
    if (text.charAt(offset - 1) === ":") {
      return Promise.resolve(result);
    }
    let currentDoc = matchOffsetToDocument(offset, doc);
    if (currentDoc === null) {
      return Promise.resolve(result);
    }
    currentDoc = currentDoc.clone();
    let [node, foundByClosest] = currentDoc.getNodeFromPosition(offset, textBuffer, this.indentation.length);
    const currentWord = this.getCurrentWord(document2, offset);
    let lineContent = textBuffer.getLineContent(position.line);
    const lineAfterPosition = lineContent.substring(position.character);
    const areOnlySpacesAfterPosition = /^[ ]+\n?$/.test(lineAfterPosition);
    this.arrayPrefixIndentation = "";
    let overwriteRange = null;
    if (areOnlySpacesAfterPosition) {
      overwriteRange = Range2.create(position, Position2.create(position.line, lineContent.length));
      const isOnlyWhitespace = lineContent.trim().length === 0;
      const isOnlyDash = lineContent.match(/^\s*(-)\s*$/);
      if (node && isScalar(node) && !isOnlyWhitespace && !isOnlyDash) {
        const lineToPosition = lineContent.substring(0, position.character);
        const matches = (
          // get indentation of unfinished property (between indent and cursor)
          lineToPosition.match(/^[\s-]*([^:]+)?$/) || // OR get unfinished value (between colon and cursor)
          lineToPosition.match(/:[ \t]((?!:[ \t]).*)$/)
        );
        if (matches == null ? void 0 : matches[1]) {
          overwriteRange = Range2.create(Position2.create(position.line, position.character - matches[1].length), Position2.create(position.line, lineContent.length));
        }
      }
    } else if (node && isScalar(node) && node.value === "null") {
      const nodeStartPos = document2.positionAt(node.range[0]);
      nodeStartPos.character += 1;
      const nodeEndPos = document2.positionAt(node.range[2]);
      nodeEndPos.character += 1;
      overwriteRange = Range2.create(nodeStartPos, nodeEndPos);
    } else if (node && isScalar(node) && node.value) {
      const start = document2.positionAt(node.range[0]);
      overwriteRange = Range2.create(start, document2.positionAt(node.range[1]));
    } else if (node && isScalar(node) && node.value === null && currentWord === "-") {
      overwriteRange = Range2.create(position, position);
      this.arrayPrefixIndentation = " ";
    } else {
      let overwriteStart = offset - currentWord.length;
      if (overwriteStart > 0 && text[overwriteStart - 1] === '"') {
        overwriteStart--;
      }
      overwriteRange = Range2.create(document2.positionAt(overwriteStart), position);
    }
    const proposed = {};
    const collector = {
      add: (completionItem, oneOfSchema) => {
        const addSuggestionForParent = function(completionItem2) {
          var _a22;
          const existsInYaml = ((_a22 = proposed[completionItem2.label]) == null ? void 0 : _a22.label) === existingProposeItem;
          if (existsInYaml) {
            return;
          }
          const schema4 = completionItem2.parent.schema;
          const schemaType = getSchemaTypeName(schema4);
          const schemaDescription = schema4.markdownDescription || schema4.description;
          let parentCompletion = result.items.find((item) => {
            var _a32;
            return ((_a32 = item.parent) == null ? void 0 : _a32.schema) === schema4 && item.kind === parentCompletionKind;
          });
          if (parentCompletion && parentCompletion.parent.insertTexts.includes(completionItem2.insertText)) {
            return;
          } else if (!parentCompletion) {
            parentCompletion = {
              ...completionItem2,
              label: schemaType,
              documentation: schemaDescription,
              sortText: "_" + schemaType,
              kind: parentCompletionKind
            };
            parentCompletion.label = parentCompletion.label || completionItem2.label;
            parentCompletion.parent.insertTexts = [completionItem2.insertText];
            result.items.push(parentCompletion);
          } else {
            parentCompletion.parent.insertTexts.push(completionItem2.insertText);
          }
        };
        const isForParentCompletion = !!completionItem.parent;
        let label = completionItem.label;
        if (!label) {
          console.warn(`Ignoring CompletionItem without label: ${JSON.stringify(completionItem)}`);
          return;
        }
        if (!isString22(label)) {
          label = String(label);
        }
        label = label.replace(/[\n]/g, "\u21B5");
        if (label.length > 60) {
          const shortendedLabel = label.substr(0, 57).trim() + "...";
          if (!proposed[shortendedLabel]) {
            label = shortendedLabel;
          }
        }
        if (completionItem.insertText.endsWith("$1") && !isForParentCompletion) {
          completionItem.insertText = completionItem.insertText.substr(0, completionItem.insertText.length - 2);
        }
        if (overwriteRange && overwriteRange.start.line === overwriteRange.end.line) {
          completionItem.textEdit = TextEdit.replace(overwriteRange, completionItem.insertText);
        }
        completionItem.label = label;
        if (isForParentCompletion) {
          addSuggestionForParent(completionItem);
          return;
        }
        if (this.arrayPrefixIndentation) {
          this.updateCompletionText(completionItem, this.arrayPrefixIndentation + completionItem.insertText);
        }
        const existing = proposed[label];
        const isInsertTextDifferent = (existing == null ? void 0 : existing.label) !== existingProposeItem && (existing == null ? void 0 : existing.insertText) !== completionItem.insertText;
        if (!existing) {
          proposed[label] = completionItem;
          result.items.push(completionItem);
        } else if (isInsertTextDifferent) {
          const mergedText = this.mergeSimpleInsertTexts(label, existing.insertText, completionItem.insertText, oneOfSchema);
          if (mergedText) {
            this.updateCompletionText(existing, mergedText);
          } else {
            proposed[label] = completionItem;
            result.items.push(completionItem);
          }
        }
        if (existing && !existing.documentation && completionItem.documentation) {
          existing.documentation = completionItem.documentation;
        }
      },
      error: (message) => {
        var _a22;
        (_a22 = this.telemetry) == null ? void 0 : _a22.sendError("yaml.completion.error", message);
      },
      log: (message) => {
        console.log(message);
      },
      getNumberOfProposals: () => {
        return result.items.length;
      },
      result,
      proposed
    };
    if (this.customTags && this.customTags.length > 0) {
      this.getCustomTagValueCompletions(collector);
    }
    if (lineContent.endsWith("\n")) {
      lineContent = lineContent.substr(0, lineContent.length - 1);
    }
    try {
      const schema4 = await this.schemaService.getSchemaForResource(document2.uri, currentDoc);
      if (!schema4 || schema4.errors.length) {
        if (position.line === 0 && position.character === 0 && !isModeline(lineContent)) {
          const inlineSchemaCompletion = {
            kind: CompletionItemKind2.Text,
            label: "Inline schema",
            insertText: "# yaml-language-server: $schema=",
            insertTextFormat: InsertTextFormat.PlainText
          };
          result.items.push(inlineSchemaCompletion);
        }
      }
      if (isModeline(lineContent) || isInComment(doc.tokens, offset)) {
        const schemaIndex = lineContent.indexOf("$schema=");
        if (schemaIndex !== -1 && schemaIndex + "$schema=".length <= position.character) {
          this.schemaService.getAllSchemas().forEach((schema22) => {
            var _a22;
            const schemaIdCompletion = {
              kind: CompletionItemKind2.Constant,
              label: (_a22 = schema22.name) != null ? _a22 : schema22.uri,
              detail: schema22.description,
              insertText: schema22.uri,
              insertTextFormat: InsertTextFormat.PlainText,
              insertTextMode: InsertTextMode.asIs
            };
            result.items.push(schemaIdCompletion);
          });
        }
        return result;
      }
      if (!schema4 || schema4.errors.length) {
        return result;
      }
      let currentProperty = null;
      if (!node) {
        if (!currentDoc.internalDocument.contents || isScalar(currentDoc.internalDocument.contents)) {
          const map2 = currentDoc.internalDocument.createNode({});
          map2.range = [offset, offset + 1, offset + 1];
          currentDoc.internalDocument.contents = map2;
          currentDoc.updateFromInternalDocument();
          node = map2;
        } else {
          node = currentDoc.findClosestNode(offset, textBuffer);
          foundByClosest = true;
        }
      }
      const originalNode = node;
      if (node) {
        if (lineContent.length === 0) {
          node = currentDoc.internalDocument.contents;
        } else {
          const parent = currentDoc.getParent(node);
          if (parent) {
            if (isScalar(node)) {
              if (node.value) {
                if (isPair(parent)) {
                  if (parent.value === node) {
                    if (lineContent.trim().length > 0 && lineContent.indexOf(":") < 0) {
                      const map2 = this.createTempObjNode(currentWord, node, currentDoc);
                      const parentParent = currentDoc.getParent(parent);
                      if (isSeq(currentDoc.internalDocument.contents)) {
                        const index = indexOf(currentDoc.internalDocument.contents, parent);
                        if (typeof index === "number") {
                          currentDoc.internalDocument.set(index, map2);
                          currentDoc.updateFromInternalDocument();
                        }
                      } else if (parentParent && (isMap(parentParent) || isSeq(parentParent))) {
                        parentParent.set(parent.key, map2);
                        currentDoc.updateFromInternalDocument();
                      } else {
                        currentDoc.internalDocument.set(parent.key, map2);
                        currentDoc.updateFromInternalDocument();
                      }
                      currentProperty = map2.items[0];
                      node = map2;
                    } else if (lineContent.trim().length === 0) {
                      const parentParent = currentDoc.getParent(parent);
                      if (parentParent) {
                        node = parentParent;
                      }
                    }
                  } else if (parent.key === node) {
                    const parentParent = currentDoc.getParent(parent);
                    currentProperty = parent;
                    if (parentParent) {
                      node = parentParent;
                    }
                  }
                } else if (isSeq(parent)) {
                  if (lineContent.trim().length > 0) {
                    const map2 = this.createTempObjNode(currentWord, node, currentDoc);
                    parent.delete(node);
                    parent.add(map2);
                    currentDoc.updateFromInternalDocument();
                    node = map2;
                  } else {
                    node = parent;
                  }
                }
              } else if (node.value === null) {
                if (isPair(parent)) {
                  if (parent.key === node) {
                    node = parent;
                  } else {
                    if (isNode(parent.key) && parent.key.range) {
                      const parentParent = currentDoc.getParent(parent);
                      if (foundByClosest && parentParent && isMap(parentParent) && isMapContainsEmptyPair(parentParent)) {
                        node = parentParent;
                      } else {
                        const parentPosition = document2.positionAt(parent.key.range[0]);
                        if (position.character > parentPosition.character && position.line !== parentPosition.line) {
                          const map2 = this.createTempObjNode(currentWord, node, currentDoc);
                          if (parentParent && (isMap(parentParent) || isSeq(parentParent))) {
                            parentParent.set(parent.key, map2);
                            currentDoc.updateFromInternalDocument();
                          } else {
                            currentDoc.internalDocument.set(parent.key, map2);
                            currentDoc.updateFromInternalDocument();
                          }
                          currentProperty = map2.items[0];
                          node = map2;
                        } else if (parentPosition.character === position.character) {
                          if (parentParent) {
                            node = parentParent;
                          }
                        }
                      }
                    }
                  }
                } else if (isSeq(parent)) {
                  if (lineContent.charAt(position.character - 1) !== "-") {
                    const map2 = this.createTempObjNode(currentWord, node, currentDoc);
                    parent.delete(node);
                    parent.add(map2);
                    currentDoc.updateFromInternalDocument();
                    node = map2;
                  } else if (lineContent.charAt(position.character - 1) === "-") {
                    const map2 = this.createTempObjNode("", node, currentDoc);
                    parent.delete(node);
                    parent.add(map2);
                    currentDoc.updateFromInternalDocument();
                    node = map2;
                  } else {
                    node = parent;
                  }
                }
              }
            } else if (isMap(node)) {
              if (!foundByClosest && lineContent.trim().length === 0 && isSeq(parent)) {
                const nextLine = textBuffer.getLineContent(position.line + 1);
                if (textBuffer.getLineCount() === position.line + 1 || nextLine.trim().length === 0) {
                  node = parent;
                }
              }
            }
          } else if (isScalar(node)) {
            const map2 = this.createTempObjNode(currentWord, node, currentDoc);
            currentDoc.internalDocument.contents = map2;
            currentDoc.updateFromInternalDocument();
            currentProperty = map2.items[0];
            node = map2;
          } else if (isMap(node)) {
            for (const pair of node.items) {
              if (isNode(pair.value) && pair.value.range && pair.value.range[0] === offset + 1) {
                node = pair.value;
              }
            }
          } else if (isSeq(node)) {
            if (lineContent.charAt(position.character - 1) !== "-") {
              const map2 = this.createTempObjNode(currentWord, node, currentDoc);
              map2.items = [];
              currentDoc.updateFromInternalDocument();
              for (const pair of node.items) {
                if (isMap(pair)) {
                  pair.items.forEach((value) => {
                    map2.items.push(value);
                  });
                }
              }
              node = map2;
            }
          }
        }
      }
      if (node && isMap(node)) {
        const properties = node.items;
        for (const p of properties) {
          if (!currentProperty || currentProperty !== p) {
            if (isScalar(p.key)) {
              proposed[p.key.value + ""] = CompletionItem.create(existingProposeItem);
            }
          }
        }
        this.addPropertyCompletions(schema4, currentDoc, node, originalNode, "", collector, textBuffer, overwriteRange, doComplete);
        if (!schema4 && currentWord.length > 0 && text.charAt(offset - currentWord.length - 1) !== '"') {
          collector.add({
            kind: CompletionItemKind2.Property,
            label: currentWord,
            insertText: this.getInsertTextForProperty(currentWord, null, ""),
            insertTextFormat: InsertTextFormat.Snippet
          });
        }
      }
      const types = {};
      this.getValueCompletions(schema4, currentDoc, node, offset, document2, collector, types, doComplete);
    } catch (err) {
      (_a4 = this.telemetry) == null ? void 0 : _a4.sendError("yaml.completion.error", err);
    }
    this.finalizeParentCompletion(result);
    const uniqueItems = result.items.filter((arr, index, self2) => index === self2.findIndex((item) => item.label === arr.label && item.insertText === arr.insertText && item.kind === arr.kind));
    if ((uniqueItems == null ? void 0 : uniqueItems.length) > 0) {
      result.items = uniqueItems;
    }
    return result;
  }
  updateCompletionText(completionItem, text) {
    completionItem.insertText = text;
    if (completionItem.textEdit) {
      completionItem.textEdit.newText = text;
    }
  }
  mergeSimpleInsertTexts(label, existingText, addingText, oneOfSchema) {
    const containsNewLineAfterColon = (value) => {
      return value.includes("\n");
    };
    const startWithNewLine = (value) => {
      return value.startsWith("\n");
    };
    const isNullObject = (value) => {
      const index = value.indexOf("\n");
      return index > 0 && value.substring(index, value.length).trim().length === 0;
    };
    if (containsNewLineAfterColon(existingText) || containsNewLineAfterColon(addingText)) {
      if (oneOfSchema && isNullObject(existingText) && !isNullObject(addingText) && !startWithNewLine(addingText)) {
        return addingText;
      }
      return void 0;
    }
    const existingValues = this.getValuesFromInsertText(existingText);
    const addingValues = this.getValuesFromInsertText(addingText);
    const newValues = Array.prototype.concat(existingValues, addingValues);
    if (!newValues.length) {
      return void 0;
    } else if (newValues.length === 1) {
      return `${label}: \${1:${newValues[0]}}`;
    } else {
      return `${label}: \${1|${newValues.join(",")}|}`;
    }
  }
  getValuesFromInsertText(insertText) {
    const value = insertText.substring(insertText.indexOf(":") + 1).trim();
    if (!value) {
      return [];
    }
    const valueMath = value.match(/^\${1[|:]([^|]*)+\|?}$/);
    if (valueMath) {
      return valueMath[1].split(",");
    }
    return [value];
  }
  finalizeParentCompletion(result) {
    const reindexText = (insertTexts) => {
      let max$index = 0;
      return insertTexts.map((text) => {
        const match = text.match(/\$([0-9]+)|\${[0-9]+:/g);
        if (!match) {
          return text;
        }
        const max$indexLocal = match.map((m) => +m.replace(/\${([0-9]+)[:|]/g, "$1").replace("$", "")).reduce((p, n) => n > p ? n : p, 0);
        const reindexedStr = text.replace(/\$([0-9]+)/g, (s, args) => "$" + (+args + max$index)).replace(/\${([0-9]+)[:|]/g, (s, args) => "${" + (+args + max$index) + ":");
        max$index += max$indexLocal;
        return reindexedStr;
      });
    };
    result.items.forEach((completionItem) => {
      if (isParentCompletionItem(completionItem)) {
        const indent = completionItem.parent.indent || "";
        const reindexedTexts = reindexText(completionItem.parent.insertTexts);
        let insertText = reindexedTexts.join(`
${indent}`);
        if (insertText.endsWith("$1")) {
          insertText = insertText.substring(0, insertText.length - 2);
        }
        completionItem.insertText = this.arrayPrefixIndentation + insertText;
        if (completionItem.textEdit) {
          completionItem.textEdit.newText = completionItem.insertText;
        }
        const mdText = insertText.replace(/\${[0-9]+[:|](.*)}/g, (s, arg) => arg).replace(/\$([0-9]+)/g, "");
        const originalDocumentation = completionItem.documentation ? [completionItem.documentation, "", "----", ""] : [];
        completionItem.documentation = {
          kind: MarkupKind.Markdown,
          value: [...originalDocumentation, "```yaml", indent + mdText, "```"].join("\n")
        };
        delete completionItem.parent;
      }
    });
  }
  createTempObjNode(currentWord, node, currentDoc) {
    const obj = {};
    obj[currentWord] = null;
    const map2 = currentDoc.internalDocument.createNode(obj);
    map2.range = node.range;
    map2.items[0].key.range = node.range;
    map2.items[0].value.range = node.range;
    return map2;
  }
  addPropertyCompletions(schema4, doc, node, originalNode, separatorAfter, collector, textBuffer, overwriteRange, doComplete) {
    var _a4, _b2, _c;
    const matchingSchemas = doc.getMatchingSchemas(schema4.schema, -1, null, doComplete);
    const existingKey = textBuffer.getText(overwriteRange);
    const lineContent = textBuffer.getLineContent(overwriteRange.start.line);
    const hasOnlyWhitespace = lineContent.trim().length === 0;
    const hasColon = lineContent.indexOf(":") !== -1;
    const isInArray = lineContent.trimLeft().indexOf("-") === 0;
    const nodeParent = doc.getParent(node);
    const matchOriginal = matchingSchemas.find((it) => it.node.internalNode === originalNode && it.schema.properties);
    const oneOfSchema = matchingSchemas.filter((schema22) => schema22.schema.oneOf).map((oneOfSchema2) => oneOfSchema2.schema.oneOf)[0];
    let didOneOfSchemaMatches = false;
    if ((oneOfSchema == null ? void 0 : oneOfSchema.length) < matchingSchemas.length) {
      oneOfSchema == null ? void 0 : oneOfSchema.forEach((property, index) => {
        var _a22, _b22;
        if (!((_a22 = matchingSchemas[index]) == null ? void 0 : _a22.schema.oneOf) && ((_b22 = matchingSchemas[index]) == null ? void 0 : _b22.schema.properties) === property.properties) {
          didOneOfSchemaMatches = true;
        }
      });
    }
    for (const schema22 of matchingSchemas) {
      if ((schema22.node.internalNode === node && !matchOriginal || schema22.node.internalNode === originalNode && !hasColon || ((_a4 = schema22.node.parent) == null ? void 0 : _a4.internalNode) === originalNode && !hasColon) && !schema22.inverted) {
        this.collectDefaultSnippets(schema22.schema, separatorAfter, collector, {
          newLineFirst: false,
          indentFirstObject: false,
          shouldIndentWithTab: isInArray
        });
        const schemaProperties = schema22.schema.properties;
        if (schemaProperties) {
          const maxProperties = schema22.schema.maxProperties;
          if (maxProperties === void 0 || node.items === void 0 || node.items.length < maxProperties || node.items.length === maxProperties && !hasOnlyWhitespace) {
            for (const key in schemaProperties) {
              if (Object.prototype.hasOwnProperty.call(schemaProperties, key)) {
                const propertySchema = schemaProperties[key];
                if (typeof propertySchema === "object" && !propertySchema.deprecationMessage && !propertySchema["doNotSuggest"]) {
                  let identCompensation = "";
                  if (nodeParent && isSeq(nodeParent) && node.items.length <= 1 && !hasOnlyWhitespace) {
                    const sourceText = textBuffer.getText();
                    const indexOfSlash = sourceText.lastIndexOf("-", node.range[0] - 1);
                    if (indexOfSlash >= 0) {
                      const overwriteChars = overwriteRange.end.character - overwriteRange.start.character;
                      identCompensation = " " + sourceText.slice(indexOfSlash + 1, node.range[1] - overwriteChars);
                    }
                  }
                  identCompensation += this.arrayPrefixIndentation;
                  let pair;
                  if (propertySchema.type === "array" && (pair = node.items.find((it) => isScalar(it.key) && it.key.range && it.key.value === key && isScalar(it.value) && !it.value.value && textBuffer.getPosition(it.key.range[2]).line === overwriteRange.end.line - 1)) && pair) {
                    if (Array.isArray(propertySchema.items)) {
                      this.addSchemaValueCompletions(propertySchema.items[0], separatorAfter, collector, {}, "property");
                    } else if (typeof propertySchema.items === "object" && propertySchema.items.type === "object") {
                      this.addArrayItemValueCompletion(propertySchema.items, separatorAfter, collector);
                    }
                  }
                  let insertText = key;
                  if (!key.startsWith(existingKey) || !hasColon) {
                    insertText = this.getInsertTextForProperty(key, propertySchema, separatorAfter, identCompensation + this.indentation);
                  }
                  const isNodeNull = isScalar(originalNode) && originalNode.value === null || isMap(originalNode) && originalNode.items.length === 0;
                  const existsParentCompletion = ((_b2 = schema22.schema.required) == null ? void 0 : _b2.length) > 0;
                  if (!this.parentSkeletonSelectedFirst || !isNodeNull || !existsParentCompletion) {
                    collector.add({
                      kind: CompletionItemKind2.Property,
                      label: key,
                      insertText,
                      insertTextFormat: InsertTextFormat.Snippet,
                      documentation: this.fromMarkup(propertySchema.markdownDescription) || propertySchema.description || ""
                    }, didOneOfSchemaMatches);
                  }
                  if ((_c = schema22.schema.required) == null ? void 0 : _c.includes(key)) {
                    collector.add({
                      label: key,
                      insertText: this.getInsertTextForProperty(key, propertySchema, separatorAfter, identCompensation + this.indentation),
                      insertTextFormat: InsertTextFormat.Snippet,
                      documentation: this.fromMarkup(propertySchema.markdownDescription) || propertySchema.description || "",
                      parent: {
                        schema: schema22.schema,
                        indent: identCompensation
                      }
                    });
                  }
                }
              }
            }
          }
        }
        if (nodeParent && isSeq(nodeParent) && isPrimitiveType(schema22.schema)) {
          this.addSchemaValueCompletions(schema22.schema, separatorAfter, collector, {}, "property", Array.isArray(nodeParent.items));
        }
        if (schema22.schema.propertyNames && schema22.schema.additionalProperties && schema22.schema.type === "object") {
          const propertyNameSchema = asSchema2(schema22.schema.propertyNames);
          const label = propertyNameSchema.title || "property";
          collector.add({
            kind: CompletionItemKind2.Property,
            label,
            insertText: `\${1:${label}}: `,
            insertTextFormat: InsertTextFormat.Snippet,
            documentation: this.fromMarkup(propertyNameSchema.markdownDescription) || propertyNameSchema.description || ""
          });
        }
      }
      if (nodeParent && schema22.node.internalNode === nodeParent && schema22.schema.defaultSnippets) {
        if (node.items.length === 1) {
          this.collectDefaultSnippets(schema22.schema, separatorAfter, collector, {
            newLineFirst: false,
            indentFirstObject: false,
            shouldIndentWithTab: true
          }, 1);
        } else {
          this.collectDefaultSnippets(schema22.schema, separatorAfter, collector, {
            newLineFirst: false,
            indentFirstObject: true,
            shouldIndentWithTab: false
          }, 1);
        }
      }
    }
  }
  getValueCompletions(schema4, doc, node, offset, document2, collector, types, doComplete) {
    let parentKey = null;
    if (node && isScalar(node)) {
      node = doc.getParent(node);
    }
    if (!node) {
      this.addSchemaValueCompletions(schema4.schema, "", collector, types, "value");
      return;
    }
    if (isPair(node)) {
      const valueNode = node.value;
      if (valueNode && valueNode.range && offset > valueNode.range[0] + valueNode.range[2]) {
        return;
      }
      parentKey = isScalar(node.key) ? node.key.value + "" : null;
      node = doc.getParent(node);
    }
    if (node && (parentKey !== null || isSeq(node))) {
      const separatorAfter = "";
      const matchingSchemas = doc.getMatchingSchemas(schema4.schema, -1, null, doComplete);
      for (const s of matchingSchemas) {
        if (s.node.internalNode === node && !s.inverted && s.schema) {
          if (s.schema.items) {
            this.collectDefaultSnippets(s.schema, separatorAfter, collector, {
              newLineFirst: false,
              indentFirstObject: false,
              shouldIndentWithTab: false
            });
            if (isSeq(node) && node.items) {
              if (Array.isArray(s.schema.items)) {
                const index = this.findItemAtOffset(node, document2, offset);
                if (index < s.schema.items.length) {
                  this.addSchemaValueCompletions(s.schema.items[index], separatorAfter, collector, types, "value");
                }
              } else if (typeof s.schema.items === "object" && (s.schema.items.type === "object" || isAnyOfAllOfOneOfType(s.schema.items))) {
                this.addSchemaValueCompletions(s.schema.items, separatorAfter, collector, types, "value", true);
              } else {
                this.addSchemaValueCompletions(s.schema.items, separatorAfter, collector, types, "value");
              }
            }
          }
          if (s.schema.properties) {
            const propertySchema = s.schema.properties[parentKey];
            if (propertySchema) {
              this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types, "value");
            }
          }
          if (s.schema.additionalProperties) {
            this.addSchemaValueCompletions(s.schema.additionalProperties, separatorAfter, collector, types, "value");
          }
        }
      }
      if (types["boolean"]) {
        this.addBooleanValueCompletion(true, separatorAfter, collector);
        this.addBooleanValueCompletion(false, separatorAfter, collector);
      }
      if (types["null"]) {
        this.addNullValueCompletion(separatorAfter, collector);
      }
    }
  }
  addArrayItemValueCompletion(schema4, separatorAfter, collector, index) {
    const schemaType = getSchemaTypeName(schema4);
    const insertText = `- ${this.getInsertTextForObject(schema4, separatorAfter).insertText.trimLeft()}`;
    const schemaTypeTitle = schemaType ? " type `" + schemaType + "`" : "";
    const schemaDescription = schema4.description ? " (" + schema4.description + ")" : "";
    const documentation = this.getDocumentationWithMarkdownText(`Create an item of an array${schemaTypeTitle}${schemaDescription}`, insertText);
    collector.add({
      kind: this.getSuggestionKind(schema4.type),
      label: "- (array item) " + (schemaType || index),
      documentation,
      insertText,
      insertTextFormat: InsertTextFormat.Snippet
    });
  }
  getInsertTextForProperty(key, propertySchema, separatorAfter, indent = this.indentation) {
    const propertyText = this.getInsertTextForValue(key, "", "string");
    const resultText = propertyText + ":";
    let value;
    let nValueProposals = 0;
    if (propertySchema) {
      let type = Array.isArray(propertySchema.type) ? propertySchema.type[0] : propertySchema.type;
      if (!type) {
        if (propertySchema.properties) {
          type = "object";
        } else if (propertySchema.items) {
          type = "array";
        } else if (propertySchema.anyOf) {
          type = "anyOf";
        }
      }
      if (Array.isArray(propertySchema.defaultSnippets)) {
        if (propertySchema.defaultSnippets.length === 1) {
          const body = propertySchema.defaultSnippets[0].body;
          if (isDefined2(body)) {
            value = this.getInsertTextForSnippetValue(body, "", {
              newLineFirst: true,
              indentFirstObject: false,
              shouldIndentWithTab: false
            }, [], 1);
            if (!value.startsWith(" ") && !value.startsWith("\n")) {
              value = " " + value;
            }
          }
        }
        nValueProposals += propertySchema.defaultSnippets.length;
      }
      if (propertySchema.enum) {
        if (!value && propertySchema.enum.length === 1) {
          value = " " + this.getInsertTextForGuessedValue(propertySchema.enum[0], "", type);
        }
        nValueProposals += propertySchema.enum.length;
      }
      if (propertySchema.const) {
        if (!value) {
          value = this.getInsertTextForGuessedValue(propertySchema.const, "", type);
          value = evaluateTab1Symbol(value);
          value = " " + value;
        }
        nValueProposals++;
      }
      if (isDefined2(propertySchema.default)) {
        if (!value) {
          value = " " + this.getInsertTextForGuessedValue(propertySchema.default, "", type);
        }
        nValueProposals++;
      }
      if (Array.isArray(propertySchema.examples) && propertySchema.examples.length) {
        if (!value) {
          value = " " + this.getInsertTextForGuessedValue(propertySchema.examples[0], "", type);
        }
        nValueProposals += propertySchema.examples.length;
      }
      if (propertySchema.properties) {
        return `${resultText}
${this.getInsertTextForObject(propertySchema, separatorAfter, indent).insertText}`;
      } else if (propertySchema.items) {
        return `${resultText}
${indent}- ${this.getInsertTextForArray(propertySchema.items, separatorAfter, 1, indent).insertText}`;
      }
      if (nValueProposals === 0) {
        switch (type) {
          case "boolean":
            value = " $1";
            break;
          case "string":
            value = " $1";
            break;
          case "object":
            value = `
${indent}`;
            break;
          case "array":
            value = `
${indent}- `;
            break;
          case "number":
          case "integer":
            value = " ${1:0}";
            break;
          case "null":
            value = " ${1:null}";
            break;
          case "anyOf":
            value = " $1";
            break;
          default:
            return propertyText;
        }
      }
    }
    if (!value || nValueProposals > 1) {
      value = " $1";
    }
    return resultText + value + separatorAfter;
  }
  getInsertTextForObject(schema4, separatorAfter, indent = this.indentation, insertIndex = 1) {
    let insertText = "";
    if (!schema4.properties) {
      insertText = `${indent}$${insertIndex++}
`;
      return { insertText, insertIndex };
    }
    Object.keys(schema4.properties).forEach((key) => {
      const propertySchema = schema4.properties[key];
      let type = Array.isArray(propertySchema.type) ? propertySchema.type[0] : propertySchema.type;
      if (!type) {
        if (propertySchema.anyOf) {
          type = "anyOf";
        }
        if (propertySchema.properties) {
          type = "object";
        }
        if (propertySchema.items) {
          type = "array";
        }
      }
      if (schema4.required && schema4.required.indexOf(key) > -1) {
        switch (type) {
          case "boolean":
          case "string":
          case "number":
          case "integer":
          case "anyOf": {
            let value = propertySchema.default || propertySchema.const;
            if (value) {
              if (type === "string") {
                value = convertToStringValue(value);
              }
              insertText += `${indent}${key}: \${${insertIndex++}:${value}}
`;
            } else {
              insertText += `${indent}${key}: $${insertIndex++}
`;
            }
            break;
          }
          case "array":
            {
              const arrayInsertResult = this.getInsertTextForArray(propertySchema.items, separatorAfter, insertIndex++, indent);
              const arrayInsertLines = arrayInsertResult.insertText.split("\n");
              let arrayTemplate = arrayInsertResult.insertText;
              if (arrayInsertLines.length > 1) {
                for (let index = 1; index < arrayInsertLines.length; index++) {
                  const element = arrayInsertLines[index];
                  arrayInsertLines[index] = `  ${element}`;
                }
                arrayTemplate = arrayInsertLines.join("\n");
              }
              insertIndex = arrayInsertResult.insertIndex;
              insertText += `${indent}${key}:
${indent}${this.indentation}- ${arrayTemplate}
`;
            }
            break;
          case "object":
            {
              const objectInsertResult = this.getInsertTextForObject(propertySchema, separatorAfter, `${indent}${this.indentation}`, insertIndex++);
              insertIndex = objectInsertResult.insertIndex;
              insertText += `${indent}${key}:
${objectInsertResult.insertText}
`;
            }
            break;
        }
      } else if (!this.disableDefaultProperties && propertySchema.default !== void 0) {
        switch (type) {
          case "boolean":
          case "number":
          case "integer":
            insertText += `${indent}${//added quote if key is null
            key === "null" ? this.getInsertTextForValue(key, "", "string") : key}: \${${insertIndex++}:${propertySchema.default}}
`;
            break;
          case "string":
            insertText += `${indent}${key}: \${${insertIndex++}:${convertToStringValue(propertySchema.default)}}
`;
            break;
          case "array":
          case "object":
            break;
        }
      }
    });
    if (insertText.trim().length === 0) {
      insertText = `${indent}$${insertIndex++}
`;
    }
    insertText = insertText.trimRight() + separatorAfter;
    return { insertText, insertIndex };
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getInsertTextForArray(schema4, separatorAfter, insertIndex = 1, indent = this.indentation) {
    let insertText = "";
    if (!schema4) {
      insertText = `$${insertIndex++}`;
      return { insertText, insertIndex };
    }
    let type = Array.isArray(schema4.type) ? schema4.type[0] : schema4.type;
    if (!type) {
      if (schema4.properties) {
        type = "object";
      }
      if (schema4.items) {
        type = "array";
      }
    }
    switch (schema4.type) {
      case "boolean":
        insertText = `\${${insertIndex++}:false}`;
        break;
      case "number":
      case "integer":
        insertText = `\${${insertIndex++}:0}`;
        break;
      case "string":
        insertText = `\${${insertIndex++}}`;
        break;
      case "object":
        {
          const objectInsertResult = this.getInsertTextForObject(schema4, separatorAfter, `${indent}  `, insertIndex++);
          insertText = objectInsertResult.insertText.trimLeft();
          insertIndex = objectInsertResult.insertIndex;
        }
        break;
    }
    return { insertText, insertIndex };
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getInsertTextForGuessedValue(value, separatorAfter, type) {
    switch (typeof value) {
      case "object":
        if (value === null) {
          return "${1:null}" + separatorAfter;
        }
        return this.getInsertTextForValue(value, separatorAfter, type);
      case "string": {
        let snippetValue = JSON.stringify(value);
        snippetValue = snippetValue.substr(1, snippetValue.length - 2);
        snippetValue = this.getInsertTextForPlainText(snippetValue);
        if (type === "string") {
          snippetValue = convertToStringValue(snippetValue);
        }
        return "${1:" + snippetValue + "}" + separatorAfter;
      }
      case "number":
      case "boolean":
        return "${1:" + value + "}" + separatorAfter;
    }
    return this.getInsertTextForValue(value, separatorAfter, type);
  }
  getInsertTextForPlainText(text) {
    return text.replace(/[\\$}]/g, "\\$&");
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getInsertTextForValue(value, separatorAfter, type) {
    if (value === null) {
      return "null";
    }
    switch (typeof value) {
      case "object": {
        const indent = this.indentation;
        return this.getInsertTemplateForValue(value, indent, { index: 1 }, separatorAfter);
      }
      case "number":
      case "boolean":
        return this.getInsertTextForPlainText(value + separatorAfter);
    }
    type = Array.isArray(type) ? type[0] : type;
    if (type === "string") {
      value = convertToStringValue(value);
    }
    return this.getInsertTextForPlainText(value + separatorAfter);
  }
  getInsertTemplateForValue(value, indent, navOrder, separatorAfter) {
    if (Array.isArray(value)) {
      let insertText = "\n";
      for (const arrValue of value) {
        insertText += `${indent}- \${${navOrder.index++}:${arrValue}}
`;
      }
      return insertText;
    } else if (typeof value === "object") {
      let insertText = "\n";
      for (const key in value) {
        if (Object.prototype.hasOwnProperty.call(value, key)) {
          const element = value[key];
          insertText += `${indent}\${${navOrder.index++}:${key}}:`;
          let valueTemplate;
          if (typeof element === "object") {
            valueTemplate = `${this.getInsertTemplateForValue(element, indent + this.indentation, navOrder, separatorAfter)}`;
          } else {
            valueTemplate = ` \${${navOrder.index++}:${this.getInsertTextForPlainText(element + separatorAfter)}}
`;
          }
          insertText += `${valueTemplate}`;
        }
      }
      return insertText;
    }
    return this.getInsertTextForPlainText(value + separatorAfter);
  }
  addSchemaValueCompletions(schema4, separatorAfter, collector, types, completionType, isArray) {
    if (typeof schema4 === "object") {
      this.addEnumValueCompletions(schema4, separatorAfter, collector, isArray);
      this.addDefaultValueCompletions(schema4, separatorAfter, collector);
      this.collectTypes(schema4, types);
      if (isArray && completionType === "value" && !isAnyOfAllOfOneOfType(schema4)) {
        this.addArrayItemValueCompletion(schema4, separatorAfter, collector);
      }
      if (Array.isArray(schema4.allOf)) {
        schema4.allOf.forEach((s) => {
          return this.addSchemaValueCompletions(s, separatorAfter, collector, types, completionType, isArray);
        });
      }
      if (Array.isArray(schema4.anyOf)) {
        schema4.anyOf.forEach((s) => {
          return this.addSchemaValueCompletions(s, separatorAfter, collector, types, completionType, isArray);
        });
      }
      if (Array.isArray(schema4.oneOf)) {
        schema4.oneOf.forEach((s) => {
          return this.addSchemaValueCompletions(s, separatorAfter, collector, types, completionType, isArray);
        });
      }
    }
  }
  collectTypes(schema4, types) {
    if (Array.isArray(schema4.enum) || isDefined2(schema4.const)) {
      return;
    }
    const type = schema4.type;
    if (Array.isArray(type)) {
      type.forEach(function(t) {
        return types[t] = true;
      });
    } else if (type) {
      types[type] = true;
    }
  }
  addDefaultValueCompletions(schema4, separatorAfter, collector, arrayDepth = 0) {
    let hasProposals = false;
    if (isDefined2(schema4.default)) {
      let type = schema4.type;
      let value = schema4.default;
      for (let i = arrayDepth; i > 0; i--) {
        value = [value];
        type = "array";
      }
      let label;
      if (typeof value == "object") {
        label = "Default value";
      } else {
        label = value.toString().replace(doubleQuotesEscapeRegExp, '"');
      }
      collector.add({
        kind: this.getSuggestionKind(type),
        label,
        insertText: this.getInsertTextForValue(value, separatorAfter, type),
        insertTextFormat: InsertTextFormat.Snippet,
        detail: localize7("json.suggest.default", "Default value")
      });
      hasProposals = true;
    }
    if (Array.isArray(schema4.examples)) {
      schema4.examples.forEach((example) => {
        let type = schema4.type;
        let value = example;
        for (let i = arrayDepth; i > 0; i--) {
          value = [value];
          type = "array";
        }
        collector.add({
          kind: this.getSuggestionKind(type),
          label: this.getLabelForValue(value),
          insertText: this.getInsertTextForValue(value, separatorAfter, type),
          insertTextFormat: InsertTextFormat.Snippet
        });
        hasProposals = true;
      });
    }
    this.collectDefaultSnippets(schema4, separatorAfter, collector, {
      newLineFirst: true,
      indentFirstObject: true,
      shouldIndentWithTab: true
    });
    if (!hasProposals && typeof schema4.items === "object" && !Array.isArray(schema4.items)) {
      this.addDefaultValueCompletions(schema4.items, separatorAfter, collector, arrayDepth + 1);
    }
  }
  addEnumValueCompletions(schema4, separatorAfter, collector, isArray) {
    if (isDefined2(schema4.const) && !isArray) {
      collector.add({
        kind: this.getSuggestionKind(schema4.type),
        label: this.getLabelForValue(schema4.const),
        insertText: this.getInsertTextForValue(schema4.const, separatorAfter, schema4.type),
        insertTextFormat: InsertTextFormat.Snippet,
        documentation: this.fromMarkup(schema4.markdownDescription) || schema4.description
      });
    }
    if (Array.isArray(schema4.enum)) {
      for (let i = 0, length = schema4.enum.length; i < length; i++) {
        const enm = schema4.enum[i];
        let documentation = this.fromMarkup(schema4.markdownDescription) || schema4.description;
        if (schema4.markdownEnumDescriptions && i < schema4.markdownEnumDescriptions.length && this.doesSupportMarkdown()) {
          documentation = this.fromMarkup(schema4.markdownEnumDescriptions[i]);
        } else if (schema4.enumDescriptions && i < schema4.enumDescriptions.length) {
          documentation = schema4.enumDescriptions[i];
        }
        collector.add({
          kind: this.getSuggestionKind(schema4.type),
          label: this.getLabelForValue(enm),
          insertText: this.getInsertTextForValue(enm, separatorAfter, schema4.type),
          insertTextFormat: InsertTextFormat.Snippet,
          documentation
        });
      }
    }
  }
  getLabelForValue(value) {
    if (value === null) {
      return "null";
    }
    if (Array.isArray(value)) {
      return JSON.stringify(value);
    }
    return "" + value;
  }
  collectDefaultSnippets(schema4, separatorAfter, collector, settings, arrayDepth = 0) {
    if (Array.isArray(schema4.defaultSnippets)) {
      for (const s of schema4.defaultSnippets) {
        let type = schema4.type;
        let value = s.body;
        let label = s.label;
        let insertText;
        let filterText;
        if (isDefined2(value)) {
          const type2 = s.type || schema4.type;
          if (arrayDepth === 0 && type2 === "array") {
            const fixedObj = {};
            Object.keys(value).forEach((val, index) => {
              if (index === 0 && !val.startsWith("-")) {
                fixedObj[`- ${val}`] = value[val];
              } else {
                fixedObj[`  ${val}`] = value[val];
              }
            });
            value = fixedObj;
          }
          const existingProps = Object.keys(collector.proposed).filter((proposedProp) => collector.proposed[proposedProp].label === existingProposeItem);
          insertText = this.getInsertTextForSnippetValue(value, separatorAfter, settings, existingProps);
          if (insertText === "" && value) {
            continue;
          }
          label = label || this.getLabelForSnippetValue(value);
        } else if (typeof s.bodyText === "string") {
          let prefix = "", suffix = "", indent = "";
          for (let i = arrayDepth; i > 0; i--) {
            prefix = prefix + indent + "[\n";
            suffix = suffix + "\n" + indent + "]";
            indent += this.indentation;
            type = "array";
          }
          insertText = prefix + indent + s.bodyText.split("\n").join("\n" + indent) + suffix + separatorAfter;
          label = label || insertText;
          filterText = insertText.replace(/[\n]/g, "");
        }
        collector.add({
          kind: s.suggestionKind || this.getSuggestionKind(type),
          label,
          sortText: s.sortText || s.label,
          documentation: this.fromMarkup(s.markdownDescription) || s.description,
          insertText,
          insertTextFormat: InsertTextFormat.Snippet,
          filterText
        });
      }
    }
  }
  getInsertTextForSnippetValue(value, separatorAfter, settings, existingProps, depth) {
    const replacer = (value2) => {
      if (typeof value2 === "string") {
        if (value2[0] === "^") {
          return value2.substr(1);
        }
        if (value2 === "true" || value2 === "false") {
          return `"${value2}"`;
        }
      }
      return value2;
    };
    return stringifyObject(value, "", replacer, { ...settings, indentation: this.indentation, existingProps }, depth) + separatorAfter;
  }
  addBooleanValueCompletion(value, separatorAfter, collector) {
    collector.add({
      kind: this.getSuggestionKind("boolean"),
      label: value ? "true" : "false",
      insertText: this.getInsertTextForValue(value, separatorAfter, "boolean"),
      insertTextFormat: InsertTextFormat.Snippet,
      documentation: ""
    });
  }
  addNullValueCompletion(separatorAfter, collector) {
    collector.add({
      kind: this.getSuggestionKind("null"),
      label: "null",
      insertText: "null" + separatorAfter,
      insertTextFormat: InsertTextFormat.Snippet,
      documentation: ""
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getLabelForSnippetValue(value) {
    const label = JSON.stringify(value);
    return label.replace(/\$\{\d+:([^}]+)\}|\$\d+/g, "$1");
  }
  getCustomTagValueCompletions(collector) {
    const validCustomTags = filterInvalidCustomTags(this.customTags);
    validCustomTags.forEach((validTag) => {
      const label = validTag.split(" ")[0];
      this.addCustomTagValueCompletion(collector, " ", label);
    });
  }
  addCustomTagValueCompletion(collector, separatorAfter, label) {
    collector.add({
      kind: this.getSuggestionKind("string"),
      label,
      insertText: label + separatorAfter,
      insertTextFormat: InsertTextFormat.Snippet,
      documentation: ""
    });
  }
  getDocumentationWithMarkdownText(documentation, insertText) {
    let res = documentation;
    if (this.doesSupportMarkdown()) {
      insertText = insertText.replace(/\${[0-9]+[:|](.*)}/g, (s, arg) => {
        return arg;
      }).replace(/\$([0-9]+)/g, "");
      res = this.fromMarkup(`${documentation}
 \`\`\`
${insertText}
\`\`\``);
    }
    return res;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getSuggestionKind(type) {
    if (Array.isArray(type)) {
      const array = type;
      type = array.length > 0 ? array[0] : null;
    }
    if (!type) {
      return CompletionItemKind2.Value;
    }
    switch (type) {
      case "string":
        return CompletionItemKind2.Value;
      case "object":
        return CompletionItemKind2.Module;
      case "property":
        return CompletionItemKind2.Property;
      default:
        return CompletionItemKind2.Value;
    }
  }
  getCurrentWord(doc, offset) {
    let i = offset - 1;
    const text = doc.getText();
    while (i >= 0 && ' 	\n\r\v":{[,]}'.indexOf(text.charAt(i)) === -1) {
      i--;
    }
    return text.substring(i + 1, offset);
  }
  fromMarkup(markupString) {
    if (markupString && this.doesSupportMarkdown()) {
      return {
        kind: MarkupKind.Markdown,
        value: markupString
      };
    }
    return void 0;
  }
  doesSupportMarkdown() {
    if (this.supportsMarkdown === void 0) {
      const completion = this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.completion;
      this.supportsMarkdown = completion && completion.completionItem && Array.isArray(completion.completionItem.documentationFormat) && completion.completionItem.documentationFormat.indexOf(MarkupKind.Markdown) !== -1;
    }
    return this.supportsMarkdown;
  }
  findItemAtOffset(seqNode, doc, offset) {
    for (let i = seqNode.items.length - 1; i >= 0; i--) {
      const node = seqNode.items[i];
      if (isNode(node)) {
        if (node.range) {
          if (offset > node.range[1]) {
            return i;
          } else if (offset >= node.range[0]) {
            return i;
          }
        }
      }
    }
    return 0;
  }
};
var isNumberExp = /^\d+$/;
function convertToStringValue(param) {
  let value;
  if (typeof param === "string") {
    value = param;
  } else {
    value = "" + param;
  }
  if (value.length === 0) {
    return value;
  }
  if (value === "true" || value === "false" || value === "null" || isNumberExp.test(value)) {
    return `"${value}"`;
  }
  if (value.indexOf('"') !== -1) {
    value = value.replace(doubleQuotesEscapeRegExp, '"');
  }
  let doQuote = !isNaN(parseInt(value)) || value.charAt(0) === "@";
  if (!doQuote) {
    let idx = value.indexOf(":", 0);
    for (; idx > 0 && idx < value.length; idx = value.indexOf(":", idx + 1)) {
      if (idx === value.length - 1) {
        doQuote = true;
        break;
      }
      const nextChar = value.charAt(idx + 1);
      if (nextChar === "	" || nextChar === " ") {
        doQuote = true;
        break;
      }
    }
  }
  if (doQuote) {
    value = `"${value}"`;
  }
  return value;
}
function evaluateTab1Symbol(value) {
  return value.replace(/\$\{1:(.*)\}/, "$1");
}
function isParentCompletionItem(item) {
  return "parent" in item;
}
function JSONSchemaSelection() {
}
var YamlDefinition = class {
  constructor(telemetry2) {
    this.telemetry = telemetry2;
  }
  getDefinition(document2, params) {
    var _a4;
    try {
      const yamlDocument = yamlDocumentsCache.getYamlDocument(document2);
      const offset = document2.offsetAt(params.position);
      const currentDoc = matchOffsetToDocument(offset, yamlDocument);
      if (currentDoc) {
        const [node] = currentDoc.getNodeFromPosition(offset, new TextBuffer(document2));
        if (node && isAlias(node)) {
          const defNode = node.resolve(currentDoc.internalDocument);
          if (defNode && defNode.range) {
            const targetRange = Range2.create(document2.positionAt(defNode.range[0]), document2.positionAt(defNode.range[2]));
            const selectionRange = Range2.create(document2.positionAt(defNode.range[0]), document2.positionAt(defNode.range[1]));
            return [LocationLink.create(document2.uri, targetRange, selectionRange)];
          }
        }
      }
    } catch (err) {
      (_a4 = this.telemetry) == null ? void 0 : _a4.sendError("yaml.definition.error", err);
    }
    return void 0;
  }
};
function getSelectionRanges(document2, positions) {
  const doc = yamlDocumentsCache.getYamlDocument(document2);
  return positions.map((position) => {
    const ranges = getRanges(position);
    let current;
    for (const range of ranges) {
      current = SelectionRange.create(range, current);
    }
    return current != null ? current : SelectionRange.create({ start: position, end: position });
  });
  function getRanges(position) {
    const offset = document2.offsetAt(position);
    const result = [];
    for (const ymlDoc of doc.documents) {
      let currentNode;
      let overrideStartOffset;
      ymlDoc.visit((node) => {
        const endOffset = node.offset + node.length;
        if (endOffset < offset) {
          return true;
        }
        if (getTextFromOffsets(endOffset - 1, endOffset) === "\n") {
          if (endOffset - 1 < offset) {
            return true;
          }
        }
        let startOffset = node.offset;
        if (startOffset > offset) {
          const newOffset = getStartOffsetForSpecialCases(node, position);
          if (!newOffset || newOffset > offset) {
            return true;
          }
          startOffset = newOffset;
        }
        if (!currentNode || startOffset >= currentNode.offset) {
          currentNode = node;
          overrideStartOffset = startOffset;
        }
        return true;
      });
      while (currentNode) {
        const startOffset = overrideStartOffset != null ? overrideStartOffset : currentNode.offset;
        const endOffset = currentNode.offset + currentNode.length;
        const range = {
          start: document2.positionAt(startOffset),
          end: document2.positionAt(endOffset)
        };
        const text = document2.getText(range);
        const trimmedText = trimEndNewLine(text);
        const trimmedEndOffset = startOffset + trimmedText.length;
        if (trimmedEndOffset >= offset) {
          range.end = document2.positionAt(trimmedEndOffset);
        }
        const isSurroundedBy = (startCharacter, endCharacter) => {
          return trimmedText.startsWith(startCharacter) && trimmedText.endsWith(endCharacter || startCharacter);
        };
        if (currentNode.type === "string" && (isSurroundedBy("'") || isSurroundedBy('"')) || currentNode.type === "object" && isSurroundedBy("{", "}") || currentNode.type === "array" && isSurroundedBy("[", "]")) {
          result.push({
            start: document2.positionAt(startOffset + 1),
            end: document2.positionAt(endOffset - 1)
          });
        }
        result.push(range);
        currentNode = currentNode.parent;
        overrideStartOffset = void 0;
      }
      if (result.length > 0) {
        break;
      }
    }
    return result.reverse();
  }
  function getStartOffsetForSpecialCases(node, position) {
    var _a4;
    const nodeStartPosition = document2.positionAt(node.offset);
    if (nodeStartPosition.line !== position.line) {
      return;
    }
    if (((_a4 = node.parent) == null ? void 0 : _a4.type) === "array") {
      if (getTextFromOffsets(node.offset - 2, node.offset) === "- ") {
        return node.offset - 2;
      }
    }
    if (node.type === "array" || node.type === "object") {
      const lineBeginning = { line: nodeStartPosition.line, character: 0 };
      const text = document2.getText({ start: lineBeginning, end: nodeStartPosition });
      if (text.trim().length === 0) {
        return document2.offsetAt(lineBeginning);
      }
    }
  }
  function getTextFromOffsets(startOffset, endOffset) {
    return document2.getText({
      start: document2.positionAt(startOffset),
      end: document2.positionAt(endOffset)
    });
  }
}
function trimEndNewLine(str) {
  if (str.endsWith("\r\n")) {
    return str.substring(0, str.length - 2);
  }
  if (str.endsWith("\n")) {
    return str.substring(0, str.length - 1);
  }
  return str;
}
var SchemaPriority;
(function(SchemaPriority2) {
  SchemaPriority2[SchemaPriority2["SchemaStore"] = 1] = "SchemaStore";
  SchemaPriority2[SchemaPriority2["SchemaAssociation"] = 2] = "SchemaAssociation";
  SchemaPriority2[SchemaPriority2["Settings"] = 3] = "Settings";
})(SchemaPriority || (SchemaPriority = {}));
function getLanguageService(params) {
  const schemaService = new YAMLSchemaService(params.schemaRequestService, params.workspaceContext);
  const completer = new YamlCompletion(schemaService, params.clientCapabilities, yamlDocumentsCache, params.telemetry);
  const hover = new YAMLHover(schemaService, params.telemetry);
  const yamlDocumentSymbols = new YAMLDocumentSymbols(schemaService, params.telemetry);
  const yamlValidation = new YAMLValidation(schemaService, params.telemetry);
  const formatter = new YAMLFormatter();
  const yamlCodeActions = new YamlCodeActions(params.clientCapabilities);
  const yamlCodeLens = new YamlCodeLens(schemaService, params.telemetry);
  const yamlLinks = new YamlLinks(params.telemetry);
  const yamlDefinition = new YamlDefinition(params.telemetry);
  new JSONSchemaSelection(schemaService, params.yamlSettings, params.connection);
  return {
    configure: (settings) => {
      schemaService.clearExternalSchemas();
      if (settings.schemas) {
        schemaService.schemaPriorityMapping = /* @__PURE__ */ new Map();
        settings.schemas.forEach((settings2) => {
          const currPriority = settings2.priority ? settings2.priority : 0;
          schemaService.addSchemaPriority(settings2.uri, currPriority);
          schemaService.registerExternalSchema(settings2.uri, settings2.fileMatch, settings2.schema, settings2.name, settings2.description, settings2.versions);
        });
      }
      yamlValidation.configure(settings);
      hover.configure(settings);
      completer.configure(settings);
      formatter.configure(settings);
      yamlCodeActions.configure(settings);
    },
    registerCustomSchemaProvider: (schemaProvider) => {
      schemaService.registerCustomSchemaProvider(schemaProvider);
    },
    findLinks: yamlLinks.findLinks.bind(yamlLinks),
    doComplete: completer.doComplete.bind(completer),
    doValidation: yamlValidation.doValidation.bind(yamlValidation),
    doHover: hover.doHover.bind(hover),
    findDocumentSymbols: yamlDocumentSymbols.findDocumentSymbols.bind(yamlDocumentSymbols),
    findDocumentSymbols2: yamlDocumentSymbols.findHierarchicalDocumentSymbols.bind(yamlDocumentSymbols),
    doDefinition: yamlDefinition.getDefinition.bind(yamlDefinition),
    resetSchema: (uri) => {
      return schemaService.onResourceChange(uri);
    },
    doFormat: formatter.format.bind(formatter),
    doDocumentOnTypeFormatting,
    addSchema: (schemaID, schema4) => {
      return schemaService.saveSchema(schemaID, schema4);
    },
    deleteSchema: (schemaID) => {
      return schemaService.deleteSchema(schemaID);
    },
    modifySchemaContent: (schemaAdditions) => {
      return schemaService.addContent(schemaAdditions);
    },
    deleteSchemaContent: (schemaDeletions) => {
      return schemaService.deleteContent(schemaDeletions);
    },
    deleteSchemasWhole: (schemaDeletions) => {
      return schemaService.deleteSchemas(schemaDeletions);
    },
    getFoldingRanges,
    getSelectionRanges,
    getCodeAction: (document2, params2) => {
      return yamlCodeActions.getCodeAction(document2, params2);
    },
    getCodeLens: (document2) => {
      return yamlCodeLens.getCodeLens(document2);
    },
    resolveCodeLens: (param) => yamlCodeLens.resolveCodeLens(param)
  };
}
async function schemaRequestService(uri) {
  const response = await fetch(uri);
  if (response.ok) {
    return response.text();
  }
  throw new Error(`Schema request failed for ${uri}`);
}
var telemetry = {
  send() {
  },
  sendError(name, error) {
    console.error("monaco-yaml", name, error);
  },
  sendTrack() {
  }
};
var workspaceContext = {
  resolveRelativePath(relativePath, resource) {
    return String(new URL(relativePath, resource));
  }
};
initialize2((ctx, { enableSchemaRequest, ...languageSettings }) => {
  const ls = getLanguageService({
    // @ts-expect-error Type definitions are wrong. This may be null.
    schemaRequestService: enableSchemaRequest ? schemaRequestService : null,
    telemetry,
    workspaceContext,
    // Copied from https://github.com/microsoft/vscode-json-languageservice/blob/493010da9dc2cd1cc139d403d4709d97064b17e9/src/jsonLanguageTypes.ts#L325-L335
    // Usage: https://github.com/microsoft/monaco-editor/blob/f6dc0eb8fce67e57f6036f4769d92c1666cdf546/src/language/json/jsonWorker.ts#L38
    clientCapabilities: {
      textDocument: {
        completion: {
          completionItem: {
            commitCharactersSupport: true,
            documentationFormat: ["markdown", "plaintext"]
          }
        },
        moniker: {}
      }
    }
  });
  const withDocument = (fn) => (uri, ...args) => {
    const models = ctx.getMirrorModels();
    for (const model of models) {
      if (String(model.uri) === uri) {
        return fn(TextDocument.create(uri, "yaml", model.version, model.getValue()), ...args);
      }
    }
  };
  ls.configure(languageSettings);
  return {
    doValidation: withDocument(
      (document2) => ls.doValidation(document2, Boolean(languageSettings.isKubernetes))
    ),
    doComplete: withDocument(
      (document2, position) => ls.doComplete(document2, position, Boolean(languageSettings.isKubernetes))
    ),
    doDefinition: withDocument(
      (document2, position) => ls.doDefinition(document2, { position, textDocument: document2 })
    ),
    doDocumentOnTypeFormatting: withDocument(
      (document2, position, ch, options) => ls.doDocumentOnTypeFormatting(document2, { ch, options, position, textDocument: document2 })
    ),
    doHover: withDocument(ls.doHover),
    format: withDocument(ls.doFormat),
    resetSchema: ls.resetSchema,
    findDocumentSymbols: withDocument(ls.findDocumentSymbols2),
    findLinks: withDocument(ls.findLinks),
    getCodeAction: withDocument(
      (document2, range, context) => ls.getCodeAction(document2, { range, textDocument: document2, context })
    ),
    getFoldingRanges: withDocument(
      (document2) => ls.getFoldingRanges(document2, { lineFoldingOnly: true })
    ),
    getSelectionRanges: withDocument(ls.getSelectionRanges)
  };
});
